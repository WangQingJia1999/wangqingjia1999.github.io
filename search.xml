<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>哈希冲突处理</title>
    <url>/2024/02/19/note/algo/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h1 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h1><h1 id="开放定址法（Open-Addressing"><a href="#开放定址法（Open-Addressing" class="headerlink" title="开放定址法（Open Addressing)"></a>开放定址法（Open Addressing)</h1><p>冲突时，按照一定规则，找到一个空闲位置。当删除某个键值对时，不能直接删除，否则影响其他键值对的查找，打个标记</p>
<p>优点：</p>
<ul>
<li>低内存开销，只需一个hash数组和一个哈希函数，无需像拉链法额外存指针维护链表，因此能用同样的空间提供更多卡槽，潜在地减少冲突可能</li>
<li>对缓存友好，发生冲突时，线性探查</li>
</ul>
<p>缺点：</p>
<ul>
<li>删除操作麻烦点，先打标记，等有元素来，才真正替换掉</li>
</ul>
<h2 id="线行探查法-Linear-Probing"><a href="#线行探查法-Linear-Probing" class="headerlink" title="线行探查法(Linear Probing)"></a>线行探查法(Linear Probing)</h2><p>发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>
<p>线性探测带来的最大问题就是冲突的堆积，你把别人预定的坑占了，别人也就要像你一样去找坑。当装填因子变大，效率降低，改进的办法有二次方探测法和随机数探测法。</p>
<h2 id="平方探查法-Quadratic-Probing"><a href="#平方探查法-Quadratic-Probing" class="headerlink" title="平方探查法(Quadratic Probing)"></a>平方探查法(Quadratic Probing)</h2><p>Let hash(x) be the slot index computed using the hash function.</p>
<ul>
<li>If the slot <code>hash(x) % S</code> is full, then we try <code>(hash(x) + 1*1) % S</code>.</li>
<li>If <code>(hash(x) + 1*1) % S</code> is also full, then we try <code>(hash(x) + 2*2) % S</code>.</li>
<li>If <code>(hash(x) + 2*2) % S</code> is also full, then we try <code>(hash(x) + 3*3) % S</code>.</li>
<li>This process is repeated for all the values of i until an empty slot is found.</li>
</ul>
<p>平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p>
<p><img src="/../assets/image-19.png" alt="Alt text"></p>
<h2 id="双重散列-Double-hashing"><a href="#双重散列-Double-hashing" class="headerlink" title="双重散列(Double hashing)"></a>双重散列(Double hashing)</h2><p><em>Double hashing can be done using :</em></p>
<p><em><strong>(hash1(key) + i * hash2(key)) % TABLE_SIZE</strong></em></p>
<p><em>Here hash1() and hash2() are hash functions and TABLE_SIZE</em></p>
<p><em>is size of hash table.</em></p>
<p><em>(We repeat by increasing i when collision occurs)</em></p>
<p>First hash function is typically hash1(key) &#x3D; key % TABLE_SIZE</p>
<p>A popular second hash function is</p>
<p><strong>hash2(key) &#x3D; PRIME – (key % PRIME)</strong></p>
<p>where PRIME is a prime smaller than the TABLE_SIZE.</p>
<p><img src="/../assets/image-18.png" alt="Alt text"></p>
<h1 id="链地址法（拉链法）（Separate-chaining）"><a href="#链地址法（拉链法）（Separate-chaining）" class="headerlink" title="链地址法（拉链法）（Separate chaining）"></a>链地址法（拉链法）（Separate chaining）</h1><ul>
<li>链表法适用于经常进行插入和删除的情况。</li>
<li>注：Java8之前版本用链接地址法单链表解决HashMap哈希冲突，Java8 则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储（以hashcode比较树中节点大小），如果树中元素低于6个则回退单链表，如果树中元素超过64个，则换更大的buckets数组重新散列，h<a href="https://stackoverflow.com/a/43911638/11850070">ttps:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;43911638&#x2F;11850070</a></li>
<li>缓存不友好，因为链表的每个节点在内存中分散存储的，不像开放地址法那样相邻。</li>
</ul>
<h1 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h1><p>就是同时构造多个不同的哈希函数：<br>当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p>
<h1 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h1><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
]]></content>
      <tags>
        <tag>algo</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/2024/02/19/note/algo/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Bloom-Filter的原理"><a href="#Bloom-Filter的原理" class="headerlink" title="Bloom Filter的原理"></a>Bloom Filter的原理</h1><p>用来告诉你 “某个元素一定不存在或者可能存在”。</p>
<p>布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个bit数组中的K个点位，把它们均置为1。</p>
<p>检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：</p>
<ul>
<li><p>如果这些点有任何一个0，则被检元素一定不在；</p>
</li>
<li><p>如果都是1，则被检元素很可能在。</p>
</li>
<li><p>缺点是有一定的误识别率和删除困难。</p>
</li>
</ul>
<p><img src="/./assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcnNvbl9DaHU=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>algo</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake备忘</title>
    <url>/2024/02/19/note/cpp/CMake%20/</url>
    <content><![CDATA[<p>add cxx flags for a target</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target_compile_options(scope_lock_exe PRIVATE -std=c++20 -Wall -Wextra -pedantic-errors -fsanitize=thread -g)</span><br><span class="line">target_link_libraries(scope_lock_exe PRIVATE tsan)</span><br></pre></td></tr></table></figure>

<p>list all targets</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake --build . --target help</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB指令备忘</title>
    <url>/2024/02/19/note/cpp/GDB/</url>
    <content><![CDATA[<p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb.pdf">GDB使用手册</a></p>
<h2 id="watchpoint"><a href="#watchpoint" class="headerlink" title="watchpoint"></a>watchpoint</h2><p>watchpoint又叫数据断点（data breakpoint），用于监控内存的读写。</p>
<h3 id="监控内存地址"><a href="#监控内存地址" class="headerlink" title="监控内存地址"></a>监控内存地址</h3><p>如果要监控 <code>0x402000</code> 上的读写。</p>
<p>如下不行，因为 <code>0x402000</code> 被当作常量，永不变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch 0x402000</span><br><span class="line">Cannot watch constant value `0x402000&#x27;.</span><br></pre></td></tr></table></figure>

<p>而要用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) watch *0x402000</span><br><span class="line">Hardware watchpoint 5: *0x402000</span><br></pre></td></tr></table></figure>

<p>如果要按hex打印变更前后数值，用如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch *(char**)0x402000</span><br><span class="line">watch *(void**)0x402000</span><br></pre></td></tr></table></figure>

<h2 id="Demangle-symbol"><a href="#Demangle-symbol" class="headerlink" title="Demangle symbol"></a>Demangle symbol</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) dem _ZTV1C</span><br><span class="line">vtable for C</span><br></pre></td></tr></table></figure>

<p>ref: <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Debugging-C-Plus-Plus.html">https://sourceware.org/gdb/current/onlinedocs/gdb.html/Debugging-C-Plus-Plus.html</a></p>
<h2 id="打印对象的虚函数表"><a href="#打印对象的虚函数表" class="headerlink" title="打印对象的虚函数表"></a>打印对象的虚函数表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info vtbl c</span><br></pre></td></tr></table></figure>

<h2 id="打印对象内部成员布局"><a href="#打印对象内部成员布局" class="headerlink" title="打印对象内部成员布局"></a>打印对象内部成员布局</h2><p>测试代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Foo foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体成员内存布局如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) pt /o foo</span><br><span class="line"><span class="comment">/* offset    |  size */</span>  type = <span class="keyword">struct</span> Foo &#123;</span><br><span class="line"><span class="comment">/*    0      |     1 */</span>    <span class="type">char</span> a;</span><br><span class="line"><span class="comment">/* XXX  3-byte hole */</span></span><br><span class="line"><span class="comment">/*    4      |     4 */</span>    <span class="type">int</span> b;</span><br><span class="line"><span class="comment">/*    8      |     8 */</span>    <span class="type">double</span> c;</span><br><span class="line"><span class="comment">/* total size (bytes):   16 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="找到类型定义的源文件位置"><a href="#找到类型定义的源文件位置" class="headerlink" title="找到类型定义的源文件位置"></a>找到类型定义的源文件位置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info types _Atomic_word</span><br><span class="line">All types matching regular expression &quot;_Atomic_word&quot;:</span><br><span class="line"></span><br><span class="line">File /opt/rh/devtoolset-8/root/usr/include/c++/8/x86_64-redhat-linux/bits/atomic_word.h:</span><br><span class="line">32:     typedef int _Atomic_word;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过正则表达式搜索所有包含pattern的类型，比如会搜到模板参数实例化为pattern的类型，因此精确搜索要加上^和$，限制字符左右边界。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info types ^__gnu_cxx::_Lock_policy$</span><br><span class="line">All types matching regular expression &quot;^__gnu_cxx::_Lock_policy$&quot;:</span><br><span class="line"></span><br><span class="line">File /opt/rh/devtoolset-8/root/usr/include/c++/8/ext/concurrence.h:</span><br><span class="line">49:     __gnu_cxx::_Lock_policy;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 模板类型推导</title>
    <url>/2024/02/19/note/cpp/Template%20Type%20Deduction%20/</url>
    <content><![CDATA[<h1 id="Template-Type-Deduction"><a href="#Template-Type-Deduction" class="headerlink" title="Template Type Deduction"></a>Template Type Deduction</h1><p>例子见：<a href="https://stackoverflow.com/a/47125430/11850070">https://stackoverflow.com/a/47125430/11850070</a></p>
<p>用 godbolt 直接看生成汇编，call void f<int>(int&amp;) 尖括号里是T，圆括号里是ParamType。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(expr);    <span class="comment">// deduce T and ParamType from expr</span></span><br></pre></td></tr></table></figure>

<p>Three cases:</p>
<ul>
<li>ParamType is either a pointer or a reference, but not a universal reference.</li>
<li>ParamType is a universal reference.</li>
<li>ParamType is neither a pointer nor a reference.</li>
</ul>
<h1 id="Case-1-ParamType-is-or-but-not"><a href="#Case-1-ParamType-is-or-but-not" class="headerlink" title="Case 1: ParamType is * or &amp; but not &amp;&amp;"></a>Case 1: ParamType is * or &amp; but not &amp;&amp;</h1><ol>
<li>If expr’s type is a reference, ignore the reference part.</li>
<li>Then pattern-match expr’s type against ParamType to determine T.</li>
</ol>
<p>e.g.</p>
<ul>
<li><a href="https://godbolt.org/z/11bhh1fob">https://godbolt.org/z/11bhh1fob</a></li>
</ul>
<h1 id="Case-2-ParamType-is"><a href="#Case-2-ParamType-is" class="headerlink" title="Case 2: ParamType is &amp;&amp;"></a>Case 2: ParamType is &amp;&amp;</h1><ol>
<li>If expr is an lvalue, both T and ParamType are deduced to be lvalue references.<ul>
<li>That’s doubly unusual.<ol>
<li>First, it’s the only situation in template type deduction<br>where <strong>T is deduced to be a reference</strong>. </li>
<li>Second, although ParamType is declared using the syntax for an rvalue reference, its deduced type is an lvalue reference.</li>
</ol>
</li>
</ul>
</li>
<li>If expr is an rvalue,  ignore &amp;&amp; and pattern-match expr’s type against ParamType to determine T. That is when an rvalue is passed, T is deduced to be a non-reference.</li>
</ol>
<h1 id="Case-3-ParamType-is-neither-a-pointer-nor-a-reference"><a href="#Case-3-ParamType-is-neither-a-pointer-nor-a-reference" class="headerlink" title="Case 3: ParamType is neither a pointer nor a reference"></a>Case 3: ParamType is neither a pointer nor a reference</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T param)</span></span>; <span class="comment">// param is passed by value</span></span><br></pre></td></tr></table></figure>

<ol>
<li>If the type of <code>expr</code> is a reference, ignore the reference part as before.</li>
<li>After ignoring the reference-ness of <code>expr</code>, if it is <code>const</code>, ignore that as well. If it is <code>volatile</code>, ignore that too.</li>
</ol>
<p>总结就是忽略ref，const，volatile修饰。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Universal Reference vs Forwarding Reference</title>
    <url>/2024/02/19/note/cpp/Universal%20Reference%20Forwarding%20Reference/</url>
    <content><![CDATA[<h1 id="Universal-Reference-Forwarding-Reference"><a href="#Universal-Reference-Forwarding-Reference" class="headerlink" title="Universal Reference &#x2F; Forwarding Reference"></a>Universal Reference &#x2F; Forwarding Reference</h1><p>两个名词指同一个东西，Universal Reference 是 Scott Meyers 提出的，而标准用的是Forwarding Reference，来源：<a href="https://stackoverflow.com/a/39552345/11850070">https://stackoverflow.com/a/39552345/11850070</a></p>
<h1 id="什么是通用引用（Universal-Reference）"><a href="#什么是通用引用（Universal-Reference）" class="headerlink" title="什么是通用引用（Universal Reference）"></a>什么是通用引用（Universal Reference）</h1><p>T&amp;&amp;形式且有类型推导，有函数模板通用引用参数和auto通用引用，通用引用可以绑定左值或者右值，配合std::forward实现完美转发。</p>
<h1 id="怎么辨别Universal-Reference"><a href="#怎么辨别Universal-Reference" class="headerlink" title="怎么辨别Universal Reference"></a>怎么辨别Universal Reference</h1><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><ul>
<li><p>一定要有类型推导</p>
<ul>
<li><p>std::vector::push_back没有类型推导，不是通用引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;Widget&gt; v; <span class="comment">// 因为声明std::vector时就指明了T，没有类型推导</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实实例化后的类是如下，push_back的参数是rvalue ref,不是universal ref</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span>&lt;Widget, allocator&lt;Widget&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(Widget&amp;&amp; x)</span></span>; <span class="comment">// rvalue reference</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但 emplace_back 是通用引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args); <span class="comment">// emplace_back不依赖T，每处调用都要推断Args，因此是通用引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一定要是T&amp;&amp;</p>
<ul>
<li><p>形式不对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>; <span class="comment">// param is an rvalue reference</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有const就不是了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>; <span class="comment">// param is an rvalue reference</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h2><ul>
<li>形式一定是 auto&amp;&amp;</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>x86 ABI</title>
    <url>/2024/02/19/note/cpp/X86%20Linux%20ABI%20Registers%20for%20Argument%20Passing/</url>
    <content><![CDATA[<h1 id="X86-Linux-ABI-Registers-for-Argument-Passing"><a href="#X86-Linux-ABI-Registers-for-Argument-Passing" class="headerlink" title="X86 Linux ABI Registers for Argument Passing"></a>X86 Linux ABI Registers for Argument Passing</h1><p>In Linux, the registers used to pass arguments to functions are determined by the calling convention of the system, which, in turn, is influenced by the architecture of the processor. For systems running on x86-64 architecture, which is quite common, the System V Application Binary Interface (ABI) is typically used.</p>
<h1 id="Arguments"><a href="#Arguments" class="headerlink" title="Arguments"></a>Arguments</h1><h2 id="64-bit"><a href="#64-bit" class="headerlink" title="64-bit"></a>64-bit</h2><p>According to the System V x86-64 ABI, the following registers are used to pass arguments to functions:</p>
<ol>
<li><code>%rdi</code></li>
<li><code>%rsi</code></li>
<li><code>%rdx</code></li>
<li><code>%rcx</code></li>
<li><code>%r8</code></li>
<li><code>%r9</code></li>
</ol>
<p>These registers are used to hold the first six arguments of the function; if there are more than six arguments, the additional arguments are passed on the stack.</p>
<h2 id="32-bit"><a href="#32-bit" class="headerlink" title="32-bit"></a>32-bit</h2><p>On x86 architecture, the convention is slightly different. Up to four registers are assigned to arguments in the following order:</p>
<ol>
<li><code>EAX</code></li>
<li><code>EDX</code></li>
<li><code>EBX</code></li>
<li><code>ECX</code></li>
</ol>
<p>Arguments are assigned to these registers from left to right, and if any argument cannot be assigned to a register (e.g., if it’s too large), it, along with all subsequent arguments, are assigned to the stack. The arguments assigned to the stack are pushed from right to left.</p>
<p>GCC pass integer&#x2F;address via di, si, dx, cx, r8, r9 from left to right.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e, <span class="type">int</span> f)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>X86-64 GCC 9.2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func(int, int, int, int, int, int):</span><br><span class="line"></span><br><span class="line">        pushq   %rbp</span><br><span class="line"></span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line"></span><br><span class="line">        movl    %edi, -4(%rbp)</span><br><span class="line"></span><br><span class="line">        movl    %esi, -8(%rbp)</span><br><span class="line"></span><br><span class="line">        movl    %edx, -12(%rbp)</span><br><span class="line"></span><br><span class="line">        movl    %ecx, -16(%rbp)</span><br><span class="line"></span><br><span class="line">        movl    %r8d, -20(%rbp)</span><br><span class="line"></span><br><span class="line">        movl    %r9d, -24(%rbp)</span><br><span class="line"></span><br><span class="line">        nop</span><br><span class="line"></span><br><span class="line">        popq    %rbp</span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line"></span><br><span class="line">        pushq   %rbp</span><br><span class="line"></span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line"></span><br><span class="line">        movl    $6, %r9d</span><br><span class="line"></span><br><span class="line">        movl    $5, %r8d</span><br><span class="line"></span><br><span class="line">        movl    $4, %ecx</span><br><span class="line"></span><br><span class="line">        movl    $3, %edx</span><br><span class="line"></span><br><span class="line">        movl    $2, %esi</span><br><span class="line"></span><br><span class="line">        movl    $1, %edi</span><br><span class="line"></span><br><span class="line">        call    func(int, int, int, int, int, int)</span><br><span class="line"></span><br><span class="line">        movl    $0, %eax</span><br><span class="line"></span><br><span class="line">        popq    %rbp</span><br><span class="line"></span><br><span class="line">        ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Return-value"><a href="#Return-value" class="headerlink" title="Return value"></a>Return value</h1><p>on x86 the EAX register is normally used for return values. On x86-64, it’s RAX.</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ stl atomic</title>
    <url>/2024/02/19/note/cpp/atomic%20int%20counter%20/</url>
    <content><![CDATA[<h1 id="atomic-counter"><a href="#atomic-counter" class="headerlink" title="atomic counter"></a>atomic<int> counter</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">counter_atomic</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        ++counter; <span class="comment">// 生成三条汇编指令，多线程环境发生race condition</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment_atomic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i&lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 单独一条指令完成+1，多线程下没问题</span></span><br><span class="line">        <span class="comment">// 这里的 std::memory_order_relaxed 从汇编看没有任何作用</span></span><br><span class="line">        counter_atomic.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">t3</span><span class="params">(increment_atomic)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t4</span><span class="params">(increment_atomic)</span></span>;</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line">  t4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;counter value: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;counter_atomic value: &quot;</span> &lt;&lt; counter_atomic &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">counter <span class="attr">value</span>: <span class="number">1637297</span></span><br><span class="line">counter_atomic <span class="attr">value</span>: <span class="number">2000000</span></span><br></pre></td></tr></table></figure>

<p>see example list in <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">std::memory_order - cppreference.com</a>. compare the diff of memory order.</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 类型转换</title>
    <url>/2024/02/19/note/cpp/cast/</url>
    <content><![CDATA[<h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><ul>
<li>编译期类型转换</li>
<li>向上或向下</li>
</ul>
<h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p><code>dynamic_cast</code> is used primarily for safe downcasting at runtime. It’s part of the C++ Run-Time Type Identification (RTTI) facilities.</p>
<ol>
<li><strong>Purpose</strong>: <code>dynamic_cast</code> is used to safely convert pointers or references to classes up, down, or sideways along the inheritance hierarchy.</li>
<li><strong>Downcasting</strong>: This is the most common use of <code>dynamic_cast</code>. It allows you to convert a base class pointer or reference to a derived class pointer or reference. This operation checks at runtime whether the cast is valid, making it safer than <code>static_cast</code>.</li>
<li><strong>Type Checking at Runtime</strong>: <code>dynamic_cast</code> performs a runtime check. If the cast is not possible (i.e., the cast object does not contain the type being cast to), it returns <code>nullptr</code> for pointers or throws <code>std::bad_cast</code> for references.</li>
<li><strong>Polymorphic Base Classes</strong>: For <code>dynamic_cast</code> to work, the base class must be polymorphic, which means it must have at least one virtual function. This is necessary because <code>dynamic_cast</code> uses the vtable (virtual table) to determine the actual type of the object at runtime.</li>
<li><strong>Syntax</strong>:<ul>
<li>For pointers: <code>dynamic_cast&lt;DerivedClass*&gt;(baseClassPointer)</code></li>
<li>For references: <code>dynamic_cast&lt;DerivedClass&amp;&gt;(baseClassReference)</code></li>
</ul>
</li>
<li><strong>Performance Consideration</strong>: Since <code>dynamic_cast</code> involves runtime type checking, it is slower compared to other casts like <code>static_cast</code> or <code>reinterpret_cast</code>. It should be used when safety is more critical than performance, especially in a polymorphic context.</li>
<li>Upcasting with <strong><code>dynamic_cast</code></strong> is typically not necessary and is often seen as overkill, as upcasting is always safe in C++ and can be performed implicitly or using <strong><code>static_cast</code></strong>.</li>
<li>能 <strong>T* ** -&gt; *<em>void</em></strong>, 但不能 <strong>void</strong>* -&gt; <strong>T</strong>*</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="comment">// Safe downcast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际是调了编译器提供的一个函数</p>
<ul>
<li><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/dyncast.cc">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/dyncast.cc</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">movl    $<span class="number">0</span>, %ecx</span><br><span class="line">        movl    $typeinfo <span class="keyword">for</span> Derived, %edx</span><br><span class="line">        movl    $typeinfo <span class="keyword">for</span> Base, %esi</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    __dynamic_cast</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Clang查看C++模板实例化后代码</title>
    <url>/2024/02/19/note/cpp/clang/</url>
    <content><![CDATA[<h1 id="Clang-AST"><a href="#Clang-AST" class="headerlink" title="Clang AST"></a>Clang AST</h1><p>see the compiler-instantiated code for a function template or a class template in C++?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">clang++ -Xclang -ast-print -fsyntax-only vector.cpp &gt; vector_clang.cpp</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/a/46573566/11850070">source</a></p>
<p>What <code>-ast-print</code> produces is a textual representation of the AST.</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ lambda 中 mutable 关键字</title>
    <url>/2024/02/19/note/cpp/cpp%20lambda/</url>
    <content><![CDATA[<h1 id="lambda-“mutable”-keyword"><a href="#lambda-“mutable”-keyword" class="headerlink" title="lambda “mutable” keyword"></a>lambda “mutable” keyword</h1><p>lamda按值捕获的变量不能修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x]() &#123;</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">&lt;source&gt;: In lambda function:</span><br><span class="line">&lt;source&gt;:<span class="number">7</span>:<span class="number">11</span>: error: increment of read-only variable <span class="string">&#x27;x&#x27;</span></span><br><span class="line">    <span class="number">7</span> |         ++x;</span><br><span class="line">      |           ^</span><br></pre></td></tr></table></figure>

<p>除非加上mutable</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        ++x;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>You have to understand what capture means! it’s capturing not argument passing! let’s look at some code samples:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">auto</span> lamb = [x]() &#123;<span class="keyword">return</span> x + <span class="number">5</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    y= <span class="built_in">lamb</span>();</span><br><span class="line">    cout &lt;&lt; y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt; x &lt;&lt; endl; <span class="comment">//outputs 10,5</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="built_in">lamb</span>();</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">//output 10,20</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两处lamb()调用其实用的同一个对象，且对象中按值捕获的成员x不能修改（operator()带有const修饰）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_9_17</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    __lambda_9_17(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  __lambda_9_17 lamb = __lambda_9_17&#123;x&#125;;</span><br><span class="line">  y = lamb.<span class="built_in">operator</span>()();</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(y), <span class="string">&quot;,&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(x).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">  x = <span class="number">20</span>;</span><br><span class="line">  y = lamb.<span class="built_in">operator</span>()();</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(y), <span class="string">&quot;,&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(x).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As you can see even though <code>x</code> has been changed to <code>20</code> the lambda is still returning 10 ( <code>x</code> is still <code>5</code> inside the lambda) Changing <code>x</code> inside the lambda means changing the lambda itself at each call (the lambda is mutating at each call). To enforce correctness the standard introduced the <code>mutable</code> keyword. By specifying a lambda as mutable you are saying that each call to the lambda could cause a change in the lambda itself. Let see another example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">auto</span> lamb = [x]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> x++ + <span class="number">5</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    y= <span class="built_in">lamb</span>();</span><br><span class="line">    cout &lt;&lt; y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt; x &lt;&lt; endl; <span class="comment">//outputs 10,5</span></span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    y = <span class="built_in">lamb</span>();</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; x &lt;&lt; endl; <span class="comment">//outputs 11,20</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了mutable后，operator()没有const修饰，可以在内部修改按值捕获的x</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_9_17</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">inline</span> <span class="comment">/*constexpr */</span> <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x++ + <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    __lambda_9_17(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  __lambda_9_17 lamb = __lambda_9_17&#123;x&#125;;</span><br><span class="line">  y = lamb.<span class="built_in">operator</span>()();</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(y), <span class="string">&quot;,&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(x).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">  x = <span class="number">20</span>;</span><br><span class="line">  y = lamb.<span class="built_in">operator</span>()();</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(y), <span class="string">&quot;,&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(x).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above example shows that by making the lambda mutable, changing <code>x</code> inside the lambda “mutates” the lambda at each call with a new value of <code>x</code> that has no thing to do with the actual value of <code>x</code> in the main function</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>coredump备忘</title>
    <url>/2024/02/19/note/cpp/coredump/</url>
    <content><![CDATA[<p>The location of the core file depends on <code>/proc/sys/kernel/core_pattern</code></p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 复现线程死锁</title>
    <url>/2024/02/19/note/cpp/cpp_deadlock%20/</url>
    <content><![CDATA[<h1 id="Deadlock"><a href="#Deadlock" class="headerlink" title="Deadlock"></a>Deadlock</h1><h1 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h1><p>死锁必须<strong>同时满足</strong>以下四个条件才会发生：</p>
<ul>
<li>互斥条件：操作的锁是互斥锁</li>
<li>持有并等待条件：线程已经持有一个互斥锁L1后，又要获取另外一个互斥锁L2，没取到L2就一直持有L1等待</li>
<li>不可剥夺条件：谁加锁谁释放</li>
<li>环路等待条件：T1加锁L1，尝试加锁L2；T2已加锁L2，尝试加锁L1，形成环路等待。</li>
</ul>
<p><img src="/../assets/image-8.png" alt="Alt text"></p>
<h1 id="复现死锁"><a href="#复现死锁" class="headerlink" title="复现死锁"></a>复现死锁</h1><p>两个线程先各自加一个锁，各自等待1s后，尝试取对方已加的锁，死锁发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mutex1;</span><br><span class="line">std::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="怎么排查死锁"><a href="#怎么排查死锁" class="headerlink" title="怎么排查死锁"></a>怎么排查死锁</h1><p>gdb yyds</p>
<p>__owner标识是谁加的锁，由此看出死锁了</p>
<p><img src="/../assets/image-7.png" alt="Alt text"></p>
<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p>破环任何一个必要条件，最常见的并且可行的就是 <strong>每个线程都按相同顺序加锁</strong>。</p>
<p>T1 和 T2 加锁顺序一样，T1先加L1后加L2，那T2也先加L1后加L2。</p>
<p>只需改动T2加锁顺序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mutex1;</span><br><span class="line">std::mutex mutex2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T2和T1一样，先加L1再加L2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mutex1)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>)); <span class="comment">// Simulate some work</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mutex2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(threadFunction1)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(threadFunction2)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ inline 关键字</title>
    <url>/2024/02/19/note/cpp/cpp_inline/</url>
    <content><![CDATA[<blockquote>
<p><code>extern</code>, <code>static</code>, <code>inline</code> are linkage directives, used almost exclusively by the linker, not the compiler.</p>
</blockquote>
<ul>
<li><p>static - the variable&#x2F;function name cannot be used in other translation units. Linker needs to make sure it doesn’t accidentally use a statically defined variable&#x2F;function from another translation unit.</p>
</li>
<li><p>extern - use this variable&#x2F;function name in this translation unit but don’t complain if it isn’t defined. The linker will sort it out and make sure all the code that tried to use some extern symbol has its address.</p>
</li>
<li><p>inline - this function will be defined in multiple translation units, don’t worry about it. The linker needs to make sure all translation units use a single instance of the variable&#x2F;function.</p>
</li>
</ul>
<h1 id="inline-func"><a href="#inline-func" class="headerlink" title="inline func"></a>inline func</h1><h1 id="gcc-always-inline"><a href="#gcc-always-inline" class="headerlink" title="gcc always inline"></a>gcc always inline</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__((always_inline)) <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="汇编层面看inline"><a href="#汇编层面看inline" class="headerlink" title="汇编层面看inline"></a>汇编层面看inline</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">__attribute__((always_inline)) <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bar</span>():</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        movl    $<span class="number">10</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">        nop</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        subq    $<span class="number">16</span>, %rsp</span><br><span class="line"></span><br><span class="line">        movl    $<span class="number">10</span>, <span class="number">-4</span>(%rbp)  <span class="comment">// 调用被 inline 的foo()，省去了栈操作汇编指令</span></span><br><span class="line">        <span class="function">nop                    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        call    <span class="title">bar</span><span class="params">()</span>          <span class="comment">// 调用没有 inline 的bar()</span></span></span><br><span class="line"><span class="function">        movl    $0, %eax</span></span><br><span class="line"><span class="function">        leave</span></span><br><span class="line"><span class="function">        ret</span></span><br></pre></td></tr></table></figure>

<h1 id="类成员函数是否全默认inline"><a href="#类成员函数是否全默认inline" class="headerlink" title="类成员函数是否全默认inline"></a>类成员函数是否全默认inline</h1><p>成员函数不是默认全inline。</p>
<p>启用inline情况</p>
<ul>
<li>显式：用inline关键字</li>
<li>隐式：在类声明时直接定义</li>
</ul>
<p>两种情况都必须将inline成员定义在头文件，除非是这个成员函数只用在一个特定的cpp文件中这种极其特殊的情况。因为如果把inline成员定义在cpp文件中，那么其他cpp调了该成员，链接器就报错 “undefined reference to xxx”. &#x2F;link</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 隐式inline: 在类的声明内定义</span></span><br><span class="line">    __attribute__((always_inline)) <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式inline: 在类的声明外定义且加inline关键字</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式inline: 在类的声明内定义且加inline关键字</span></span><br><span class="line">    __attribute__((always_inline)) <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__attribute__((always_inline)) <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">C::bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">234</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">    c.<span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">    c.<span class="built_in">bar</span>();</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">    c.<span class="built_in">yar</span>();</span><br><span class="line">    <span class="built_in">asm</span>(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        -------------------</span><br><span class="line">        movl    $<span class="number">123</span>, <span class="number">-12</span>(%rbp)</span><br><span class="line">        nop</span><br><span class="line">        -------------------</span><br><span class="line">        movl    $<span class="number">234</span>, <span class="number">-8</span>(%rbp)</span><br><span class="line">        nop</span><br><span class="line">        -------------------</span><br><span class="line">        movl    $<span class="number">456</span>, <span class="number">-4</span>(%rbp)</span><br><span class="line">        nop</span><br><span class="line">        -------------------</span><br><span class="line">        movl    $<span class="number">0</span>, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h1 id="类成员在cpp文件中用inline报错复现"><a href="#类成员在cpp文件中用inline报错复现" class="headerlink" title="类成员在cpp文件中用inline报错复现"></a>类成员在cpp文件中用inline报错复现</h1><p><code>inline.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>inline.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> __attribute__((always_inline)) <span class="function"><span class="type">void</span> <span class="title">C::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C::foo\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C::bar\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>use-inline.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Uncomment the following line to see the error:</span></span><br><span class="line">    <span class="comment">// c.foo();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ use-<span class="keyword">inline</span>.cpp <span class="keyword">inline</span>.cpp</span><br></pre></td></tr></table></figure>

<h2 id="虚函数（virtual）可以是内联函数（inline）吗？"><a href="#虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗？"></a>虚函数（virtual）可以是内联函数（inline）吗？</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL 容器对比</title>
    <url>/2024/02/19/note/cpp/cpp_stl/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>容器</th>
<th>底层数据结构</th>
<th>时间复杂度</th>
<th>有无序</th>
<th>可不可重复</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td>
<td>数组</td>
<td>随机读改 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td>
<td>数组</td>
<td>随机读改、尾部插入、尾部删除 O(1)<br/>头部插入、头部删除 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td>
<td>双端队列</td>
<td>头尾插入、头尾删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td>
<td>单向链表</td>
<td>插入、删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td>
<td>双向链表</td>
<td>插入、删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td>
<td>deque &#x2F; list</td>
<td>顶部插入、顶部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td>
<td>deque &#x2F; list</td>
<td>尾部插入、头部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td>
<td>vector + max-heap</td>
<td>插入、删除 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td>vector容器+heap处理规则</td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td>
<td>红黑树</td>
<td>插入、删除、查找 O(log<sub>2</sub>n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
</tbody></table>
<img src="assets/2023-11-22-08-17-50-image.png" title="" alt="" width="446">

<h1 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h1><blockquote>
<p>The Standard effectively mandates that implementations of <a href="https://en.cppreference.com/w/cpp/container/unordered_set"><code>std::unordered_set</code></a> and <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a> - and their “multi” brethren - use <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining"><em>open hashing</em> aka <em>separate chaining</em></a>, which means an array of buckets, each of which holds the head of a linked list†.</p>
</blockquote>
<ul>
<li>LLVM libc++ <code>unordered_map</code> is a <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/__hash_table#L946">unique_ptr to an array</a> of linked lists of <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/__hash_table#L70">__hash_node</a>s</li>
<li>GNU libstdc++ <code>unordered_map</code> is a <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/hashtable.h#L312">pointer to an array</a> of linked lists of <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/hashtable_policy.h#L227">_Hash_node</a>s</li>
</ul>
<h1 id="Red-Black-Tree"><a href="#Red-Black-Tree" class="headerlink" title="Red-Black Tree"></a>Red-Black Tree</h1><p>std::map &#x2F; std::set 底层实现都是红黑树。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ volatile 关键字</title>
    <url>/2024/02/19/note/cpp/cpp_volatile/</url>
    <content><![CDATA[<h1 id="c-Why-do-we-use-volatile-keyword-Stack-Overflow"><a href="#c-Why-do-we-use-volatile-keyword-Stack-Overflow" class="headerlink" title="c++ - Why do we use volatile keyword? - Stack Overflow"></a>c++ - Why do we use volatile keyword? - Stack Overflow</h1><p><a href="https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword/4437555#4437555">https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword/4437555#4437555</a></p>
<p>Consider this code,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> some_int = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(some_int == <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When this program gets compiled, the compiler may optimize this code, if it finds that the program <strong>never</strong> ever makes any attempt to change the value of <code>some_int</code>, so it may be tempted to optimize the <code>while</code> loop by changing it from <code>while(some_int == 100)</code> to <em>something</em> which is equivalent to <code>while(true)</code> so that the execution could be fast (since the condition in <code>while</code> loop appears to be <code>true</code> always). <em>(if the compiler doesn’t optimize it, then it has to fetch the value of <code>some_int</code> and compare it with 100, in each iteration which obviously is a little bit slow.)</em></p>
<p>However, sometimes, optimization (of some parts of your program) may be <strong>undesirable</strong>, because it may be that someone else is changing the value of <code>some_int</code> from <strong>outside the program which compiler is not aware of</strong>, since it can’t see it; but it’s how you’ve designed it. In that case, compiler’s optimization would <strong>not</strong> produce the desired result!</p>
<p>So, to ensure the desired result, you need to somehow stop the compiler from optimizing the <code>while</code> loop. That is where the <code>volatile</code> keyword plays its role. All you need to do is this,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile int some_int = 100; //note the &#x27;volatile&#x27; qualifier now!</span><br></pre></td></tr></table></figure>

<p>In other words, I would explain this as follows:</p>
<p><code>volatile</code> tells the compiler that,</p>
<blockquote>
<p>“Hey compiler, I’m volatile and, you know, I can be changed by some XYZ that you’re not even aware of. That XYZ could be anything. Maybe some alien outside this planet called program. Maybe some lightning, some form of interrupt, volcanoes, etc can mutate me. Maybe. You never know who is going to change me! So O you ignorant, stop playing an all-knowing god, and don’t dare touch the code where I’m present. Okay?”</p>
</blockquote>
<p>Well, that is how <code>volatile</code> prevents the compiler from optimizing code. Now search the web to see some sample examples.</p>
<p>Quoting from the C++ Standard ($7.1.5.1&#x2F;8)</p>
<blockquote>
<p>[..] volatile is a hint to the implementation to <strong>avoid aggressive optimization involving the object</strong> because the value of the object might be changed by means undetectable by an implementation.[…]</p>
</blockquote>
<p>例子：在编译器看来恒为true的条件，如果编译开启了优化，则会跳过判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> some_int = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(some_int == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加 <code>-O1</code> 优化，直接调 <code>foo()</code> ，跳过了检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string &quot;foo()\n&quot;</span><br><span class="line">foo():</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        movl    $6, %edx</span><br><span class="line">        movl    $.LC0, %esi</span><br><span class="line">        movl    $_ZSt4cout, %edi</span><br><span class="line">        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long)</span><br><span class="line">        addq    $8, %rsp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        call    foo()</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        addq    $8, %rsp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>加上 <code>volatile</code> ，禁止编译器优化 <code>some_int</code> 变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> some_int = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(some_int == <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">foo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次乖乖取取内存中值，<code>some_int</code> 本身是存在栈内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.LC0:</span><br><span class="line">        .string &quot;foo()\n&quot;</span><br><span class="line">foo():</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        movl    $6, %edx</span><br><span class="line">        movl    $.LC0, %esi</span><br><span class="line">        movl    $_ZSt4cout, %edi</span><br><span class="line">        call    std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long)</span><br><span class="line">        addq    $8, %rsp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        subq    $24, %rsp</span><br><span class="line">        movl    $100, 12(%rsp)</span><br><span class="line">        movl    12(%rsp), %eax</span><br><span class="line">        cmpl    $100, %eax</span><br><span class="line">        je      .L6</span><br><span class="line">.L4:</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        addq    $24, %rsp</span><br><span class="line">        ret</span><br><span class="line">.L6:</span><br><span class="line">        call    foo()</span><br><span class="line">        jmp     .L4</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++静态变量</title>
    <url>/2024/02/19/note/cpp/cpp%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="存哪里了？"><a href="#存哪里了？" class="headerlink" title="存哪里了？"></a>存哪里了？</h1><ul>
<li>未初始化或初始化为0的存 <code>.bss</code></li>
<li>初始化为非0的存 <code>.data</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> s_null;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_0 = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objdump -C -t demo | grep s_</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000601034</span> l     O .bss   <span class="number">0000000000000004</span>              s_null</span><br><span class="line"><span class="number">0000000000601038</span> l     O .bss   <span class="number">0000000000000004</span>              s_0</span><br><span class="line"><span class="number">000000000060102</span>c l     O .data  <span class="number">0000000000000004</span>              s_1</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ dynamic_cast</title>
    <url>/2024/02/19/note/cpp/dynamic_cast/</url>
    <content><![CDATA[<p><code>dynamic_cast</code> is used primarily for polymorphism. When you have a pointer or reference to a base type, <code>dynamic_cast</code> helps in safely converting it to a derived type. Here’s a summary of the key points about <code>dynamic_cast</code>:</p>
<ol>
<li><p><strong>Polymorphic Types</strong>: <code>dynamic_cast</code> is used with polymorphic types, i.e., classes with at least one virtual function. The presence of a virtual function enables RTTI (Run-Time Type Identification), which <code>dynamic_cast</code> relies on to safely cast between types.</p>
</li>
<li><p><strong>Safe Casting</strong>: Unlike other casting operators like <code>static_cast</code> or <code>reinterpret_cast</code>, <code>dynamic_cast</code> performs a runtime check to ensure that the object being cast actually is of the target type or can be safely cast to it. This makes <code>dynamic_cast</code> safer, but also a bit slower.</p>
</li>
<li><p><strong>Syntax</strong>:</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dynamic_cast &lt;target-type&gt; (expression)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Usage</strong>:</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> virtual <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = new Derived;</span><br><span class="line">Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);  <span class="comment">// Safe cast</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Runtime Check</strong>:<br>If the cast is successful, <code>dynamic_cast</code> returns a pointer to the target type. If the cast fails and the expression is a pointer type, it returns <code>nullptr</code>. If the expression is a reference type and the cast fails, it throws a <code>std::bad_cast</code> exception.</p>
</li>
<li><p><strong>Performance</strong>:<br>Since <code>dynamic_cast</code> requires runtime checking, it is slower compared to other casting operators. It’s advisable to use it only when necessary, for example when dealing with polymorphic types and there’s a need to ensure the safety of the cast.</p>
</li>
<li><p>Upcasting with <strong><code>dynamic_cast</code></strong> is typically not necessary and is often seen as overkill, as upcasting is always safe in C++ and can be performed implicitly or using <strong><code>static_cast</code></strong>.</p>
</li>
</ol>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> Derived;</span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);  <span class="comment">// Safe downcast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际是调了编译器提供的一个函数</p>
<ul>
<li><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/dyncast.cc">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/libsupc%2B%2B/dyncast.cc</a></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">movl    $<span class="number">0</span>, %ecx</span><br><span class="line">        movl    $typeinfo <span class="keyword">for</span> Derived, %edx</span><br><span class="line">        movl    $typeinfo <span class="keyword">for</span> Base, %esi</span><br><span class="line">        movq    %rax, %rdi</span><br><span class="line">        call    __dynamic_cast</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ explicit 关键字</title>
    <url>/2024/02/19/note/cpp/explicit/</url>
    <content><![CDATA[<p>加在哪: 只有一个参数的构造参数, 或者有多个参数，但只有一个没有默认值的构造函数声明前。<br>原则：默认全加上，除非能找出合适的转换情况。</p>
<p>Constructors that take a single std::initializer_list parameter should also omit explicit, in order to support copy-initialization (e.g., MyType m &#x3D; {1, 2};).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">int</span> n) &#123;&#125;;</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *p) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不加explict, 调的是 String(int n)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    subq    $16, %rsp</span><br><span class="line">    leaq    -1(%rbp), %rax</span><br><span class="line">    movl    $97, %esi</span><br><span class="line">    movq    %rax, %rdi</span><br><span class="line">    call    String::String(int) [complete object constructor]</span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    leave</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内部链接与外部链接</title>
    <url>/2024/02/19/note/cpp/internal%20linkage%20external%20linkage/</url>
    <content><![CDATA[<h1 id="内部链接与外部链接"><a href="#内部链接与外部链接" class="headerlink" title="内部链接与外部链接"></a>内部链接与外部链接</h1><h2 id="内部链接（Internal-Linkage）"><a href="#内部链接（Internal-Linkage）" class="headerlink" title="内部链接（Internal Linkage）:"></a><strong>内部链接（Internal Linkage）:</strong></h2><ol>
<li><strong>作用域</strong>：内部链接标识的符号仅在所定义的翻译单元可访问，其他翻译单元不可访问。</li>
<li><strong>声明</strong>：<ol>
<li>使用 <strong><code>static</code></strong> 关键字</li>
<li>非 <code>extern</code> 的 <code>const</code>   </li>
<li>匿名命名空间内部所定义的符号为内部链接。</li>
</ol>
</li>
<li><strong>用途</strong>：<ul>
<li>限制作用域，避免命名冲突</li>
<li>封装实现细节</li>
</ul>
</li>
</ol>
<h2 id="外部链接（External-Linkage）"><a href="#外部链接（External-Linkage）" class="headerlink" title="外部链接（External Linkage）:"></a><strong>外部链接（External Linkage）:</strong></h2><ol>
<li><strong>作用域</strong>：外部链接符号在整个程序的所有翻译单元内均可访问。</li>
<li><strong>声明</strong>：<ol>
<li>全局符号默认为外部链接链接。</li>
<li>使用 <strong><code>extern</code></strong> 关键字显式指定。符号定义到当前编译单元或其他链接的编译单元均可。</li>
</ol>
</li>
<li><strong>用途</strong>：<ul>
<li>多个翻译单元共享符号。</li>
</ul>
</li>
</ol>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// internal linkage</span></span><br><span class="line"><span class="type">int</span> v_gloabl;</span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">	<span class="type">int</span> v_anonymous_namespace;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> v_const = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// global linkage</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> v_extern;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> v_static;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二列 l 代表 local，g 代表 global</span></span><br><span class="line">$ objdump -C -t a.out | grep v_</span><br><span class="line"><span class="number">0000000000002018</span> l     O .bss   <span class="number">0000000000000004</span>              v_static</span><br><span class="line"><span class="number">000000000000201</span>c l     O .bss   <span class="number">0000000000000004</span>              (anonymous <span class="keyword">namespace</span>)::v_anonymous_namespace</span><br><span class="line"><span class="number">00000000000006</span>cc l     O .rodata        <span class="number">0000000000000004</span>              v_const</span><br><span class="line"><span class="number">0000000000002014</span> g     O .bss   <span class="number">0000000000000004</span>              v_gloabl</span><br><span class="line"><span class="number">0000000000002020</span> g     O .bss   <span class="number">0000000000000004</span>              v_extern</span><br></pre></td></tr></table></figure>


<h2 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h2><p>声明一个符号为外部链接，即全局链接，告知编译器这个符号可能定义在任意一个编译单元，由链接器负责最终找这个定义。</p>
<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接在当前编译单元定义也行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lib.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先分别编译成 .o 文件</span></span><br><span class="line">g++ -g -c main.cpp -o main.o</span><br><span class="line">g++ -g -c lib.cpp -o lib.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再链接成可执行文件</span></span><br><span class="line">g++ lib.o main.o -o main.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编目标文件和可执行文件</span></span><br><span class="line">objdump -C -D main.o &gt; main.o.s</span><br><span class="line">objdump -C -D lib.o &gt; lib.o.s</span><br><span class="line">objdump -C -D main.exe &gt; main.exe.s</span><br></pre></td></tr></table></figure>

<p>main.o </p>
<ul>
<li>注意其中 callq 的地址是相对地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;bar()&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   4:	b8 02 00 00 00       	mov    $0x2,%eax</span><br><span class="line">   9:	5d                   	pop    %rbp</span><br><span class="line">   a:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000000000b &lt;main&gt;:</span><br><span class="line">   b:	55                   	push   %rbp</span><br><span class="line">   c:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   f:	e8 00 00 00 00       	callq  14 &lt;main+0x9&gt;</span><br><span class="line">  14:	e8 00 00 00 00       	callq  19 &lt;main+0xe&gt;</span><br><span class="line">  19:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  1e:	5d                   	pop    %rbp</span><br><span class="line">  1f:	c3                   	retq   </span><br></pre></td></tr></table></figure></li>
</ul>
<p>lib.o.s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;foo()&gt;:</span><br><span class="line">   0:	55                   	push   %rbp</span><br><span class="line">   1:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">   4:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">   9:	5d                   	pop    %rbp</span><br><span class="line">   a:	c3                   	retq   </span><br></pre></td></tr></table></figure>

<p>main.exe.s  </p>
<ul>
<li>链接器搜索所有目标文件中搜索foo()和bar()，汇总到可执行文件。</li>
<li>callq的地址变成绝对地址，链接器进行了静态地址重定向。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000400632 &lt;foo()&gt;:</span><br><span class="line">  400632:	55                   	push   %rbp</span><br><span class="line">  400633:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  400636:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  40063b:	5d                   	pop    %rbp</span><br><span class="line">  40063c:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">000000000040063d &lt;bar()&gt;:</span><br><span class="line">  40063d:	55                   	push   %rbp</span><br><span class="line">  40063e:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  400641:	b8 02 00 00 00       	mov    $0x2,%eax</span><br><span class="line">  400646:	5d                   	pop    %rbp</span><br><span class="line">  400647:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000400648 &lt;main&gt;:</span><br><span class="line">  400648:	55                   	push   %rbp</span><br><span class="line">  400649:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">  40064c:	e8 e1 ff ff ff       	callq  400632 &lt;foo()&gt;</span><br><span class="line">  400651:	e8 e7 ff ff ff       	callq  40063d &lt;bar()&gt;</span><br><span class="line">  400656:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40065b:	5d                   	pop    %rbp</span><br><span class="line">  40065c:	c3                   	retq   </span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/19/note/cpp/make/</url>
    <content><![CDATA[<p>The <code>make</code> command in Linux is a utility used to automate the compilation and building process of projects. It reads a file named <code>Makefile</code> that contains a set of directives about how to compile and link a program. Here’s a brief overview of the syntax and key concepts of a <code>Makefile</code>:</p>
<h3 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h3><p>A <code>Makefile</code> typically consists of a set of rules. A rule is made up of three parts:</p>
<ol>
<li><strong>Target</strong>: The name of the file that the rule produces.</li>
<li><strong>Prerequisites</strong>: The files that are used as input to create the target.</li>
<li><strong>Recipe</strong>: The commands that will be executed to create the target from the prerequisites.</li>
</ol>
<p>The basic syntax of a rule is:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">target: prerequisites</span></span><br><span class="line">    recipe</span><br></pre></td></tr></table></figure>

<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>Here’s a simple example of a <code>Makefile</code> that compiles a C program:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Define the compiler</span></span><br><span class="line">CC=gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the compiler flags</span></span><br><span class="line">CFLAGS=-Wall</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the target executable</span></span><br><span class="line">TARGET=myprogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the rule for the target</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(TARGET)</span>.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(TARGET)</span>.c</span><br></pre></td></tr></table></figure>

<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>You can define variables in a <code>Makefile</code> to make it more readable and maintainable. In the example above, <code>CC</code>, <code>CFLAGS</code>, and <code>TARGET</code> are variables.</p>
<h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><p>Comments in a <code>Makefile</code> start with the <code>#</code> symbol. Anything following this symbol on a line is considered a comment.</p>
<h3 id="Phony-Targets"><a href="#Phony-Targets" class="headerlink" title="Phony Targets"></a>Phony Targets</h3><p>By default, Makefile targets are “file targets” - they are used to build files from other files. Make assumes its target is a file, and this makes writing Makefiles relatively easy:</p>
<p>In terms of Make, a phony target is simply a target that is always out-of-date, so whenever you ask make <phony_target>, it will run, independent from the state of the file system. Some common make targets that are often phony are: all, install, clean, distclean, TAGS, info, check.</p>
<p>A phony target is one that does not represent a file. It’s used to avoid conflicts with files of the same name and to improve performance. You can declare phony targets using the <code>.PHONY</code> directive.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h3 id="Advanced-Features"><a href="#Advanced-Features" class="headerlink" title="Advanced Features"></a>Advanced Features</h3><ul>
<li><strong>Pattern Rules</strong>: Allow you to define generic rules using <code>%</code> as a pattern matcher.</li>
<li><strong>Automatic Variables</strong>: Variables like <code>$@</code> (the name of the target), <code>$&lt;</code> (the name of the first prerequisite), and <code>$^</code> (the names of all the prerequisites) are set automatically and can be used in recipes.</li>
<li><strong>Conditional Execution</strong>: You can include conditionals in a <code>Makefile</code> to control the flow based on certain conditions.</li>
</ul>
<h3 id="Running-Make"><a href="#Running-Make" class="headerlink" title="Running Make"></a>Running Make</h3><p>To run <code>make</code>, simply type <code>make</code> in the terminal in the directory containing the <code>Makefile</code>. If you want to run a specific target, type <code>make &lt;target_name&gt;</code>.</p>
<p>This overview covers the basics of <code>make</code> syntax. <code>make</code> is a powerful tool with many more features and capabilities to explore.</p>
]]></content>
  </entry>
  <entry>
    <title>C++ placement new</title>
    <url>/2024/02/19/note/cpp/new-operator/</url>
    <content><![CDATA[<h1 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h1><p>在预先申请好的一片内存上构造对象。</p>
<p>比如 vector 的 reserve()，先预先申请足够的内存，后续用 placement new按需构造对象。</p>
<p>在内存池和垃圾回收器中经常用到。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *buf  = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(string)]; <span class="comment">// pre-allocated buffer</span></span><br><span class="line">string *p = <span class="built_in">new</span> (buf) <span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>);    <span class="comment">// placement new</span></span><br><span class="line">string *q = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>);          <span class="comment">// ordinary heap allocation</span></span><br></pre></td></tr></table></figure>

<h1 id="那有-placement-delete-吗？"><a href="#那有-placement-delete-吗？" class="headerlink" title="那有 placement delete 吗？"></a>那有 placement delete 吗？</h1><p>没有</p>
<h1 id="vector的placement-new"><a href="#vector的placement-new" class="headerlink" title="vector的placement new"></a>vector的placement new</h1><h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  __gnu_cxx::new_allocator&lt;S&gt;::<span class="built_in">allocate</span> (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __n=<span class="number">1</span>) at /usr/include/c++/<span class="number">9</span>/ext/new_allocator.h:<span class="number">114</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000055555555583a</span> in std::allocator_traits&lt;std::allocator&lt;S&gt; &gt;::<span class="built_in">allocate</span> (__a=..., __n=<span class="number">1</span>) at /usr/include/c++/<span class="number">9</span>/bits/alloc_traits.h:<span class="number">443</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000055555555569c</span> in std::_Vector_base&lt;S, std::allocator&lt;S&gt; &gt;::_M_allocate (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __n=<span class="number">1</span>) at /usr/include/c++/<span class="number">9</span>/bits/stl_vector.h:<span class="number">343</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x00005555555551e7</span> in std::vector&lt;S, std::allocator&lt;S&gt; &gt;::_M_realloc_insert&lt;S&gt; (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __position=non-dereferenceable iterator <span class="keyword">for</span> std::vector) at /usr/include/c++/<span class="number">9</span>/bits/vector.tcc:<span class="number">440</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000555555554ffa</span> in std::vector&lt;S, std::allocator&lt;S&gt; &gt;::<span class="built_in">emplace_back</span>&lt;S&gt; (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>) at /usr/include/c++/<span class="number">9</span>/bits/vector.tcc:<span class="number">121</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0x0000555555554e72</span> in std::vector&lt;S, std::allocator&lt;S&gt; &gt;::<span class="built_in">push_back</span> (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __x=...) at /usr/include/c++/<span class="number">9</span>/bits/stl_vector.h:<span class="number">1201</span></span><br><span class="line">#<span class="number">6</span>  <span class="number">0x0000555555554c0a</span> <span class="function">in <span class="title">main</span> <span class="params">()</span> at demo.cpp:<span class="number">29</span></span></span><br></pre></td></tr></table></figure>

<h2 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  __gnu_cxx::new_allocator&lt;S&gt;::<span class="built_in">construct</span>&lt;S, S&gt; (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __p=<span class="number">0x55555556aeb0</span>) at /usr/include/c++/<span class="number">9</span>/ext/new_allocator.h:<span class="number">146</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00005555555550b9</span> in std::allocator_traits&lt;std::allocator&lt;S&gt; &gt;::<span class="built_in">construct</span>&lt;S, S&gt; (__a=..., __p=<span class="number">0x55555556aeb0</span>) at /usr/include/c++/<span class="number">9</span>/bits/alloc_traits.h:<span class="number">483</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000555555555224</span> in std::vector&lt;S, std::allocator&lt;S&gt; &gt;::_M_realloc_insert&lt;S&gt; (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __position=non-dereferenceable iterator <span class="keyword">for</span> std::vector) at /usr/include/c++/<span class="number">9</span>/bits/vector.tcc:<span class="number">449</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x0000555555554ffa</span> in std::vector&lt;S, std::allocator&lt;S&gt; &gt;::<span class="built_in">emplace_back</span>&lt;S&gt; (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>) at /usr/include/c++/<span class="number">9</span>/bits/vector.tcc:<span class="number">121</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000555555554e72</span> in std::vector&lt;S, std::allocator&lt;S&gt; &gt;::<span class="built_in">push_back</span> (<span class="keyword">this</span>=<span class="number">0x7fffffffe2b0</span>, __x=...) at /usr/include/c++/<span class="number">9</span>/bits/stl_vector.h:<span class="number">1201</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0x0000555555554c0a</span> <span class="function">in <span class="title">main</span> <span class="params">()</span> at demo.cpp:<span class="number">29</span></span></span><br></pre></td></tr></table></figure>

<h1 id="stl为什么用allocator而不是直接new？"><a href="#stl为什么用allocator而不是直接new？" class="headerlink" title="stl为什么用allocator而不是直接new？"></a>stl为什么用allocator而不是直接new？</h1><p>因为stl需要将对象构造拆分为两步，1. 申请内存; 2. 构造对象。同样析构也拆分为，1. 析构对象; 2. 释放内存；如果没有这个拆分的需求，new足矣。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ pahole 查看对象成员内存布局</title>
    <url>/2024/02/19/note/cpp/pahole/</url>
    <content><![CDATA[<p>pahole: Poke-a-Hole</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install dwarves</span><br></pre></td></tr></table></figure>

<p>–show_private_classes 显示所有在namespace内部的类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:~/demo$ pahole ./a.out --show_private_classes | grep shared_ptr</span><br><span class="line">die__process_class: tag not supported 0x2f (template_type_parameter)!</span><br><span class="line">die__process_class: tag not supported 0x30 (template_value_parameter)!</span><br><span class="line">die__process_function: tag not supported 0x4107 (GNU_template_parameter_pack)!</span><br><span class="line">die__process_function: tag not supported 0x4108 (GNU_formal_parameter_pack)!</span><br><span class="line">class __shared_ptr_access&lt;int, (__gnu_cxx::_Lock_policy)2, false, false&gt; &#123;</span><br><span class="line">class __shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2&gt; : public __shared_ptr_access&lt;int, (__gnu_cxx::_Lock_policy)2, false, false&gt; &#123;</span><br><span class="line">        /* class __shared_ptr_access&lt;int, (__gnu_cxx::_Lock_policy)2, false, false&gt; &lt;ancestor&gt;; */ /*     0     0 */</span><br><span class="line">class shared_ptr&lt;int&gt; : public __shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line">        /* class __shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2&gt; &lt;ancestor&gt;; */ /*     0    16 */</span><br></pre></td></tr></table></figure>

<p>It doesn’t uses any source code files, just the DWARF2<br>information in ELF sections, inserted by ‘gcc -g’, to print out the<br>above information:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[acme@newtoy net-2.6]$ pahole kernel/sched.o task_struct</span><br><span class="line">/* include2/asm/system.h:11 */</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">        volatile long int       state;          /*     0     4 */</span><br><span class="line">        struct thread_info *    thread_info;    /*     4     4 */</span><br><span class="line">        atomic_t                usage;          /*     8     4 */</span><br><span class="line">        long unsigned int       flags;          /*    12     4 */</span><br><span class="line"></span><br><span class="line">	&lt;SNIP&gt;</span><br><span class="line"></span><br><span class="line">        short unsigned int         ioprio;      /*    52     2 */</span><br><span class="line"></span><br><span class="line">        /* XXX 2 bytes hole, try to pack */</span><br><span class="line"></span><br><span class="line">        long unsigned int          sleep_avg;   /*    56     4 */ */</span><br><span class="line">        unsigned char              fpu_counter; /*   388     1 */</span><br><span class="line"></span><br><span class="line">        /* XXX 3 bytes hole, try to pack */</span><br><span class="line"></span><br><span class="line">        int                        oomkilladj;  /*   392     4 */</span><br><span class="line"></span><br><span class="line">	&lt;SNIP&gt;</span><br><span class="line"></span><br><span class="line">&#125;; /* size: 1312, sum members: 1287, holes: 3, sum holes: 13, padding: 12 */</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::move vs std::forward</title>
    <url>/2024/02/19/note/cpp/std%20move%20std%20forward%20/</url>
    <content><![CDATA[<h1 id="std-move-std-forward"><a href="#std-move-std-forward" class="headerlink" title="std::move std::forward"></a>std::move std::forward</h1><p>二者唯一区别: std::move无条件将入参转换为右值，std::forward特定条件才转换为右值</p>
<p>std::move适用于将对象无条件转换为右值，从而为移动服务；</p>
<p>std::forward适用于保留对象的左值&#x2F;右值这一特性，从而原封不动的转发，保留原汁原味；</p>
<p>二者均是编译期生效，运行期什么都不做。</p>
<p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html</a> 标准实现讨论</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type &amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp &amp;&amp;<span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type &amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::move(var) 无条件将var类型转换为右值，std::move一定返回右值，但不保证可以被移动，比如, </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> std::string s;</span><br></pre></td></tr></table></figure>

<p>std::move后保留const，因此，待移动的变量不能是const，否则就不能匹配上<strong>移动</strong>构造&#x2F;赋值函数，而退化为<strong>拷贝</strong>构造&#x2F;赋值函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; cout &lt;&lt; <span class="string">&quot;Str default constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">const</span> Str&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str copy construtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(Str&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str move constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    Str s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(Str str) : <span class="built_in">s</span>(str) &#123;&#125; <span class="comment">// 效率最低的一种</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str s;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">default</span> constructor</span><br><span class="line">Str copy construtor <span class="comment">// 参数拷贝传递触发</span></span><br><span class="line">Str copy construtor <span class="comment">// C的初始化列表触发, 这里可以用std::move优化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; cout &lt;&lt; <span class="string">&quot;Str default constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">const</span> Str&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str copy construtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(Str&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str move constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    Str s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(Str str) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(str)) &#123;&#125; <span class="comment">// 优化一次copy为move</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str s;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">default</span> constructor</span><br><span class="line">Str copy construtor</span><br><span class="line">Str move constructor</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; cout &lt;&lt; <span class="string">&quot;Str default constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">const</span> Str&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str copy construtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(Str&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str move constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    Str s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 效率最低的一种，因为const的存在，转换为右值不能移动，退化为拷贝</span></span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> Str str) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(str)) &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str s;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">default</span> constructor</span><br><span class="line">Str copy construtor</span><br><span class="line">Str copy construtor</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; cout &lt;&lt; <span class="string">&quot;Str default constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">const</span> Str&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str copy construtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(Str&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str move constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    Str s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> Str&amp; str) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(str)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str s;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">default</span> constructor</span><br><span class="line"><span class="comment">// 参数以const&amp;传递，省去一次拷贝构造</span></span><br><span class="line">Str copy construtor <span class="comment">// C的构造函数入参str加了const，std::move不去掉const，所以不能移动，只能拷贝</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; cout &lt;&lt; <span class="string">&quot;Str default constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">const</span> Str&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str copy construtor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(Str&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;Str move constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    Str s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(Str&amp; str) : <span class="built_in">s</span>(std::<span class="built_in">move</span>(str)) &#123;&#125; <span class="comment">// 最高效的一种</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str s;</span><br><span class="line">    <span class="function">C <span class="title">c</span><span class="params">(s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Str <span class="keyword">default</span> constructor</span><br><span class="line">Str move constructor <span class="comment">// 这里才是一次真正的move</span></span><br></pre></td></tr></table></figure>

<h1 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h1><p>std::forward is a conditional cast: it casts to an rvalue only if its argument was initialized with an<br>rvalue.</p>
<h2 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">overloaded_function</span><span class="params">(std::string&amp; param)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;std::string&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">overloaded_function</span><span class="params">(std::string&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;std::string&amp;&amp; version&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass_through</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">overloaded_function</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::string pes;</span><br><span class="line">  <span class="built_in">pass_through</span>(pes);</span><br><span class="line">  <span class="built_in">pass_through</span>(std::<span class="built_in">move</span>(pes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么用std-forward"><a href="#为什么用std-forward" class="headerlink" title="为什么用std::forward?"></a>为什么用std::forward?</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(t);</span><br><span class="line">    <span class="built_in">foo</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo&lt;int&gt;(int&amp;&amp;):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        sub     rsp, 16</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    void foo&lt;int&amp;&gt;(int&amp;) // 这里以左值传递给下一层，错了</span><br><span class="line">        mov     rax, QWORD PTR [rbp-8]</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    int&amp;&amp; std::forward&lt;int&gt;(std::remove_reference&lt;int&gt;::type&amp;)</span><br><span class="line">        mov     rdi, rax</span><br><span class="line">        call    void foo&lt;int&gt;(int&amp;&amp;) // 这里以右值继续传递，正确</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内存对齐</title>
    <url>/2024/02/19/note/cpp/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>来源：<a href="https://stackoverflow.com/a/17820362/11850070">https://stackoverflow.com/a/17820362/11850070</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">double</span> d1;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">  <span class="type">double</span> d2;</span><br><span class="line">  <span class="type">char</span> c3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> d1;</span><br><span class="line">  <span class="type">double</span> d2;</span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">  <span class="type">char</span> c3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(S1)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(S2)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S2) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(S1)=<span class="number">40</span></span><br><span class="line"><span class="built_in">sizeof</span>(S2)=<span class="number">24</span></span><br></pre></td></tr></table></figure>

<p>每个字符代表1B，对齐规则为:</p>
<p>1.基本类型的对齐值就是其sizeof值;</p>
<p>2.结构体的对齐值是其成员的最大对齐值;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sizeof(S1) = 40B</span></span><br><span class="line">c*******ddddddddc*******ddddddddc*******</span><br><span class="line"></span><br><span class="line"><span class="comment">// sizeof(S2) = 24B</span></span><br><span class="line">ddddddddddddddddccc*****</span><br></pre></td></tr></table></figure>

<p>因此总的原则是，按从类型从大到小的顺序依次声明成员变量。</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++内联汇编</title>
    <url>/2024/02/19/note/cpp/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Extended Asm (Using the GNU Compiler Collection (GCC))</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inline assembly to add &#x27;a&#x27; and &#x27;b&#x27; and store the result in &#x27;result&#x27;</span></span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;add %1, %2\\n&quot;</span>     <span class="comment">// b = a + b</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;mov %2, %0\\n&quot;</span>     <span class="comment">// result = b</span></span><br><span class="line"></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span>(result)       <span class="comment">// Output operand</span></span><br><span class="line"></span><br><span class="line">        : <span class="string">&quot;r&quot;</span>(a), <span class="string">&quot;r&quot;</span>(b)     <span class="comment">// Input operands</span></span><br><span class="line"></span><br><span class="line">        : <span class="string">&quot;cc&quot;</span>               <span class="comment">// The clobber &quot;cc&quot; informs the compiler that the assembly code may modify the condition codes (flags).</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Great example to help to understand RAX:RDX pair used in instructions like <code>MUL</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> a = <span class="number">0xFFFFFFFFFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> b = <span class="number">0x0000000000000002</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> result_low, result_high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multiply &#x27;a&#x27; and &#x27;b&#x27; using inline assembly and store the 128-bit result</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// in the RDX:RAX register pair</span></span><br><span class="line"></span><br><span class="line">    __asm__(</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;mulq %3&quot;</span>            <span class="comment">// Multiply RAX (implicitly) with &#x27;b&#x27;, result stored in RDX:RAX</span></span><br><span class="line"></span><br><span class="line">        : <span class="string">&quot;=a&quot;</span>(result_low),  <span class="comment">// Output operand for the lower 64 bits (RAX)</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;=d&quot;</span>(result_high)  <span class="comment">// Output operand for the upper 64 bits (RDX)</span></span><br><span class="line"></span><br><span class="line">        : <span class="string">&quot;0&quot;</span>(a),            <span class="comment">// Input operand for &#x27;a&#x27; (placed in RAX)</span></span><br><span class="line"></span><br><span class="line">          <span class="string">&quot;rm&quot;</span>(b)            <span class="comment">// Input operand for &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">        : <span class="string">&quot;cc&quot;</span>               <span class="comment">// Clobbers</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result (high): 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; result_high &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result (low):  0x&quot;</span> &lt;&lt; std::hex &lt;&lt; result_low &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cmpxchg8b m64<br>当 DA &#x3D;&#x3D; m64 时，把 BC 存入 m64</p>
<ul>
<li>m64 - 待比较和更新值的内存地址</li>
<li>EDX:EAX - 如果EDX:EAX !&#x3D; m64, 则把m64存到EDX:EAX</li>
<li>ECX:EBX - 如果EDX:EAX &#x3D;&#x3D; m64，则把该新值存入 m64</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 运算符优先级</title>
    <url>/2024/02/19/note/cpp/%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<p>注意 i– 与等号运算符共用时的优先级问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    nums[j + <span class="number">1</span>] = nums[j--];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; num : nums)</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j--];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 取 nums[j]，即 nums[0] = 1</span></span><br><span class="line"><span class="comment">// 2. j--，此时 j 为 -1</span></span><br><span class="line"><span class="comment">// 3. 将 1 赋值给 nums[j+1] = nums[-1+1] = nums[0]，所以是自己赋值给自己，数组没有任何变化</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 绝不能在构造和析构函数中调虚函数</title>
    <url>/2024/02/19/note/cpp/%E7%BB%9D%E4%B8%8D%E8%83%BD%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E8%99%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>绝不在构造和析构过程中调用 virtual 函数，因为这类调用只会调用当前类的虚函数版本，从不下降至更下级子类（derived class）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() </span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shape()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">foo</span>(); <span class="comment">// 在构造函数中调虚函数，只会调该类的，不会向下走</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Shape()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Shape::foo()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Circle::foo()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Circle c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Shape</span>()</span><br><span class="line">Shape::<span class="built_in">foo</span>() <span class="comment">// 构造是Circle，但调的是基类的虚函数</span></span><br><span class="line"><span class="built_in">Circle</span>()</span><br><span class="line">~<span class="built_in">Circle</span>()</span><br><span class="line">~<span class="built_in">Shape</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 继承类构造与析构顺序</title>
    <url>/2024/02/19/note/cpp/%E7%BB%A7%E6%89%BF%E7%B1%BB%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F%20/</url>
    <content><![CDATA[<ul>
<li>先base类构造函数，如果继承多个，则从左到右依次构造base，如果其中有virtual继承，则高优先级；</li>
<li>接着是成员变量，按声明的顺序依次构建</li>
<li>最后是这个类当前构造函数花括号内的逻辑</li>
<li>析构与构造顺序完全相反</li>
</ul>
<h2 id="连续继承"><a href="#连续继承" class="headerlink" title="连续继承"></a>连续继承</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircle</span> : <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">MyCircle</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Shape</span>()</span><br><span class="line"><span class="built_in">Circle</span>()</span><br><span class="line"><span class="built_in">MyCircle</span>()</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MyCircle</span>()</span><br><span class="line">~<span class="built_in">Circle</span>()</span><br><span class="line">~<span class="built_in">Shape</span>()</span><br></pre></td></tr></table></figure>

<h2 id="既继承又包含"><a href="#既继承又包含" class="headerlink" title="既继承又包含"></a>既继承又包含</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A() C-tor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A() D-tor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line">    A a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B() C-tor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B() D-tor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">A</span>() C-<span class="function">tor</span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">()</span> C-tor</span></span><br><span class="line"><span class="function"><span class="title">B</span><span class="params">()</span> C-tor</span></span><br><span class="line"><span class="function">~<span class="title">B</span><span class="params">()</span> D-tor</span></span><br><span class="line"><span class="function">~<span class="title">A</span><span class="params">()</span> D-tor</span></span><br><span class="line"><span class="function">~<span class="title">A</span><span class="params">()</span> D-tor</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 编译器自动生成的构造，拷贝，移动函数</title>
    <url>/2024/02/19/note/cpp/%E7%BC%96%E8%AF%91%E5%99%A8%E7%94%9F%E6%88%90%E7%9A%84%E6%9E%84%E9%80%A0%EF%BC%8C%E6%8B%B7%E8%B4%9D%EF%BC%8C%E7%A7%BB%E5%8A%A8%E5%87%BD%E6%95%B0%20/</url>
    <content><![CDATA[<blockquote>
<p>什么时候自动生成？</p>
</blockquote>
<ul>
<li>没声明且用到了，则编译器自动生成一个默认的。</li>
</ul>
<blockquote>
<p>怎么禁止编译器生成？</p>
</blockquote>
<ul>
<li>≥ C++11 用delete</li>
<li>只声明不实现，放在private中，如果调用了，报链接错误，undefined reference to xxx</li>
</ul>
<h2 id="空类，只用到默认构造"><a href="#空类，只用到默认构造" class="headerlink" title="空类，只用到默认构造"></a>空类，只用到默认构造</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Empty e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 cppinsights 能看到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="comment">// inline constexpr Empty() noexcept = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Empty e1;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空类，用到构造、拷贝构造、拷贝赋值"><a href="#空类，用到构造、拷贝构造、拷贝赋值" class="headerlink" title="空类，用到构造、拷贝构造、拷贝赋值"></a>空类，用到构造、拷贝构造、拷贝赋值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Empty e1;</span><br><span class="line">  <span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;</span><br><span class="line">  e2 = e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="comment">// inline constexpr Empty() noexcept = default;</span></span><br><span class="line">  <span class="comment">// inline constexpr Empty(const Empty &amp;) noexcept = default;</span></span><br><span class="line">  <span class="comment">// inline constexpr Empty &amp; operator=(const Empty &amp;) noexcept = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Empty e1 = <span class="built_in">Empty</span>();</span><br><span class="line">  Empty e2 = <span class="built_in">Empty</span>(e1);</span><br><span class="line">  e2.<span class="keyword">operator</span>=(e1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空类，只用到默认构造、拷贝赋值"><a href="#空类，只用到默认构造、拷贝赋值" class="headerlink" title="空类，只用到默认构造、拷贝赋值"></a>空类，只用到默认构造、拷贝赋值</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Empty e1;</span><br><span class="line">  Empty e2 = e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="comment">// inline constexpr Empty() noexcept = default;</span></span><br><span class="line">  <span class="comment">// inline constexpr Empty(const Empty &amp;) noexcept = default;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Empty e1;</span><br><span class="line">  Empty e2 = <span class="built_in">Empty</span>(e1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 虚函数实现原理</title>
    <url>/2024/02/19/note/cpp/%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>关于这块，检索到的资料大都模棱两可，可信度很存疑，对这块的理解停留在道听途说的层面，不够深刻。</p>
<p>想了想，可以从汇编角度，看看编译器究竟为实现虚函数在背后默默做了什么。</p>
<p>本文分析 <code>gcc version 9.4.0</code> 的虚函数的实现方式。</p>
<p>基本原理：一个类只要声明了一个虚函数，则编译器为该类生成一个虚函数表（vtable），虚函数表中主要是该类的虚函数的定义地址，由该类所有的对象共享。每个对象内部存一个虚函数表指针（vptr）指向该vtable。</p>
<p>因此需要明确：虚函数表是属于类的，虚函数指针是属于单个对象。</p>
<p>注意：c++标准没有规定必须用虚函数表这种形式实现，只是大多数编译器采用这种实现方式。</p>
<h1 id="虚函数表内容"><a href="#虚函数表内容" class="headerlink" title="虚函数表内容"></a>虚函数表内容</h1><p>首先，看下虚函数表中究竟有什么。</p>
<h2 id="查看编译器生成汇编代码"><a href="#查看编译器生成汇编代码" class="headerlink" title="查看编译器生成汇编代码"></a>查看编译器生成汇编代码</h2><p>测试代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    p-&gt;<span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 -S 指示g++编译成功后立刻打住，保留汇编代码，不进行下一步汇编代码转二进制机器码的步骤。</p>
<p>注意：g++ -S 输出的汇编代码中所有符号均已 name-mangled，因此需要用 c++filt 还原符号。</p>
<p>将可读的汇编代码存到 demo.s 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -S -g demo.cpp -o demo.mangled.s</span><br><span class="line"><span class="built_in">cat</span> demo.mangled.s | c++filt &gt; demo.s</span><br></pre></td></tr></table></figure>

<p>从汇编代码中摘出Base和Derived类的虚函数表。</p>
<ul>
<li><code>.quad expr</code> 告知汇编器开辟8字节内存空间，填充 expr</li>
<li><code>.section</code> 指明该符号放在哪个section</li>
</ul>
<p>Derived的虚表大小共4*8 &#x3D; 32字节，后两个8字节是 <code>Derived::foo()</code> 与 <code>Base::bar()</code> 这两个符号的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vtable <span class="keyword">for</span> Derived:</span><br><span class="line">	.quad	<span class="number">0</span></span><br><span class="line">	.quad	typeinfo <span class="keyword">for</span> Derived</span><br><span class="line">	.<span class="function">quad	<span class="title">Derived::foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	.quad	<span class="title">Base::bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	.weak	vtable <span class="keyword">for</span> Base</span></span><br><span class="line"><span class="function">	.section	.data.rel.ro.local._ZTV4Base,&quot;awG&quot;,@progbits,vtable <span class="keyword">for</span> Base,comdat</span></span><br><span class="line"><span class="function">	.align 8</span></span><br><span class="line"><span class="function">	.type	vtable <span class="keyword">for</span> Base, @object</span></span><br><span class="line"><span class="function">	.size	vtable <span class="keyword">for</span> Base, 32</span></span><br><span class="line"><span class="function">vtable <span class="keyword">for</span> Base:</span></span><br><span class="line"><span class="function">	.quad	<span class="number">0</span></span></span><br><span class="line"><span class="function">	.quad	typeinfo for Base</span></span><br><span class="line"><span class="function">	.quad	Base::foo()</span></span><br><span class="line"><span class="function">	.quad	Base::bar()</span></span><br><span class="line"><span class="function">	.weak	typeinfo for Derived</span></span><br><span class="line"><span class="function">	.section	.data.rel.ro._ZTI7Derived,<span class="string">&quot;awG&quot;</span>,@progbits,typeinfo for Derived,comdat</span></span><br><span class="line"><span class="function">	.align <span class="number">8</span></span></span><br><span class="line"><span class="function">	.type	typeinfo for Derived, @object</span></span><br><span class="line"><span class="function">	.size	typeinfo for Derived, <span class="number">24</span></span></span><br></pre></td></tr></table></figure>


<h2 id="运行期"><a href="#运行期" class="headerlink" title="运行期"></a>运行期</h2><h3 id="GDB打印对象的vtable"><a href="#GDB打印对象的vtable" class="headerlink" title="GDB打印对象的vtable"></a>GDB打印对象的vtable</h3><p>最简单直观的一种方式，在GDB中，可直接打印运行时，对象的虚函数表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    p-&gt;<span class="built_in">bar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(gdb) info vtbl p</span><br><span class="line">vtable <span class="keyword">for</span> <span class="string">&#x27;Base&#x27;</span> @ <span class="number">0x555555556d18</span> (subobject @ <span class="number">0x555555569eb0</span>):</span><br><span class="line">[<span class="number">0</span>]: <span class="number">0x555555554a72</span> &lt;Derived::<span class="built_in">foo</span>()&gt;</span><br><span class="line">[<span class="number">1</span>]: <span class="number">0x555555554a62</span> &lt;Base::<span class="built_in">bar</span>()&gt;</span><br></pre></td></tr></table></figure>



<p>直接看下最终生成的可执行文件，正好对应于gcc -S给出的vtable中前四个.quad汇编指示，所以直接看gcc -S生成的vtable更直观</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -C -j .rodata -z -S demo</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]# objdump -C -j .rodata -z -S demo</span><br><span class="line"></span><br><span class="line">demo:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">0000000000400b50 &lt;vtable for C&gt;:</span><br><span class="line">  400b50:       00 00 00 00 00 00 00 00 b0 0b 40 00 00 00 00 00     ..........@.....</span><br><span class="line">  400b60:       02 0a 40 00 00 00 00 00 aa 09 40 00 00 00 00 00     ..@.......@.....</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]# objdump -C -t demo | grep 400bb0</span><br><span class="line">0000000000400bb0  w    O .rodata        0000000000000018              typeinfo for C</span><br><span class="line">[root@ZLPC-wangqingjia demo]# objdump -C -t demo | grep 400a02</span><br><span class="line">0000000000400a02  w    F .text  000000000000002b              C::foo()</span><br><span class="line">[root@ZLPC-wangqingjia demo]# objdump -C -t demo | grep 4009aa</span><br><span class="line">00000000004009aa  w    F .text  000000000000002b              A::bar()</span><br></pre></td></tr></table></figure>

<h1 id="gcc导出类的虚表构成"><a href="#gcc导出类的虚表构成" class="headerlink" title="gcc导出类的虚表构成"></a>gcc导出类的虚表构成</h1><p>For GCC compiler in Linux run:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ -fdump-lang-<span class="keyword">class</span> <span class="title class_">demo</span>.cpp</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NOTE: Before GCC 8, the option is -fdump-class-hierarchy instead of -fdump-lang-class.</p>
</blockquote>
<p>输出与gcc反汇编一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vtable for C</span><br><span class="line">C::vtable for C: 4 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; typeinfo for C)</span><br><span class="line">16    (int (*)(...))C::foo</span><br><span class="line">24    (int (*)(...))A::bar</span><br></pre></td></tr></table></figure>

<h1 id="虚函数表在哪？"><a href="#虚函数表在哪？" class="headerlink" title="虚函数表在哪？"></a>虚函数表在哪？</h1><p>在 .rodata</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -t 打印该section内symbol table</span></span><br><span class="line">[root@ZLPC-WangQingJia demo]<span class="comment"># objdump -C -t a.out | grep vtable</span></span><br><span class="line">0000000000400bb0  w    O .rodata        0000000000000020              vtable <span class="keyword">for</span> A</span><br><span class="line">0000000000601d40  w    O .data.rel.ro   0000000000000058              vtable <span class="keyword">for</span> __cxxabiv1::__class_type_info@@CXXABI_1.3</span><br><span class="line">0000000000400b70  w    O .rodata        0000000000000020              vtable <span class="keyword">for</span> C</span><br><span class="line">0000000000601da0  w    O .data.rel.ro   0000000000000058              vtable <span class="keyword">for</span> __cxxabiv1::__si_class_type_info@@CXXABI_1.3</span><br><span class="line">0000000000400b90  w    O .rodata        0000000000000020              vtable <span class="keyword">for</span> B</span><br></pre></td></tr></table></figure>


<h1 id="虚函数表指针在哪"><a href="#虚函数表指针在哪" class="headerlink" title="虚函数表指针在哪?"></a>虚函数表指针在哪?</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::bar&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;C::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* b = <span class="keyword">new</span> C;</span><br><span class="line">    b-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个指向多态对象的指针，指向成员变量连续内存的起始地址，但由于vptr在成员变量列表最开始位置，因此实际是指向vptr。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p/x $rbp</span><br><span class="line">$24 = 0x7ffffffed780</span><br><span class="line"></span><br><span class="line">(gdb) p b</span><br><span class="line">$22 = (B *) 0x603030</span><br><span class="line">(gdb) p &amp;b</span><br><span class="line">$23 = (B **) 0x7ffffffed760  # 说明基类指针b本身存在栈中</span><br><span class="line">(gdb) x/xg 0x603030</span><br><span class="line">0x603030:       0x0000000000400b90  # 0x603030 应是虚函数表指针的地址，即 p 指向虚函数指针</span><br><span class="line">(gdb) x/xg 0x0000000000400b90</span><br><span class="line">0x400b90 &lt;_ZTV1C+16&gt;:   0x0000000000400a2e # 0x400b90 是虚表函数指针数组首个元素地址</span><br><span class="line">(gdb) dem _ZTV1C</span><br><span class="line">vtable for C</span><br><span class="line">(gdb) x/xg 0x0000000000400a2e</span><br><span class="line">0x400a2e &lt;C::foo()&gt;:    0x10ec8348e5894855 # 注意： 0x10ec8348e5894855 其实是一串汇编指令</span><br></pre></td></tr></table></figure>




<p><img src="/../assets/image-12.png" alt="Alt text"></p>
<h1 id="虚函数指针究竟在对象中哪里存的"><a href="#虚函数指针究竟在对象中哪里存的" class="headerlink" title="虚函数指针究竟在对象中哪里存的?"></a>虚函数指针究竟在对象中哪里存的?</h1><p>反汇编指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">g++ -g -O0 demo.cpp -o demo</span><br><span class="line"></span><br><span class="line">g++ -S -g -O0 demo.cpp -o demo.s.tmp</span><br><span class="line"><span class="built_in">cat</span> demo.s.tmp | c++filt &gt; demo.gcc.s</span><br><span class="line"><span class="built_in">rm</span> demo.s.tmp</span><br><span class="line"></span><br><span class="line">objdump -C -d -S demo &gt; demo.s</span><br><span class="line">objdump -C -t demo &gt; demo.sym</span><br><span class="line">objdump -C -j .rodata -z -S demo &gt; demo.rodata.s</span><br><span class="line"></span><br><span class="line">g++ -fdump-lang-class demo.cpp</span><br><span class="line"><span class="built_in">cat</span> demo.cpp.001l.class | c++filt &gt; demo.class</span><br><span class="line"><span class="built_in">rm</span> demo.cpp.001l.class</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::bar&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">short</span> c = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;C::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在堆上构造含虚函数的对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A* a = new C();</span><br><span class="line">     bc6:    bf 18 00 00 00           mov    $0x18,%edi       // 类大小为0x18=24字节</span><br><span class="line">     bcb:    e8 b0 fe ff ff           callq  a80 &lt;_init+0xa0&gt; // new 出内存</span><br><span class="line">     bd0:    48 89 c3                 mov    %rax,%rbx        // 申请的地址在 %rax 中</span><br><span class="line">     bd3:    48 c7 03 00 00 00 00     movq   $0x0,(%rbx)      // 类C虚函数表vptr</span><br><span class="line">     bda:    c7 43 08 00 00 00 00     movl   $0x0,0x8(%rbx)   // int a</span><br><span class="line">     be1:    c7 43 0c 00 00 00 00     movl   $0x0,0xc(%rbx)   // int b</span><br><span class="line">     be8:    66 c7 43 10 00 00        movw   $0x0,0x10(%rbx)  // short c </span><br><span class="line">     bee:    48 89 df                 mov    %rbx,%rdi        // 将对象的起始地址(在%rbx中暂存)传入C::C()构造函数</span><br><span class="line">     bf1:    e8 c6 01 00 00           callq  dbc &lt;C::C()&gt;</span><br></pre></td></tr></table></figure>

<p>new出内存之后，调用 C::C() 构造对象之前：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24xb $rbx</span><br><span class="line">0x555555569eb0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x555555569eb8: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x555555569ec0: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br></pre></td></tr></table></figure>

<p>调用 C::C() 之后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) x/24xb $rbx</span><br><span class="line">0x555555569eb0: 0xc8    0x6c    0x55    0x55    0x55    0x55    0x00    0x00</span><br><span class="line">0x555555569eb8: 0x0a    0x00    0x00    0x00    0x0a    0x00    0x00    0x00</span><br><span class="line">0x555555569ec0: 0x14    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line"></span><br><span class="line">// 最开头的8字节是vptr for C</span><br><span class="line">(gdb) x/gx 0x555555556cc8</span><br><span class="line">0x555555556cc8 &lt;_ZTV1C+16&gt;:     0x0000555555554d34</span><br><span class="line">(gdb) dem _ZTV1C</span><br><span class="line">vtable for C</span><br><span class="line">(gdb) x/gx 0x0000555555554d34</span><br><span class="line">0x555555554d34 &lt;C::foo()&gt;:      0xe5894855fa1e0ff3</span><br><span class="line"></span><br><span class="line">// 接下来8字节分别是 int a = 10 = 0x0a 和 int b = 10 = 0x0a</span><br><span class="line"></span><br><span class="line">// 最后8字节的低2字节: 0x14 = 20 即 int c = 20;</span><br></pre></td></tr></table></figure>

<h1 id="多继承虚函数指针怎么分布？"><a href="#多继承虚函数指针怎么分布？" class="headerlink" title="多继承虚函数指针怎么分布？"></a>多继承虚函数指针怎么分布？</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">aFunc1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">aFunc2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">aFunc3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bFunc1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bFunc2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dFunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dFunc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eFunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eFunc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B, <span class="keyword">public</span> D, <span class="keyword">public</span> E</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">aFunc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">cFunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dFunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc导出vtable</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ -fdump-lang-<span class="keyword">class</span> <span class="title class_">demo</span>.cpp</span><br><span class="line">cat demo.cpp<span class="number">.001l</span>.<span class="keyword">class</span> | c++filt &gt; demo.<span class="keyword">class</span>  # 导出为demo.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">rm</span> demo.cpp<span class="number">.001l</span>.<span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<p>C类继承4个父类，类C本身的虚函数跟在第一个父类指针数组后面，其余父类的虚函数依次排列，每个C类的对象含4个vptr，分别指向C类虚函表数组的四个地址。注意是全指向C类的虚表数组，数组中存的是虚函数地址，不涉及父类虚表。编译期就确定了某个类的虚表分布与构成。</p>
<ol>
<li>vtable+16</li>
<li>vtable+64</li>
<li>vtable+96</li>
<li>vtable+128</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> C</span><br><span class="line">C::vtable <span class="keyword">for</span> C: <span class="number">18</span> entries</span><br><span class="line"><span class="number">0</span>     (<span class="built_in">int</span> (*)(...))<span class="number">0</span></span><br><span class="line"><span class="number">8</span>     (<span class="built_in">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> C)</span><br><span class="line"><span class="number">16</span>    (<span class="built_in">int</span> (*)(...))A::aFunc1</span><br><span class="line"><span class="number">24</span>    (<span class="built_in">int</span> (*)(...))C::aFunc2</span><br><span class="line"><span class="number">32</span>    (<span class="built_in">int</span> (*)(...))C::cFunc1</span><br><span class="line"><span class="number">40</span>    (<span class="built_in">int</span> (*)(...))C::dFunc1</span><br><span class="line"><span class="number">48</span>    (<span class="built_in">int</span> (*)(...))<span class="number">-8</span></span><br><span class="line"><span class="number">56</span>    (<span class="built_in">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> C)</span><br><span class="line"><span class="number">64</span>    (<span class="built_in">int</span> (*)(...))B::bFunc1</span><br><span class="line"><span class="number">72</span>    (<span class="built_in">int</span> (*)(...))B::bFunc2</span><br><span class="line"><span class="number">80</span>    (<span class="built_in">int</span> (*)(...))<span class="number">-16</span></span><br><span class="line"><span class="number">88</span>    (<span class="built_in">int</span> (*)(...))(&amp; typeinfo <span class="keyword">for</span> C)</span><br><span class="line"><span class="number">96</span>    (<span class="built_in">int</span> (*)(...))C::non-<span class="function"><span class="keyword">virtual</span> thunk to <span class="title">C::dFunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">104   <span class="params">(<span class="type">int</span> (*)(...))</span>D::dFunc2</span></span><br><span class="line"><span class="function">112   <span class="params">(<span class="type">int</span> (*)(...))</span>-24</span></span><br><span class="line"><span class="function">120   <span class="params">(<span class="type">int</span> (*)(...))</span><span class="params">(&amp; typeinfo <span class="keyword">for</span> C)</span></span></span><br><span class="line"><span class="function">128   <span class="params">(<span class="type">int</span> (*)(...))</span>E::eFunc1</span></span><br><span class="line"><span class="function">136   <span class="params">(<span class="type">int</span> (*)(...))</span>E::eFunc2</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Class C</span></span><br><span class="line"><span class="function">   size</span>=<span class="number">32</span> align=<span class="number">8</span></span><br><span class="line">   base size=<span class="number">32</span> base align=<span class="number">8</span></span><br><span class="line"><span class="built_in">C</span> (<span class="number">0x0</span>x7fa0d22ea900) <span class="number">0</span></span><br><span class="line">    vptr=((&amp; C::vtable <span class="keyword">for</span> C) + <span class="number">16</span>)</span><br><span class="line">  <span class="built_in">A</span> (<span class="number">0x0</span>x7fa0d2424e40) <span class="number">0</span> nearly-empty</span><br><span class="line">      primary-<span class="keyword">for</span> <span class="built_in">C</span> (<span class="number">0x0</span>x7fa0d22ea900)</span><br><span class="line">  <span class="built_in">B</span> (<span class="number">0x0</span>x7fa0d2424ea0) <span class="number">8</span> nearly-empty</span><br><span class="line">      vptr=((&amp; C::vtable <span class="keyword">for</span> C) + <span class="number">64</span>)</span><br><span class="line">  <span class="built_in">D</span> (<span class="number">0x0</span>x7fa0d2424f00) <span class="number">16</span> nearly-empty</span><br><span class="line">      vptr=((&amp; C::vtable <span class="keyword">for</span> C) + <span class="number">96</span>)</span><br><span class="line">  <span class="built_in">E</span> (<span class="number">0x0</span>x7fa0d2424f60) <span class="number">24</span> nearly-empty</span><br><span class="line">      vptr=((&amp; C::vtable <span class="keyword">for</span> C) + <span class="number">128</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 虚析构函数</title>
    <url>/2024/02/19/note/cpp/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%20/</url>
    <content><![CDATA[<h1 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h1><blockquote>
<p>何时声明类的析构函数为virtual？</p>
</blockquote>
<ul>
<li>当要通过基类指针删除子类对象时，如果基类的析构函数没用virtual，则是未定义行为，大多数实现是把基类的析构函数当作普通非虚函数，因此只析构基类，导致子类资源泄露。</li>
<li>因此Effective C++讲：只要基类有一个虚函数，就该考虑将其析构函数声明为virtual。从而确保从子类→基类的析构函数依次调用（构造顺序是先基类后子类，析构顺序正好相反，先子类后父类），否则只有基类析构，子类没析构，子类发生资源泄漏。</li>
<li>也可以声明基类析构函数为protected，从而编译器禁止通过基类指针删除子类对象。</li>
</ul>
<blockquote>
<p>那是否每个基类的析构函数都声明为virtual？</p>
</blockquote>
<ul>
<li>不用，只要最上边的基类是virtual即可，其余子类的析构函数均继承了virtual修饰。</li>
</ul>
<h2 id="多态基类析构函数没加virtual"><a href="#多态基类析构函数没加virtual" class="headerlink" title="多态基类析构函数没加virtual"></a>多态基类析构函数没加virtual</h2><p>这种情况是未定义的，大多数实现是只析构基类了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Shape()&quot;</span> &lt;&lt; endl; &#125;; <span class="comment">// 这里去掉了virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircle</span> : <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">MyCircle</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Shape</span>()</span><br><span class="line"><span class="built_in">Circle</span>()</span><br><span class="line"><span class="built_in">MyCircle</span>()</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Shape</span>() <span class="comment">// 要删除子类，结果只调了基类的析构函数</span></span><br></pre></td></tr></table></figure>

<h2 id="多态基类析构函数加上virtual后"><a href="#多态基类析构函数加上virtual后" class="headerlink" title="多态基类析构函数加上virtual后"></a>多态基类析构函数加上virtual后</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Shape()&quot;</span> &lt;&lt; endl; &#125;; <span class="comment">// 这里加上virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircle</span> : <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">MyCircle</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Shape</span>()</span><br><span class="line"><span class="built_in">Circle</span>()</span><br><span class="line"><span class="built_in">MyCircle</span>()</span><br><span class="line"></span><br><span class="line">~<span class="built_in">MyCircle</span>() <span class="comment">// 从子类到父类依次析构</span></span><br><span class="line">~<span class="built_in">Circle</span>()</span><br><span class="line">~<span class="built_in">Shape</span>()</span><br></pre></td></tr></table></figure>

<h2 id="多态基类析构函数声明为protected"><a href="#多态基类析构函数声明为protected" class="headerlink" title="多态基类析构函数声明为protected"></a>多态基类析构函数声明为protected</h2><p>禁止从基类指针删除子类对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Circle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Circle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircle</span> : <span class="keyword">public</span> Circle</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyCircle</span>() &#123; cout &lt;&lt; <span class="string">&quot;~MyCircle()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">MyCircle</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> shape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;source&gt;: In function <span class="string">&#x27;int main()&#x27;</span>:</span><br><span class="line">&lt;source&gt;:<span class="number">32</span>:<span class="number">12</span>: error: <span class="string">&#x27;Shape::~Shape()&#x27;</span> is <span class="keyword">protected</span> within <span class="keyword">this</span> context</span><br><span class="line">   <span class="number">32</span> |     <span class="keyword">delete</span> shape;</span><br><span class="line">      |            ^~~~~</span><br><span class="line">&lt;source&gt;:<span class="number">10</span>:<span class="number">5</span>: note: declared <span class="keyword">protected</span> here</span><br><span class="line">   <span class="number">10</span> |     ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Shape()&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">      |     ^</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Linux内核</title>
    <url>/2024/02/19/note/linux/Linux%20kernel%20compiling/</url>
    <content><![CDATA[<h1 id="Linux-kernel-compiling"><a href="#Linux-kernel-compiling" class="headerlink" title="Linux kernel compiling"></a>Linux kernel compiling</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/cirosantilli/linux-kernel-module-cheat</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux page cache</title>
    <url>/2024/02/19/note/linux/PageCache%20/</url>
    <content><![CDATA[<h1 id="PageCache"><a href="#PageCache" class="headerlink" title="PageCache"></a>PageCache</h1><h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><ul>
<li>pagecache是最主要的一种disk cache</li>
<li>通过程序的方式，当读&#x2F;写文件时，将文件<strong>部分</strong>内容以页为单位在内存中缓存一份，提高未来多个进程对该文件的读写速度，由于是以页为单位，因此缓存的文件页不一定是文件中连续的。</li>
<li>如果有空闲内存，那么缓存的页一直常驻内存</li>
<li>当把页写回块设备时，也缓存一份要写入的内容，但内核不是立即写入设备，而是推迟一会儿写入设备，因为每次写入硬盘的速度很慢，攒够一波再发车。</li>
<li>read()和write()都用pagecache，除非是像数据库有数据立即写入硬盘需求，可以加O_DIRECT禁用pagecache。</li>
<li>如果断电了，page cache中未写入硬盘的页全丢了</li>
<li>dirty page写回硬盘的策略<ul>
<li>page cache量超出阈值或者dirty page cache超出阈值</li>
<li>dirty时常超出阈值</li>
<li>用户程序调sync(), fsync(), fdatasync()系统调用</li>
</ul>
</li>
<li>TODO：分析page cache工具 <a href="https://www.percona.com/blog/using-linux-fincore-to-check-linux-page-cache-usage/">https://www.percona.com/blog/using-linux-fincore-to-check-linux-page-cache-usage/</a></li>
<li>TODO: 实验page cache优化效果 <a href="https://www.linuxatemyram.com/play.html">https://www.linuxatemyram.com/play.html</a></li>
</ul>
<h1 id="清空disk-cache"><a href="#清空disk-cache" class="headerlink" title="清空disk cache"></a>清空disk cache</h1><ul>
<li><p>To free pagecache:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 | sudo tee /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
</li>
<li><p>To free dentries and inodes:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 2 | sudo tee /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>
</li>
<li><p>To free pagecache, dentries and inodes:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 3 | sudo tee /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://unix.stackexchange.com/a/87909/375713">https://unix.stackexchange.com/a/87909/375713</a></li>
</ul>
<h1 id="fincore"><a href="#fincore" class="headerlink" title="fincore"></a>fincore</h1><p>查看文件的pagecache情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个200MB的文件</span></span><br><span class="line">wqj@ubuntu-server:~/demo$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=bigfile bs=1M count=200</span><br><span class="line"></span><br><span class="line">wqj@ubuntu-server:~/demo$ ll -h</span><br><span class="line">total 201M</span><br><span class="line">drwxrwxr-x  2 wqj wqj 4.0K Oct 16 09:51 ./</span><br><span class="line">drwxr-xr-x 12 wqj wqj 4.0K Oct 16 09:40 ../</span><br><span class="line">-rw-rw-r--  1 wqj wqj 200M Oct 16 09:43 bigfile      <span class="comment"># 有一个200M的文件</span></span><br><span class="line"></span><br><span class="line">wqj@ubuntu-server:~/demo$ fincore bigfile <span class="comment"># 没有生成pagecache</span></span><br><span class="line">RES PAGES  SIZE FILE</span><br><span class="line"> 0B     0  200M bigfile</span><br><span class="line"></span><br><span class="line">wqj@ubuntu-server:~/demo$ time <span class="built_in">cat</span> bigfile &gt; /dev/null <span class="comment"># 读这个文件（生成pagecache）</span></span><br><span class="line"></span><br><span class="line">real    0m0.242s</span><br><span class="line">user    0m0.011s</span><br><span class="line">sys     0m0.203s</span><br><span class="line">wqj@ubuntu-server:~/demo$ fincore bigfile <span class="comment"># 验证生成pagecache</span></span><br><span class="line">  RES PAGES  SIZE FILE</span><br><span class="line"> 200M 51200  200M bigfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次读这个文件，读的是pagecache，速度提升 0.242/0.032=7.56倍</span></span><br><span class="line">wqj@ubuntu-server:~/demo$ time <span class="built_in">cat</span> bigfile &gt; /dev/null </span><br><span class="line"></span><br><span class="line">real    0m0.032s</span><br><span class="line">user    0m0.000s</span><br><span class="line">sys     0m0.032s</span><br></pre></td></tr></table></figure>

<h1 id="pcstat"><a href="#pcstat" class="headerlink" title="pcstat"></a>pcstat</h1><p><a href="https://github.com/tobert/pcstat">https://github.com/tobert/pcstat</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux ELF文件分析</title>
    <url>/2024/02/19/note/linux/elf/</url>
    <content><![CDATA[<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computing">computing</a>, the <strong>Executable and Linkable Format</strong>[<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#cite_note-linuxfoundation-elf-2">2]</a> (<strong>ELF</strong>, formerly named <strong>Extensible Linking Format</strong>), is a common standard <a href="https://en.wikipedia.org/wiki/File_format">file format</a> for <a href="https://en.wikipedia.org/wiki/Executable">executable</a> files, <a href="https://en.wikipedia.org/wiki/Object_code">object code</a>, <a href="https://en.wikipedia.org/wiki/Shared_library">shared libraries</a>, and <a href="https://en.wikipedia.org/wiki/Core_dump">core dumps</a>. – wikipedia</p>
</blockquote>
<p>本文分析ELF文件内容，以备日后查询。</p>
<h1 id="Object-File-Format"><a href="#Object-File-Format" class="headerlink" title="Object File Format"></a>Object File Format</h1><p><img src="/../assets/image-20231028195226909.png" alt="image-20231028195226909"></p>
<h1 id="ELF-Format-Overview"><a href="#ELF-Format-Overview" class="headerlink" title="ELF Format Overview"></a>ELF Format Overview</h1><p><img src="/../assets/image-20231028104927399.png" alt="image-20231028104927399"></p>
<h1 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h1><blockquote>
<p>Strictly speaking, the division into sections is intended to provide a convenient organization for use by the linker. Sections are intended to provide a view for the linker only.</p>
</blockquote>
<p>由 <code>section header table</code> 定义 sections.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:/home/cpp/build/self_mutate$ readelf --sections --wide demo</span><br><span class="line">There are 31 section headers, starting at offset 0x3ac8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        00000000004002a8 0002a8 00001c 00   A  0   0  1</span><br><span class="line">  [ 2] .note.gnu.build-id NOTE            00000000004002c4 0002c4 000024 00   A  0   0  4</span><br><span class="line">  [ 3] .note.ABI-tag     NOTE            00000000004002e8 0002e8 000020 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        0000000000400308 000308 00001c 00   A  5   0  8</span><br><span class="line">  [ 5] .dynsym           DYNSYM          0000000000400328 000328 000048 18   A  6   1  8</span><br><span class="line">  [ 6] .dynstr           STRTAB          0000000000400370 000370 000038 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          00000000004003a8 0003a8 000006 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         00000000004003b0 0003b0 000020 00   A  6   1  8</span><br><span class="line">  [ 9] .rela.dyn         RELA            00000000004003d0 0003d0 000030 18   A  5   0  8</span><br><span class="line">  [10] .init             PROGBITS        0000000000401000 001000 00001b 00  AX  0   0  4</span><br><span class="line">  [11] .text             PROGBITS        0000000000401020 001020 0001a5 00  AX  0   0 16</span><br><span class="line">  [12] .fini             PROGBITS        00000000004011c8 0011c8 00000d 00  AX  0   0  4</span><br><span class="line">  [13] .rodata           PROGBITS        0000000000402000 002000 000004 04  AM  0   0  4</span><br><span class="line">  [14] .eh_frame_hdr     PROGBITS        0000000000402004 002004 00002c 00   A  0   0  4</span><br><span class="line">  [15] .eh_frame         PROGBITS        0000000000402030 002030 0000a0 00   A  0   0  8</span><br><span class="line">  [16] .init_array       INIT_ARRAY      0000000000403e50 002e50 000008 08  WA  0   0  8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY      0000000000403e58 002e58 000008 08  WA  0   0  8</span><br><span class="line">  [18] .dynamic          DYNAMIC         0000000000403e60 002e60 000190 10  WA  6   0  8</span><br><span class="line">  [19] .got              PROGBITS        0000000000403ff0 002ff0 000010 08  WA  0   0  8</span><br><span class="line">  [20] .got.plt          PROGBITS        0000000000404000 003000 000018 08  WA  0   0  8</span><br><span class="line">  [21] .data             PROGBITS        0000000000404018 003018 000010 00  WA  0   0  8</span><br><span class="line">  [22] .bss              NOBITS          0000000000404028 003028 000008 00  WA  0   0  1</span><br><span class="line">  [23] .comment          PROGBITS        0000000000000000 003028 00002b 01  MS  0   0  1</span><br><span class="line">  [24] .debug_aranges    PROGBITS        0000000000000000 003053 000030 00      0   0  1</span><br><span class="line">  [25] .debug_info       PROGBITS        0000000000000000 003083 0000b2 00      0   0  1</span><br><span class="line">  [26] .debug_abbrev     PROGBITS        0000000000000000 003135 000028 00      0   0  1</span><br><span class="line">  [27] .debug_line       PROGBITS        0000000000000000 00315d 000054 00      0   0  1</span><br><span class="line">  [28] .symtab           SYMTAB          0000000000000000 0031b8 000600 18     29  47  8</span><br><span class="line">  [29] .strtab           STRTAB          0000000000000000 0037b8 0001e1 00      0   0  1</span><br><span class="line">  [30] .shstrtab         STRTAB          0000000000000000 003999 00012e 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><table>
<thead>
<tr>
<th>typedef struct {</th>
</tr>
</thead>
<tbody><tr>
<td>uint32_t sh_name;  &#x2F;* Section name (string tbl index) *&#x2F;</td>
</tr>
<tr>
<td>uint32_t sh_type;  &#x2F;* Section type  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_flags;  &#x2F;* Section flags  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_addr;  &#x2F;* Section virtual addr at execution *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_offset;  &#x2F;* Section file offset  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_size;  &#x2F;* Section size in bytes  *&#x2F;</td>
</tr>
<tr>
<td>uint32_t sh_link;  &#x2F;* Link to another section  *&#x2F;</td>
</tr>
<tr>
<td>uint32_t sh_info;  &#x2F;* Additional section information  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_addralign;  &#x2F;* Section alignment  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_entsize;  &#x2F;* Entry size if section holds table *&#x2F;</td>
</tr>
<tr>
<td>} Elf64_Shdr;</td>
</tr>
</tbody></table>
<blockquote>
<p> Files used during linking must have a section header table; </p>
</blockquote>
<h3 id="sh-name"><a href="#sh-name" class="headerlink" title="sh_name"></a>sh_name</h3><p>If set, it contains an index into the string table. If the index is zero, it means the section doesn’t have a name.</p>
<blockquote>
<p>a special section called .shstrtab, which<br>contains an array of NULL-terminated strings, one for every section name.<br>The index of the section header describing the string table is given in the<br>e_shstrndx field of the executable header. This allows tools like readelf to<br>easily find the .shstrtab section and then index it with the sh_name field of<br>every section header (including the header of .shstrtab) to find the string<br>describing the name of the section in question. This allows a human analyst<br>to easily identify the purpose of each section.2</p>
</blockquote>
<p>TODO: test above </p>
<h3 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h3><p><code>sh_type</code> tells the linker something about the structure of a section’s contents. </p>
<p><img src="/./assets/image-20231028162640052.png" alt="image-20231028162640052"></p>
<h4 id="SHT-PROGBITS"><a href="#SHT-PROGBITS" class="headerlink" title="SHT_PROGBITS"></a>SHT_PROGBITS</h4><blockquote>
<p>Sections with type SHT_PROGBITS contain program data, such as machine<br>instructions or constants. These sections have no particular structure for the<br>linker to parse.</p>
</blockquote>
<h4 id="SHT-SYMTAB"><a href="#SHT-SYMTAB" class="headerlink" title="SHT_SYMTAB"></a>SHT_SYMTAB</h4><p>static symbol tables. Symbol tables contain symbols in a well-defined format (struct Elf64_Sym in elf.h)</p>
<h4 id="SHT-DYNSYM"><a href="#SHT-DYNSYM" class="headerlink" title="SHT_DYNSYM"></a>SHT_DYNSYM</h4><p>symbol tables used by the dynamic linker.</p>
<h4 id="SHT-STRTAB"><a href="#SHT-STRTAB" class="headerlink" title="SHT_STRTAB"></a>SHT_STRTAB</h4><p>string tables, which simply contain an array of NULL-terminated strings, with the first byte in the string table set to NULL by convention.</p>
<h4 id="SHT-REL-SHT-RELA"><a href="#SHT-REL-SHT-RELA" class="headerlink" title="SHT_REL &#x2F; SHT_RELA"></a>SHT_REL &#x2F; SHT_RELA</h4><blockquote>
<p>Sections with type SHT_REL or SHT_RELA are particularly important for<br>the linker because they contain relocation entries in a well-defined format<br>(struct Elf64_Rel and struct Elf64_Rela in elf.h), which the linker can parse<br>to perform the necessary relocations in other sections. Each relocation entry<br>tells the linker about a particular location in the binary where a relocation is<br>needed and which symbol the relocation should be resolved to.</p>
</blockquote>
<h4 id="SHT-DYNAMIC"><a href="#SHT-DYNAMIC" class="headerlink" title="SHT_DYNAMIC"></a>SHT_DYNAMIC</h4><blockquote>
<p>Sections of type SHT_DYNAMIC contain information needed for dynamic<br>linking. This information is formatted using struct Elf64_Dyn as specified<br>in elf.h.</p>
</blockquote>
<h3 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h3><h4 id="SHF-WRITE"><a href="#SHF-WRITE" class="headerlink" title="SHF_WRITE"></a>SHF_WRITE</h4><p>SHF_WRITE indicates that the section is writable at runtime. </p>
<h4 id="SHF-ALLOC"><a href="#SHF-ALLOC" class="headerlink" title="SHF_ALLOC"></a>SHF_ALLOC</h4><blockquote>
<p>The SHF_ALLOC flag indicates that the contents of the section are to be loaded into virtual memory when executing the binary (though the actual loading happens using the segment view of the binary, not the section view).</p>
</blockquote>
<h4 id="SHF-EXECINSTR"><a href="#SHF-EXECINSTR" class="headerlink" title="SHF_EXECINSTR"></a>SHF_EXECINSTR</h4><blockquote>
<p>SHF_EXECINSTR tells you that the section contains executable instructions, which is useful to know when disassembling a binary.</p>
</blockquote>
<h3 id="sh-addr"><a href="#sh-addr" class="headerlink" title="sh_addr"></a>sh_addr</h3><p>virtual address of section.</p>
<blockquote>
<p>the linker sometimes needs to know at which addresses partic-<br>ular pieces of code and data will end up at runtime to do relocations. The<br>sh_addr field provides this information. Sections that aren’t intended to be<br>loaded into virtual memory when setting up the process have an sh_addr<br>value of zero.</p>
</blockquote>
<h3 id="sh-offset"><a href="#sh-offset" class="headerlink" title="sh_offset"></a>sh_offset</h3><p>file offset (in bytes from the start of the file)</p>
<h3 id="sh-size"><a href="#sh-size" class="headerlink" title="sh_size"></a>sh_size</h3><p>size (in bytes) of the section</p>
<h3 id="sh-info"><a href="#sh-info" class="headerlink" title="sh_info"></a>sh_info</h3><blockquote>
<p>The sh_info field contains additional information about the section. The<br>meaning of the additional information varies depending on the section type.<br>For instance, for relocation sections, sh_info denotes the index of the section<br>to which the relocations are to be applied.</p>
</blockquote>
<h3 id="sh-addralign"><a href="#sh-addralign" class="headerlink" title="sh_addralign"></a>sh_addralign</h3><blockquote>
<p>Some sections may need to be aligned in memory in a particular way for effi-<br>ciency of memory accesses. For example, a section may need to be loaded<br>at some address that is a multiple of 8 bytes or 16 bytes. These alignment<br>requirements are specified in the sh_addralign field. For instance, if this field<br>is set to 16, it means the base address of the section (as chosen by the linker)<br>must be some multiple of 16. The values 0 and 1 are reserved to indicate no<br>special alignment needs.</p>
</blockquote>
<h3 id="sh-entsize"><a href="#sh-entsize" class="headerlink" title="sh_entsize"></a>sh_entsize</h3><blockquote>
<p>Some sections, such as symbol tables or relocation tables, contain a table<br>of well-defined data structures (such as Elf64_Sym or Elf64_Rela). For such<br>sections, the sh_entsize field indicates the size in bytes of each entry in the<br>table. When the field is unused, it is set to zero</p>
</blockquote>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><h4 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [24] .data             PROGBITS        0000000000002000 001000 000010 00  WA  0   0  8</span><br></pre></td></tr></table></figure>

<h4 id="plt"><a href="#plt" class="headerlink" title=".plt"></a>.plt</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [13] .plt              PROGBITS        0000000000000550 000550 000050 10  AX  0   0 16</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000000000000550 &lt;.plt&gt;:</span><br><span class="line"> 550:    ff 35 8a 1a 00 00        pushq  0x1a8a(%rip)        # 1fe0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line"> 556:    f2 ff 25 8b 1a 00 00     bnd jmpq *0x1a8b(%rip)        # 1fe8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line"> 55d:    0f 1f 00                 nopl   (%rax)</span><br><span class="line"> 560:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 564:    68 00 00 00 00           pushq  $0x0</span><br><span class="line"> 569:    f2 e9 e1 ff ff ff        bnd jmpq 550 &lt;_init+0x28&gt;</span><br><span class="line"> 56f:    90                       nop</span><br><span class="line"> 570:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 574:    68 01 00 00 00           pushq  $0x1</span><br><span class="line"> 579:    f2 e9 d1 ff ff ff        bnd jmpq 550 &lt;_init+0x28&gt;</span><br><span class="line"> 57f:    90                       nop</span><br><span class="line"> 580:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 584:    f2 ff 25 65 1a 00 00     bnd jmpq *0x1a65(%rip)        # 1ff0 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br><span class="line"> 58b:    0f 1f 04 00              nopl   (%rax,%rax,1)</span><br><span class="line"> 58f:    90                       nop</span><br><span class="line"> 590:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 594:    f2 ff 25 5d 1a 00 00     bnd jmpq *0x1a5d(%rip)        # 1ff8 &lt;putchar@GLIBC_2.2.5&gt;</span><br><span class="line"> 59b:    0f 1f 04 00              nopl   (%rax,%rax,1)</span><br><span class="line"> 59f:    90                       nop</span><br></pre></td></tr></table></figure>

<h4 id="got"><a href="#got" class="headerlink" title=".got"></a>.got</h4><p>A GOT is simply a table of addresses, residing in the data section. The GOT entry, in turn, will contain the absolute address of the variable:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [22] .got              PROGBITS        0000000000001fb0 000fb0 000028 00  WA  0   0  8</span><br></pre></td></tr></table></figure>

<h4 id="got-plt"><a href="#got-plt" class="headerlink" title=".got.plt"></a>.got.plt</h4><p><code>.got.plt</code> 的前三项是有特殊意义的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOT[0]：保存的是“.dynamic”节的地址，这个节描述了本模块动态链接相关的信息</span><br><span class="line">GOT[1]：保存的是本模块的link_map结构的地址，动态链接器利用该地址来对符号进行解析。</span><br><span class="line">GOT[2]：保存的是_dl_runtime_resolve()的地址。</span><br></pre></td></tr></table></figure>

<p>其中第二项和第三项由动态链接器在装载共享模块的时候负责将它们初始化。</p>
<p><code>.got.plt</code>的其余项分别对应每个外部函数的引用</p>
<p><code>.got.plt</code> contains the addresses of the external <em>functions</em> used by the program.</p>
<p>PLT(Procedure Linkage Table) which is, put simply, used to call external procedures&#x2F;functions whose address isn’t known in the time of linking, and is left to be resolved by the dynamic linker at run time.</p>
<p>for code, things are a bit more complicated.</p>
<p>Whenever a function from a shared library is called, the linker makes us jump to an address in the PLT.</p>
<p>The first time the function is called, the PLT code uses offsets stored in the GOT to decide the actual final location of the function, and then:</p>
<ul>
<li>stores this pre-calculated value</li>
<li>jumps there</li>
</ul>
<p>The next times the function is called, the value has already been calculated, so it just jumps there directly.</p>
<p>Due to this lazy resolution mechanism:</p>
<ul>
<li>programs can start running quickly even if the shared libraries have a lot of symbols</li>
<li>we can replace functions on the fly by playing with the <code>LD_PRELOAD</code> variable</li>
</ul>
<h4 id="rela-text"><a href="#rela-text" class="headerlink" title=".rela.text"></a>.rela.text</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;        <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword    r_info;            <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword    r_addend;        <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p><img src="/../assets/2023-10-29-15-50-16-image.png"></p>
<h4 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h4><p>专门用于动态链接</p>
<p>动态链接ELF中<code>最重要的结构</code>应该是 **<code>.dynamic</code>**，这个节里面保存了<code>动态链接器</code>所需要的<code>基本信息</code>，比如依赖于哪些<code>共享对象</code>、<code>动态链接符号表</code>的位置、<code>动态链接重定位表</code>的位置、<code>共享对象初始化代码</code>的地址等。</p>
<p>使用<code>readelf</code>工具可以查看<code>“.dynamic”节</code>的内容：</p>
<ul>
<li><blockquote>
<p>-d –dynamic           Display the dynamic section (if present)</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -d a.out</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x750 contains 25 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048328</span><br><span class="line"> 0x0000000d (FINI)                       0x8048650</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049744</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049748</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0x804818c</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481c0</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048260</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481e0</span><br><span class="line"> 0x0000000a (STRSZ)                      95 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x8049844</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   48 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x80482f8</span><br><span class="line"> 0x00000011 (REL)                        0x80482f0</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482d0</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482c0</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure>



<h1 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h1><blockquote>
<p>segments, which are used at execution time (as opposed to sections, which are used at link time).</p>
</blockquote>
<blockquote>
<p>The program header table provides a segment view of the binary, as opposed to<br>the section view provided by the section header table. The section view of an<br>ELF binary, which I discussed earlier, is meant for static linking purposes<br>only. In contrast, the segment view, which I’ll discuss next, is used by the<br>operating system and dynamic linker when loading an ELF into a process for<br>execution to locate the relevant code and data and decide what to load into<br>virtual memory.</p>
</blockquote>
<p>由 <code>program header table</code> 定义 segments。由于 segment 提供运行时视角，因此只有可执行目标文件才有这个，不可执行的目标文件没有。</p>
<h2 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h2><table>
<thead>
<tr>
<th>typedef struct {</th>
</tr>
</thead>
<tbody><tr>
<td>uint32_t p_type;  &#x2F;* Segment type  *&#x2F;</td>
</tr>
<tr>
<td>uint32_t p_flags;  &#x2F;* Segment flags  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_offset; &#x2F;* Segment file offset  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_vaddr;  &#x2F;* Segment virtual address  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_paddr;  &#x2F;* Segment physical address *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_filesz; &#x2F;* Segment size in file  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_memsz;  &#x2F;* Segment size in memory  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_align;  &#x2F;* Segment alignment  *&#x2F;</td>
</tr>
<tr>
<td>} Elf64_Phdr;</td>
</tr>
</tbody></table>
<blockquote>
<p>A program header table, if present, tells the system how to create a process image.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:/home/cpp/build/self_mutate$ readelf --wide --segments demo</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x401020</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000400 0x000400 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x0001d5 0x0001d5 R E 0x1000</span><br><span class="line">  LOAD           0x002000 0x0000000000402000 0x0000000000402000 0x0000d0 0x0000d0 R   0x1000</span><br><span class="line">  LOAD           0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001d8 0x0001e0 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002e60 0x0000000000403e60 0x0000000000403e60 0x000190 0x000190 RW  0x8</span><br><span class="line">  NOTE           0x0002c4 0x00000000004002c4 0x00000000004002c4 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x002004 0x0000000000402004 0x0000000000402004 0x00002c 0x00002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line">  GNU_RELRO      0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001b0 0x0001b0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn </span><br><span class="line">   03     .init .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   06     .dynamic </span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<h3 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># /usr/include/elf.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Legal values for p_type (segment type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    PT_NULL        0        <span class="comment">/* Program header table entry unused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD        1        <span class="comment">/* Loadable program segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DYNAMIC    2        <span class="comment">/* Dynamic linking information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_INTERP    3        <span class="comment">/* Program interpreter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NOTE        4        <span class="comment">/* Auxiliary information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SHLIB    5        <span class="comment">/* Reserved */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_PHDR        6        <span class="comment">/* Entry for header table itself */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TLS        7        <span class="comment">/* Thread-local storage segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    PT_NUM        8        <span class="comment">/* Number of defined types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOOS        0x60000000    <span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_EH_FRAME    0x6474e550    <span class="comment">/* GCC .eh_frame_hdr segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_STACK    0x6474e551    <span class="comment">/* Indicates stack executability */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_RELRO    0x6474e552    <span class="comment">/* Read-only after relocation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOSUNW    0x6ffffffa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUNWBSS    0x6ffffffa    <span class="comment">/* Sun Specific segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUNWSTACK    0x6ffffffb    <span class="comment">/* Stack segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HISUNW    0x6fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIOS        0x6fffffff    <span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOPROC    0x70000000    <span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIPROC    0x7fffffff    <span class="comment">/* End of processor-specific */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="PT-PHDR"><a href="#PT-PHDR" class="headerlink" title="PT_PHDR"></a>PT_PHDR</h4><blockquote>
<p>PT_PHDR segment, which encompasses the program header table.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line"></span><br><span class="line">Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br></pre></td></tr></table></figure>

<h4 id="PT-LOAD"><a href="#PT-LOAD" class="headerlink" title="PT_LOAD"></a>PT_LOAD</h4><blockquote>
<p>Segments of type PT_LOAD, as the name implies, are intended to be loaded<br>into memory when setting up the process. The size of the loadable chunk<br>and the address to load it at are described in the rest of the program header.<br>As you can see in the readelf output, there are usually at least two PT_LOAD<br>segments—one encompassing the nonwritable sections and one containing<br>the writable data sections.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000400 0x000400 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x0001d5 0x0001d5 R E 0x1000</span><br><span class="line">  LOAD           0x002000 0x0000000000402000 0x0000000000402000 0x0000d0 0x0000d0 R   0x1000</span><br><span class="line">  LOAD           0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001d8 0x0001e0 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002e60 0x0000000000403e60 0x0000000000403e60 0x000190 0x000190 RW  0x8</span><br><span class="line">  NOTE           0x0002c4 0x00000000004002c4 0x00000000004002c4 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x002004 0x0000000000402004 0x0000000000402004 0x00002c 0x00002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line">  GNU_RELRO      0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001b0 0x0001b0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn </span><br><span class="line">   03     .init .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   06     .dynamic </span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<h4 id="PT-DYNAMIC"><a href="#PT-DYNAMIC" class="headerlink" title="PT_DYNAMIC"></a>PT_DYNAMIC</h4><blockquote>
<p>PT_DYNAMIC segment contains the .dynamic section, which tells the interpreter how to parse and prepare the binary for execution. </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:/home/cpp/build/self_mutate$ readelf --wide --segments demo</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x401020</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8       0</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1       1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000400 0x000400 R   0x1000    2</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x0001d5 0x0001d5 R E 0x1000    3</span><br><span class="line">  LOAD           0x002000 0x0000000000402000 0x0000000000402000 0x0000d0 0x0000d0 R   0x1000    4</span><br><span class="line">  LOAD           0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001d8 0x0001e0 RW  0x1000    5</span><br><span class="line"></span><br><span class="line">  DYNAMIC        0x002e60 0x0000000000403e60 0x0000000000403e60 0x000190 0x000190 RW  0x8       6</span><br><span class="line"></span><br><span class="line">  NOTE           0x0002c4 0x00000000004002c4 0x00000000004002c4 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x002004 0x0000000000402004 0x0000000000402004 0x00002c 0x00002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line">  GNU_RELRO      0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001b0 0x0001b0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn </span><br><span class="line">   03     .init .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line"></span><br><span class="line">   06     .dynamic </span><br><span class="line"></span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<h4 id="PT-INTERP"><a href="#PT-INTERP" class="headerlink" title="PT_INTERP"></a>PT_INTERP</h4><blockquote>
<p>The PT_INTERP segment contains the .interp section, which provides the name of the interpreter that is to be used to load the binary.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br></pre></td></tr></table></figure>

<h3 id="p-flag"><a href="#p-flag" class="headerlink" title="p_flag"></a>p_flag</h3><p>The flags specify the runtime access permissions for the segment.</p>
<h4 id="PF-X"><a href="#PF-X" class="headerlink" title="PF_X"></a>PF_X</h4><p>The PF_X flag indicates that the segment is executable and is set for code segments (readelf displays it as an E rather than an X in the Flg column</p>
<h4 id="PF-W"><a href="#PF-W" class="headerlink" title="PF_W"></a>PF_W</h4><p>The PF_W flag means that the segment is writable, and it is normally set only for writable data segments, never for code segments.</p>
<h4 id="PF-R"><a href="#PF-R" class="headerlink" title="PF_R"></a>PF_R</h4><p>PF_R means that the segment is readable, as is normally the case for both code and data segments.</p>
<h3 id="p-offset-p-vaddr-and-p-filesz"><a href="#p-offset-p-vaddr-and-p-filesz" class="headerlink" title="p_offset, p_vaddr, and p_filesz"></a>p_offset, p_vaddr, and p_filesz</h3><p>They specify the file offset at which the segment starts, the virtual address at which it is to be loaded, and the file size of the segment, respectively. </p>
<h3 id="p-paddr"><a href="#p-paddr" class="headerlink" title="p_paddr"></a>p_paddr</h3><p>On modern operating systems such as Linux, this field is unused and set to zero since they execute all binaries in virtual memory.</p>
<h3 id="p-memsz"><a href="#p-memsz" class="headerlink" title="p_memsz"></a>p_memsz</h3><p><code>p_filesz</code> is the file size of the segment and <code>p_memsz</code> is the size in memory. To understand this, recall that some sections only indicate the need to allocate some bytes in memory but don’t actually occupy these bytes in the binary file. For instance, the <code>.bss</code> section contains zero-initialized data. Since all data in this section is known to be zero anyway, there’s no need to actually include all these zeros in the binary. However, when loading the segment containing <code>.bss</code> into virtual memory, all the bytes in <code>.bss</code> should be allocated. Thus, it’s possible for <code>p_memsz</code> to be larger than <code>p_filesz</code>. When this happens, the loader adds the extra bytes at the end of the segment when loading the binary and initializes them to zero.</p>
<h3 id="p-align"><a href="#p-align" class="headerlink" title="p_align"></a>p_align</h3><p>It indicates the required memory alignment (in bytes) for the segment. An alignment value of 0 or 1 indicates that no particular alignment is required. If <code>p_align</code> isn’t set to 0 or 1, then its value must be a power of 2, and <code>p_vaddr</code> must be equal to <code>p_offset</code>, modulo p_align.</p>
<h1 id="Relocation"><a href="#Relocation" class="headerlink" title="Relocation"></a>Relocation</h1><p>主要参考这篇文章：</p>
<blockquote>
<p><a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">Position Independent Code (PIC) in shared libraries - Eli Bendersky’s website</a></p>
</blockquote>
<blockquote>
<p>Relocation is the process of connecting symbolic references with symbolic definitions. For<br>example, when a program calls a function, the associated call instruction must transfer control<br>to the proper destination address at execution. In other words, relocatable files must have<br>information that describes how to modify their section contents, thus allowing executable and<br>shared object files to hold the right information for a process’s program image. Relocation<br>entries are these data.</p>
</blockquote>
<p>Transform a relocatable file into either an executable or a shared object file. The link editor merges one or more relocatable files to form the output. It first decides how to combine and locate the input files, then updates the symbol values, and finally performs the relocation. Relocations applied to executable or shared object files are similar and accomplish the same result.</p>
<p><em>relocations</em> are entries in binaries that are left to be filled in later – at link time by the toolchain linker or at runtime by the dynamic linker.</p>
<blockquote>
<p>Briefly, when the linker creates a shared library, it doesn’t know in advance where it might be loaded.</p>
<p>There are two main approaches to solve this problem in Linux ELF shared libraries:</p>
<ol>
<li>Load-time relocation</li>
<li>Position independent code (PIC)</li>
</ol>
<p><a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">Position Independent Code (PIC) in shared libraries - Eli Bendersky’s website</a></p>
</blockquote>
<h2 id="Static-Relocation"><a href="#Static-Relocation" class="headerlink" title="Static Relocation"></a>Static Relocation</h2><p>静态链接器</p>
<h2 id="Dynamic-Relocation"><a href="#Dynamic-Relocation" class="headerlink" title="Dynamic Relocation"></a>Dynamic Relocation</h2><p>动态链接器 <code>/lib/ld-linux.so</code> 重定位程序对共享库中符号的引用的过程。</p>
<h3 id="PIC-Variable"><a href="#PIC-Variable" class="headerlink" title="PIC Variable"></a>PIC Variable</h3><p>单独由 <code>.got</code> section实现。</p>
<h4 id="Example-PIC变量"><a href="#Example-PIC变量" class="headerlink" title="Example - PIC变量"></a>Example - PIC变量</h4><p>读取动态库中的全局变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataonly.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myglob;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataonly.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myglob + a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dataonly.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ml_func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -fpic -shared -m32 -o libmlpic_dataonly.so dataonly.c</span><br><span class="line">gcc -m32 -o dataonlymain dataonlymain.c -L. -lmlpic_dataonly -g</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:. gdb dataonlymain</span></span><br><span class="line">(gdb) b ml_func</span><br></pre></td></tr></table></figure>

<p>从 .got 中取得 myglob 的绝对地址，.got中的绝对地址是 ld-linux.so 将 libmlpic_dataonly.so 加载后立刻解析出填充的。</p>
<p><img src="/../assets/image-20231029233741911.png" alt="image-20231029233741911"></p>
<p>.got 是静态链接器和动态连接器协商的结果，静态链接器将所有对 myglob 的访问都改成从.got取绝对地址，动态链接器加载动态库时，填充对应的绝对地址。</p>
<h3 id="PIC-Function-Lazy-Binding"><a href="#PIC-Function-Lazy-Binding" class="headerlink" title="PIC Function (Lazy Binding)"></a>PIC Function (Lazy Binding)</h3><p>PIC函数符号的绝对地址不是像PIC变量一样直接填充到<code>.got</code>，而是通过 lazy binding 实现，又多绕一层。首先，动态库中函数比全局变量多，开销更大；其次，有很多动态库函数，比如处理错误的，有可能在运行时根本不会调用到。为优化效率，PIC函数借助PLT实现lazy binding。</p>
<blockquote>
<p>When a shared library refers to some function, the real address of that function is not known until load time. Resolving this address is called <em>binding</em>, and it’s something the dynamic loader does when it loads the shared library into the process’s memory space. This binding process is non-trivial, since the loader has to actually <em>look up</em> the function symbol in special tables <a href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/#id13">[5]</a>.</p>
<p>So, resolving each function takes time. Not a lot of time, but it adds up since the amount of functions in libraries is typically much larger than the amount of global variables. Moreover, most of these resolutions are done in vain, because in a typical run of a program only a fraction of functions actually get called (think about various functions handling error and special conditions, which typically don’t get called at all).</p>
<p>So, to speed up this process, a clever lazy binding scheme was devised. “Lazy” is a generic name for a family of optimizations in computer programming, where work is delayed until the last moment when it’s actually needed, with the intention of avoiding doing this work if its results are never required during a specific run of a program. Good examples of laziness are <a href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> and <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>.</p>
</blockquote>
<p>由<code>.plt</code> + <code>.got.plt</code> 两个section配合实现。</p>
<p>函数首次调用时：</p>
<p><img src="/../assets/plt_before.png" alt="img"></p>
<p>上图的 GOT 是 <code>.got.plt</code></p>
<p><img src="/../assets/image-20231030080446860.png" alt="image-20231030080446860"></p>
<p>后续的函数调用：</p>
<p><img src="/../assets/plt_after.png" alt="img"></p>
<h4 id="Example-PIC函数"><a href="#Example-PIC函数" class="headerlink" title="Example - PIC函数"></a>Example - PIC函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_util_func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dynamic linker 听好了，你找到 ml_util_func 的绝对地址后，给我写入 0x2008 这个地址。</p>
<blockquote>
<p>The last line means that the dynamic loader should place the value (address) of symbol ml_util_func into 0x2008 (which, recall, is the GOT entry for this function).</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">readelf -r libmlpic.so</span></span><br><span class="line">[...] snip output</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x328 contains 3 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00002000  00000107 R_386_JUMP_SLOT   00000000   __cxa_finalize</span><br><span class="line">00002004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">00002008  00000707 R_386_JUMP_SLOT   0000046c   ml_util_func</span><br></pre></td></tr></table></figure>





<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><p><a href="https://refspecs.linuxbase.org/elf/elf.pdf">ELF标准定义文档</a></p>
</li>
<li><p>动态链接详解 - 你说起一个什么名的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/263094043">https://zhuanlan.zhihu.com/p/263094043</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/gnuemacs/p/14523720.html">https://www.cnblogs.com/gnuemacs/p/14523720.html</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux bfd</title>
    <url>/2024/02/19/note/linux/bfd/</url>
    <content><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="arelent"><a href="#arelent" class="headerlink" title="arelent"></a>arelent</h2><blockquote>
<p>BFD represents a relocation as a pointer to the ‘arelent’ type. A relocation describes an action which the linker must take to modify the section contents. Relocations have a symbol, an address, an addend, and a pointer to a howto structure which describes how to perform the relocation. </p>
</blockquote>
<blockquote>
<p>In BFD, each section has an array of ‘arelent’ structures. Each structure has a pointer to a symbol, an address within the section, an addend, and a pointer to a ‘reloc_howto_struct’ structure. The howto structure has a bunch of fields describing the reloc, including a type field. The type field is specific to the object file format backend; none of the generic code in BFD examines it.</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux epoll 学习</title>
    <url>/2024/02/19/note/linux/epoll/</url>
    <content><![CDATA[<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h1 id="边沿触发和水平触发"><a href="#边沿触发和水平触发" class="headerlink" title="边沿触发和水平触发"></a>边沿触发和水平触发</h1><p>只有epoll有这两种模式，select和poll均只有水平触发。</p>
<h2 id="一次write，水平触发，不read，"><a href="#一次write，水平触发，不read，" class="headerlink" title="一次write，水平触发，不read，"></a>一次write，水平触发，不read，</h2><p>写者调一次write，读者以默认的水平触发监听写事件，但不调read去读，结果就是epoll_wait一直在唤醒。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span> <span class="comment">// prctl(), PR_SET_PDEATHSIG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> <span class="comment">// signals</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// fork()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// perror()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> parent_pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="number">0</span>); <span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getppid</span>() != parent_pid)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Child process (Receiver)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]); <span class="comment">// Close the write end of the pipe in the child</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line"></span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ev.events |= EPOLLET; // Use ET mode</span></span><br><span class="line"></span><br><span class="line">        ev.data.fd = pipe_fd[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fcntl</span>(pipe_fd[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events;</span><br><span class="line">            <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, &amp;events, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nfds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Child found readable fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Parent process (Sender)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]); <span class="comment">// Close the read end of the pipe in the parent</span></span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, Child!&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Write the message to the pipe</span></span><br><span class="line">        <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent wrote: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the write end of the pipe in the parent to signal the end</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Parent wrote: Hello, Child!</span><br><span class="line">Child found readable fd</span><br><span class="line">Child found readable fd</span><br><span class="line">Child found readable fd</span><br><span class="line">Child found readable fd</span><br><span class="line">Child found readable fd</span><br><span class="line">Child found readable fd</span><br><span class="line">...</span><br><span class="line">Child found readable fd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="一次write，边沿触发，不read"><a href="#一次write，边沿触发，不read" class="headerlink" title="一次write，边沿触发，不read"></a>一次write，边沿触发，不read</h2><p>写者调一次write，读者以边沿触发监听写事件，但不调read去读，结果就是epoll_wait只在写着调用完write后唤醒一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span> <span class="comment">// prctl(), PR_SET_PDEATHSIG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> <span class="comment">// signals</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// fork()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// perror()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe_fd) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> parent_pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">-1</span>) &#123; <span class="built_in">perror</span>(<span class="number">0</span>); <span class="built_in">exit</span>(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getppid</span>() != parent_pid)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Child process (Receiver)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]); <span class="comment">// Close the write end of the pipe in the child</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line"></span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">        ev.events |= EPOLLET; <span class="comment">// Use ET mode</span></span><br><span class="line"></span><br><span class="line">        ev.data.fd = pipe_fd[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fcntl</span>(pipe_fd[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events;</span><br><span class="line">            <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, &amp;events, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nfds == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nfds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Child found readable fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Parent process (Sender)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]); <span class="comment">// Close the read end of the pipe in the parent</span></span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* message = <span class="string">&quot;Hello, Child!&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Write the message to the pipe</span></span><br><span class="line">        <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Parent wrote: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the write end of the pipe in the parent to signal the end</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Parent wrote: Hello, Child!</span><br><span class="line">Child found readable fd</span><br></pre></td></tr></table></figure>

<h2 id="连续write，边沿触发，不read"><a href="#连续write，边沿触发，不read" class="headerlink" title="连续write，边沿触发，不read"></a>连续write，边沿触发，不read</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span> <span class="comment">// prctl(), PR_SET_PDEATHSIG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>    <span class="comment">// signals</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// fork()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// perror()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe_fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> parent_pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getppid</span>() != parent_pid)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Child process (Receiver)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]); <span class="comment">// Close the write end of the pipe in the child</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line"></span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">        ev.events |= EPOLLET; <span class="comment">// Use ET mode</span></span><br><span class="line"></span><br><span class="line">        ev.data.fd = pipe_fd[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fcntl</span>(pipe_fd[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events;</span><br><span class="line">            <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, &amp;events, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nfds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;Child found readable fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parent process (Sender)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]); <span class="comment">// Close the read end of the pipe in the parent</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, Child!&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write the message to the pipe</span></span><br><span class="line">            <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message));</span><br><span class="line">            <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;Parent wrote: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the write end of the pipe in the parent to signal the end</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现，存在连续若干次的write合并为一次可读事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">5040</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">4558</span>]Child found readable fd</span><br></pre></td></tr></table></figure>

<h2 id="每秒一次write，水平触发，不read"><a href="#每秒一次write，水平触发，不read" class="headerlink" title="每秒一次write，水平触发，不read"></a>每秒一次write，水平触发，不read</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span> <span class="comment">// prctl(), PR_SET_PDEATHSIG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>    <span class="comment">// signals</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// fork()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// perror()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe_fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> parent_pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getppid</span>() != parent_pid)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Child process (Receiver)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]); <span class="comment">// Close the write end of the pipe in the child</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line"></span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ev.events |= EPOLLET; // Use ET mode</span></span><br><span class="line"></span><br><span class="line">        ev.data.fd = pipe_fd[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fcntl</span>(pipe_fd[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events;</span><br><span class="line">            <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, &amp;events, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nfds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;Child found readable fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parent process (Sender)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]); <span class="comment">// Close the read end of the pipe in the parent</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, Child!&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write the message to the pipe</span></span><br><span class="line">            <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message));</span><br><span class="line">            <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;Parent wrote: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the write end of the pipe in the parent to signal the end</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写者以每秒1次调write，读者如果没及时调read，epoll_wait会一直唤醒</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">1</span>]Child found readable fd</span><br><span class="line">[<span class="number">2</span>]Child found readable fd</span><br><span class="line">...</span><br><span class="line">[<span class="number">34190</span>]Child found readable fd</span><br><span class="line">[<span class="number">34191</span>]Child found readable fd</span><br><span class="line">[<span class="number">2</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">34192</span>]Child found readable fd</span><br><span class="line">[<span class="number">34193</span>]Child found readable fd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="每秒一次write，边沿触发，不read"><a href="#每秒一次write，边沿触发，不read" class="headerlink" title="每秒一次write，边沿触发，不read"></a>每秒一次write，边沿触发，不read</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span> <span class="comment">// prctl(), PR_SET_PDEATHSIG</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span>    <span class="comment">// signals</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>    <span class="comment">// fork()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">// perror()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipe_fd) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> parent_pid = <span class="built_in">getpid</span>();</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">prctl</span>(PR_SET_PDEATHSIG, SIGTERM);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getppid</span>() != parent_pid)</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Child process (Receiver)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]); <span class="comment">// Close the write end of the pipe in the child</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line"></span><br><span class="line">        ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">        ev.events |= EPOLLET; <span class="comment">// Use ET mode</span></span><br><span class="line"></span><br><span class="line">        ev.data.fd = pipe_fd[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, pipe_fd[<span class="number">0</span>], &amp;ev) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fcntl</span>(pipe_fd[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events;</span><br><span class="line">            <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, &amp;events, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nfds == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nfds &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++count;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;Child found readable fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parent process (Sender)</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]); <span class="comment">// Close the read end of the pipe in the parent</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, Child!&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write the message to the pipe</span></span><br><span class="line">            <span class="type">ssize_t</span> bytes_written = <span class="built_in">write</span>(pipe_fd[<span class="number">1</span>], message, <span class="built_in">strlen</span>(message));</span><br><span class="line">            <span class="keyword">if</span> (bytes_written == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;Parent wrote: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the write end of the pipe in the parent to signal the end</span></span><br><span class="line">        <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有写者调用write时，epoll_wait才唤醒一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">1</span>]Child found readable fd</span><br><span class="line">[<span class="number">2</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">2</span>]Child found readable fd</span><br><span class="line">[<span class="number">3</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">3</span>]Child found readable fd</span><br><span class="line">[<span class="number">4</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">4</span>]Child found readable fd</span><br><span class="line">[<span class="number">5</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">5</span>]Child found readable fd</span><br><span class="line">[<span class="number">6</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">6</span>]Child found readable fd</span><br><span class="line">[<span class="number">7</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">7</span>]Child found readable fd</span><br><span class="line">[<span class="number">8</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">8</span>]Child found readable fd</span><br><span class="line">[<span class="number">9</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">9</span>]Child found readable fd</span><br><span class="line">[<span class="number">10</span>]Parent wrote: Hello, Child!</span><br><span class="line">[<span class="number">10</span>]Child found readable fd</span><br></pre></td></tr></table></figure>

<h1 id="为什么边沿触发效率更高"><a href="#为什么边沿触发效率更高" class="headerlink" title="为什么边沿触发效率更高"></a>为什么边沿触发效率更高</h1>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Ftrace</title>
    <url>/2024/02/19/note/linux/ftrace/</url>
    <content><![CDATA[<h1 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h1><p><a href="https://www.youtube.com/watch?v=68osT1soAPM">https://www.youtube.com/watch?v=68osT1soAPM</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t debugfs none /sys/kernel/debug/</span><br></pre></td></tr></table></figure>

<h3 id="跟踪open"><a href="#跟踪open" class="headerlink" title="跟踪open()"></a>跟踪open()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>    <span class="comment">// For O_RDONLY</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>   <span class="comment">// For open, getpid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span>     <span class="comment">// For errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>    <span class="comment">// For strerror</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">// For std::cerr</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file (PID: &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用ftrace+kprobe获取调用栈及入参和返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">CUR_DIR=$(<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line">TRACING_DIR=/sys/kernel/debug/tracing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用debugfs</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$TRACING_DIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mount -t debugfs none /sys/kernel/debug/</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$TRACING_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置tracer参数</span></span><br><span class="line"><span class="built_in">echo</span> function_graph &gt; current_tracer <span class="comment"># 抓取函数调用栈</span></span><br><span class="line"><span class="built_in">echo</span> do_sys_open &gt; set_graph_function <span class="comment"># 只抓取这个函数及其内部</span></span><br><span class="line"><span class="built_in">echo</span> funcgraph-proc &gt; trace_options <span class="comment"># 显示进程名列</span></span><br><span class="line"><span class="built_in">echo</span> funcgraph-tail &gt; trace_options <span class="comment"># 函数结束大括号处注释函数名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭所有event</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; <span class="variable">$TRACING_DIR</span>/events/enable</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p:pre_do_sys_open do_sys_open dfd=%di filename=+0(%si):string flags=%dx mode=%cx&#x27;</span> &gt; kprobe_events</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r:post_do_sys_open do_sys_open fd=$retval&#x27;</span> &gt;&gt; kprobe_events</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;filename ~ &quot;example.txt&quot;&#x27;</span> &gt; events/kprobes/pre_do_sys_open/filter</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p:pre_link_path_walk link_path_walk name=+0(%di):string name_hex=%di:x64&#x27;</span> &gt;&gt; kprobe_events</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r:post_link_path_walk link_path_walk ret=$retval:x64&#x27;</span> &gt;&gt; kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r:post_step_into step_into ret=+0($retval):string ret_hex=$retval:x64&#x27;</span> &gt;&gt; kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; events/kprobes/pre_do_sys_open/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; events/kprobes/post_do_sys_open/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; events/kprobes/pre_link_path_walk/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; events/kprobes/post_link_path_walk/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; events/kprobes/post_step_into/enable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启所有event</span></span><br><span class="line"><span class="comment"># echo 1 &gt; $TRACING_DIR/events/enable</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空trace历史记录</span></span><br><span class="line"><span class="built_in">echo</span> &gt; trace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始trace</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start tracer&quot;</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; <span class="variable">$TRACING_DIR</span>/tracing_on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行程序</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$CUR_DIR</span></span><br><span class="line">./a.out</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止trace</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; <span class="variable">$TRACING_DIR</span>/tracing_on</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$TRACING_DIR</span>/trace &gt; trace.out</span><br><span class="line">gawk -F<span class="string">&#x27;|&#x27;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> trace.out &gt; trace.func</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;stop tracer&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="Tracing-Events"><a href="#Tracing-Events" class="headerlink" title="Tracing Events"></a>Tracing Events</h1><p>official doc: <a href="https://www.kernel.org/doc/html/v4.19/trace/events.html#event-tracing">https://www.kernel.org/doc/html/v4.19/trace/events.html#event-tracing</a></p>
<img src="./assets/image-20231121090802788.png" alt="image-20231121090802788" style="zoom:50%;" />

<img src="./assets/image-20231121090739325.png" alt="image-20231121090739325" style="zoom:50%;" />

<img src="./assets/image-20231121091847105.png" alt="image-20231121091847105" style="zoom:50%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:/sys/kernel$ sudo <span class="built_in">ls</span> /sys/kernel/debug/tracing/events</span><br><span class="line">9p            btrfs       dev           exceptions  fs_dax        hyperv       iommu        kvm        msr      netvsc  page_isolation  ras           <span class="built_in">sched</span>   sock      thermal   workqueue</span><br><span class="line">alarmtimer    cgroup      dma_fence     ext4        fscache       i2c          irq          kvmmmu     napi     nfs     pagemap         raw_syscalls  scsi    sunrpc    timer     writeback</span><br><span class="line">block         cifs        drm           fib         ftrace        initcall     irq_matrix   migrate    neigh    nfs4    percpu          rcu           sctp    swiotlb   tlb       x86_fpu</span><br><span class="line">bpf_test_run  clk         <span class="built_in">enable</span>        fib6        header_event  intel_iommu  irq_vectors  mmap       net      nfsd    power           rpcgss        signal  syscalls  udp       xdp</span><br><span class="line">bpf_trace     compaction  erofs         filelock    header_page   io_uring     jbd2         mmap_lock  netfs    nmi     printk          rseq          skb     task      vmscan    xfs</span><br><span class="line">bridge        cpuhp       error_report  filemap     huge_memory   iomap        kmem         module     netlink  oom     qdisc           rtc           smbus   tcp       vsyscall  xfs_scrub</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:/sys/kernel$ sudo <span class="built_in">ls</span> /sys/kernel/debug/tracing/events/irq</span><br><span class="line"><span class="built_in">enable</span>  filter  irq_handler_entry  irq_handler_exit  softirq_entry  softirq_exit  softirq_raise</span><br></pre></td></tr></table></figure>

<p><img src="/./assets/image-20231121092040288.png" alt="image-20231121092040288"></p>
<p><img src="/./assets/image-20231121092253164.png" alt="image-20231121092253164"></p>
<p><img src="/./assets/image-20231121092331682.png" alt="image-20231121092331682"></p>
<p><img src="/./assets/image-20231121092908547.png" alt="image-20231121092908547"></p>
<p><img src="/./assets/image-20231121093352031.png" alt="image-20231121093352031"></p>
<p><img src="/./assets/image-20231121093515480.png" alt="image-20231121093515480"></p>
<h1 id="trace-cmd"><a href="#trace-cmd" class="headerlink" title="trace-cmd"></a>trace-cmd</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install trace-cmd</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-p tracer</span><br><span class="line">           Specify a tracer. Tracers usually <span class="keyword">do</span> more than just trace an</span><br><span class="line">           event. Common tracers are: <span class="keyword">function</span>, function_graph,</span><br><span class="line">           preemptirqsoff, irqsoff, preemptoff and wakeup. A tracer must</span><br><span class="line">           be supported by the running kernel. To see a list of</span><br><span class="line">           available tracers, see trace-cmd-list(1).</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">trace-cmd record -p function_graph -n do_sys_open ./a.out</span><br></pre></td></tr></table></figure>

<h1 id="Kprobe"><a href="#Kprobe" class="headerlink" title="Kprobe"></a>Kprobe</h1><p>ftrace能打印出内核函数调用栈，但是入参和返回值获取不到，这时候用kprobe。</p>
<p>ref: <a href="https://docs.kernel.org/trace/kprobetrace.html">Kprobe-based Event Tracing &#8212; The Linux Kernel documentation</a></p>
<p>add probe points</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt;&gt; /sys/kernel/debug/tracing/kprobe_events</span><br></pre></td></tr></table></figure>

<p>enable probe points</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/&lt;EVENT&gt;/enabled.</span><br></pre></td></tr></table></figure>

<p>To add a probe as a new event, write a new definition to kprobe_events as below.</p>
<blockquote>
<p>Note:</p>
<p>The register&#x2F;stack entry assigned to each function argument depends on arch-specific ABI.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;p:myprobe do_sys_open dfd=%ax filename=%dx flags=%cx mode=+4($stack)&#x27;</span> &gt; /sys/kernel/debug/tracing/kprobe_events</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认是否加上</span></span><br><span class="line">$ <span class="built_in">ls</span> /sys/kernel/debug/tracing/events/kprobes/myprobe/</span><br><span class="line"><span class="built_in">enable</span>  filter  format  <span class="built_in">id</span>  trigger</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;r:myretprobe do_sys_open $retval&#x27;</span> &gt;&gt; /sys/kernel/debug/tracing/kprobe_events</span><br></pre></td></tr></table></figure>

<p>Right after definition, each event is disabled by default. For tracing these events, you need to enable it.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myprobe/enable</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/kprobes/myretprobe/enable</span><br></pre></td></tr></table></figure>

<h2 id="开关event"><a href="#开关event" class="headerlink" title="开关event"></a>开关event</h2><p><a href="https://www.chiark.greenend.org.uk/doc/linux-doc-5.10/html/trace/events.html#via-the-enable-toggle">Event Tracing &mdash; The Linux Kernel documentation</a></p>
<p>To enable event ‘sched_wakeup’:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable</span><br></pre></td></tr></table></figure>

<p>To disable it:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/kernel/debug/tracing/events/sched/sched_wakeup/enable</span><br></pre></td></tr></table></figure>

<p>To enable all events in sched subsystem:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/sched/enable</span><br></pre></td></tr></table></figure>

<p>To enable all events:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/kernel/debug/tracing/events/enable</span><br></pre></td></tr></table></figure>

<p>When reading one of these enable files, there are four results:</p>
<blockquote>
<ul>
<li><p>0 - all events this file affects are disabled</p>
</li>
<li><p>1 - all events this file affects are enabled</p>
</li>
<li><p>X - there is a mixture of events enabled and disabled</p>
</li>
<li><p>? - this file does not affect any event</p>
</li>
</ul>
</blockquote>
<h2 id="寄存器位长格式"><a href="#寄存器位长格式" class="headerlink" title="寄存器位长格式"></a>寄存器位长格式</h2><p>x86_64 寄存器如 rdx, rdi 带有 ‘r’ 前缀，但是加kprobe时，不识别’r’前缀，原因为kprobe自动识别位长，不用加前缀。</p>
<p>转而可用类型转换指明想要的长度。</p>
<blockquote>
<p>After discussing with <code>kprobe</code> maintainer, I get the answer:</p>
<p><code>ftrace-kprobe</code> interface does not accept bitwidth prefix like ‘<code>rax</code>‘ instead it accepts ‘<code>ax</code>‘. </p>
<p>The bitwidth is automatically chosen by architecture. So please remove ‘<code>r</code>‘ from all arguments. </p>
<p>If you’d like to access <code>eax</code> or <code>ax</code>, you can use typecast, like as <code>%ax:u32</code>.</p>
<p><a href="https://stackoverflow.com/questions/33096225/how-to-use-registers-in-kprobe">linux - How to use registers in kprobe? - Stack Overflow</a></p>
</blockquote>
<h2 id="入参为结构体指针"><a href="#入参为结构体指针" class="headerlink" title="入参为结构体指针"></a>入参为结构体指针</h2><p>怎么知道内存布局从而取特定字段？用C版本kprobe应该行。</p>
<h2 id="参数过滤"><a href="#参数过滤" class="headerlink" title="参数过滤"></a>参数过滤</h2><p><a href="https://www.chiark.greenend.org.uk/doc/linux-doc-5.10/html/trace/events.html#event-filtering">Event Tracing &mdash; The Linux Kernel documentation</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="在内核函数内任意位置绑定回调"><a href="#在内核函数内任意位置绑定回调" class="headerlink" title="在内核函数内任意位置绑定回调"></a>在内核函数内任意位置绑定回调</h3><p><a href="https://medium.com/@hu3vjeen/modifying-kernel-behavior-using-kprobe-based-modules-2795b0716964">https://medium.com/@hu3vjeen/modifying-kernel-behavior-using-kprobe-based-modules-2795b0716964</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux GAS</title>
    <url>/2024/02/19/note/linux/gas/</url>
    <content><![CDATA[<p>备忘Linux下 AT&amp;T 汇编语法。</p>
<p><a href="https://sourceware.org/binutils/docs/as/">GAS文档</a></p>
<h2 id="操作数的顺序"><a href="#操作数的顺序" class="headerlink" title="操作数的顺序"></a>操作数的顺序</h2><p>从左向右</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">movq %rsp, %rbp <span class="comment">// copy %rsp to %rbp</span></span><br></pre></td></tr></table></figure>

<h2 id="其他一些特点"><a href="#其他一些特点" class="headerlink" title="其他一些特点"></a>其他一些特点</h2><ul>
<li>mnemonic suffixes indicate the size of the operands (<code>q</code> for quad, etc.)</li>
<li>registers are prefixed with <code>%</code> and immediate values with <code>$</code></li>
<li>effective addresses are in the form <code>DISP(BASE, INDEX, SCALE)</code> (DISP + BASE + INDEX * SCALE)</li>
<li>Indirect jump&#x2F;call operands indicated with * (as opposed to direct).</li>
</ul>
<h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>如下代码中圆括号的含义？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov (%rax), %eax</span><br></pre></td></tr></table></figure>

<p>解释：<br>从 <code>rax</code> 寄存器中保存的内存地址读出4字节，复制到 <code>eax</code> 寄存器。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/41232333/what-is-the-difference-between-mov-rax-eax-and-mov-rax-eax">详见 stackoverflow</a></li>
</ul>
<p>如下代码含义？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov %rcx, %rax</span><br></pre></td></tr></table></figure>

<p>解释：复制 <code>rcx</code> 中8字节到 <code>rax</code> 中</p>
<p>因此，圆括号表示解引用。</p>
<p>如果反过来，则是将 <code>rax</code> 中的8字节，拷贝到 <code>rbx</code> 所指的8字节内存中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov %rax,(%rbx)</span><br></pre></td></tr></table></figure>

<p>等价于c中的（<code>rax</code> 中是 value，<code>rbx</code> 中是 ptr）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*ptr = value;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-符号"><a href="#Symbol-符号" class="headerlink" title="Symbol 符号"></a>Symbol 符号</h2><blockquote>
<p>Symbols are a central concept: the programmer uses symbols to name things, the linker uses symbols to link, and the debugger uses symbols to debug.</p>
</blockquote>
<h3 id="符号名"><a href="#符号名" class="headerlink" title="符号名"></a>符号名</h3><ul>
<li>区分大小写，foo !&#x3D; Foo</li>
<li>符号名首个字符可以是 字母、英文句号、短下划线或者$</li>
<li>后面跟若干数字、字母、$</li>
</ul>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>符号名+’:’</p>
<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><h3 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h3><p>末尾加一个字节，值为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">s3:</span><br><span class="line">    .string &quot;ccc&quot;</span><br><span class="line">    .ascii &quot;ccc&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ as demo.s &amp;&amp; objdump -sD</span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 63636300 636363                      ccc.ccc         </span><br><span class="line"></span><br><span class="line">Disassembly of section .data:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;s3&gt;:</span><br><span class="line">   0:   63 63 63                movslq 0x63(%rbx),%esp</span><br><span class="line">   3:   00 63 63                add    %ah,0x63(%rbx)</span><br><span class="line">   6:   63                      .byte 0x63</span><br></pre></td></tr></table></figure>

<h3 id="ascii"><a href="#ascii" class="headerlink" title=".ascii"></a>.ascii</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">.s1:</span><br><span class="line">    .ascii &quot;aaa&quot;</span><br><span class="line">s2:</span><br><span class="line">    .ascii &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">s3:</span><br><span class="line">    .ascii &quot;ccc&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ as demo.s &amp;&amp; objdump -s a.out </span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 636363                               ccc             </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 61616162 6262                        aaabbb          </span><br></pre></td></tr></table></figure>

<h2 id="L"><a href="#L" class="headerlink" title=".L"></a>.L</h2><p>GCC uses the .L for local labels.</p>
<h2 id="LFB-LFE-LBB-LBE"><a href="#LFB-LFE-LBB-LBE" class="headerlink" title=".LFB, .LFE, .LBB, .LBE"></a>.LFB, .LFE, .LBB, .LBE</h2><p>They are all defined under <a href="https://github.com/gcc-mirror/gcc/blob/releases/gcc-4.8.2/gcc/dwarf2out.c">gcc&#x2F;dwarf2out.c</a> on GCC 4.8.2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC_BEGIN_LABEL  <span class="string">&quot;LFB&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC_END_LABEL    <span class="string">&quot;LFE&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_BEGIN_LABEL <span class="string">&quot;LBB&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_END_LABEL   <span class="string">&quot;LBE&quot;</span></span></span><br><span class="line">ASM_GENERATE_INTERNAL_LABEL (loclabel, <span class="string">&quot;LVL&quot;</span>, loclabel_num);</span><br></pre></td></tr></table></figure>

<h1 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                      +-----+----+--+</span><br><span class="line">partial program # 1:  |ttttt|dddd|00|</span><br><span class="line">                      +-----+----+--+</span><br><span class="line"></span><br><span class="line">                      text   data bss</span><br><span class="line">                      seg.   seg. seg.</span><br><span class="line"></span><br><span class="line">                      +---+---+---+</span><br><span class="line">partial program # 2:  |TTT|DDD|000|</span><br><span class="line">                      +---+---+---+</span><br><span class="line"></span><br><span class="line">                      +--+---+-----+--+----+---+-----+~~</span><br><span class="line">linked program:       |  |TTT|ttttt|  |dddd|DDD|00000|</span><br><span class="line">                      +--+---+-----+--+----+---+-----+~~</span><br><span class="line"></span><br><span class="line">    addresses:        0 …</span><br></pre></td></tr></table></figure>

<p>TODO: section group 是什么？</p>
<h1 id="Directive-指示符"><a href="#Directive-指示符" class="headerlink" title="Directive 指示符"></a>Directive 指示符</h1><p>All assembler directives have names that begin with a period <code>.</code></p>
<p>The rest of the name is letters, usually in lower case.</p>
<blockquote>
<p>用途</p>
</blockquote>
<p>In AT&amp;T assembly syntax, a directive is a command that is used to instruct the assembler on how to process the information in the assembly source code. Unlike instructions, which tell the CPU what to do, directives tell the assembler how to process the information. </p>
<h2 id="quad"><a href="#quad" class="headerlink" title=".quad"></a>.quad</h2><p><a href="https://sourceware.org/binutils/docs/as/Quad.html">填充8字节</a></p>
<blockquote>
<p><a href="https://sourceware.org/binutils/docs-2.18/as/LNS-directives.html#LNS-directives">.loc</a> </p>
</blockquote>
<p>a debugging directive, and it only appears in GCC if you tell the compiler to generate debugging information with -ggdb or -g.</p>
<h1 id="movq-movl-movw"><a href="#movq-movl-movw" class="headerlink" title="movq, movl, movw"></a>movq, movl, movw</h1><ol>
<li><strong><code>movw</code></strong>: move a word (16 bits)</li>
<li><strong><code>movl</code></strong>: move a long word (32 bits)</li>
<li><strong><code>movq</code></strong>: move a quadword (64 bits)</li>
</ol>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>执行后，将 <code>rip</code> 放入栈顶，然后调新函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global main</span><br><span class="line"></span><br><span class="line">foo:</span><br><span class="line">    pushq %rax</span><br><span class="line">    movq %rax, %rbp</span><br><span class="line"></span><br><span class="line">main:    </span><br><span class="line">    call foo // 调用foo之前，将rip入栈</span><br><span class="line"></span><br><span class="line">    movq $60, %rax  # syscall: exit</span><br><span class="line">    xorq %rdi, %rdi # status: 0</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc call.s -g -o call</span><br></pre></td></tr></table></figure>

<p>用GDB调试</p>
<p><img src="/../assets/2023-10-29-22-46-18-image.png"></p>
<p>进入foo之后，打印栈顶8字节，正是rip的值。同时发现，rip指向栈顶元素（8个字节中最低位一个字节 0x02，因小端存储）</p>
<p><img src="/../assets/2023-10-29-22-48-19-image.png"></p>
<h1 id="Effective-Address"><a href="#Effective-Address" class="headerlink" title="Effective Address"></a>Effective Address</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[base + index*scale + disp]      # Intel, including GAS .<span class="function">intel_syntax noprefix</span></span><br><span class="line"><span class="function"><span class="title">disp</span><span class="params">(base, index, scale)</span>         # AT&amp;T</span></span><br></pre></td></tr></table></figure>

<p><img src="/../assets/image-13.png" alt="Alt text"></p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc/g++</title>
    <url>/2024/02/19/note/linux/gcc/</url>
    <content><![CDATA[<h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><h2 id="Wl-xxx"><a href="#Wl-xxx" class="headerlink" title="-Wl,xxx"></a>-Wl,xxx</h2><p>The <code>-Wl,xxx</code> option for <strong>gcc</strong> passes a comma-separated list of tokens as a space-separated list of arguments to the <strong>linker</strong>. So</p>
<pre><code>gcc -Wl,aaa,bbb,ccc
</code></pre>
<p>eventually becomes a linker call</p>
<pre><code>ld aaa bbb ccc
</code></pre>
<p>If you want to say “<code>ld -rpath .</code>“, you pass this to gcc as <code>-Wl,-rpath,.</code> Alternatively, you can specify repeat instances of <code>-Wl</code>:</p>
<pre><code>gcc -Wl,aaa -Wl,bbb -Wl,ccc
</code></pre>
<p>Note that there is no comma between <code>aaa</code> and the second <code>-Wl</code>.</p>
<p>ref: <a href="https://stackoverflow.com/a/6562437">https://stackoverflow.com/a/6562437</a></p>
<h2 id="Disable-PIE"><a href="#Disable-PIE" class="headerlink" title="Disable PIE"></a>Disable PIE</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -g -fno-pie -no-pie t.c</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TLDR; -fno-pie is a “code generation option” while -no-pie is a “linker option”. You need both. <a href="https://stackoverflow.com/a/76008786/11850070">https://stackoverflow.com/a/76008786/11850070</a></p>
</blockquote>
<h2 id="g-dump-vtable"><a href="#g-dump-vtable" class="headerlink" title="g++ dump vtable"></a>g++ dump vtable</h2><p>I want to see how g++ lays out memory for classes and virtual tables.</p>
<p>Is there a way to dump this information, using g++’s options?</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fdump-class-hierarchy -c source_file.cpp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc 8+</span></span><br><span class="line">[root@ZLPC-wangqingjia demo]# g++ -fdump-lang-class demo.cpp </span><br><span class="line">[root@ZLPC-wangqingjia demo]# ll demo.cpp.001l.class </span><br><span class="line">-rw-r--r-- 1 root root 132683 Nov 30 20:03 demo.cpp.001l.class</span><br></pre></td></tr></table></figure>

<p>Note that in g++ 8 this flag was switched to <code>-fdump-lang-class</code>. </p>
<p>This also works for g++ 9. See <a href="https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/Developer-Options.html">gcc.gnu.org&#x2F;onlinedocs&#x2F;gcc-9.1.0&#x2F;gcc&#x2F;Developer-Options.html</a></p>
<p>加上 <code>=stdout</code> 后缀，输出到命令行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fdump-lang-class=stdout demo.cpp</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux glibc</title>
    <url>/2024/02/19/note/linux/glibc/</url>
    <content><![CDATA[<h2 id="编译glibc"><a href="#编译glibc" class="headerlink" title="编译glibc"></a>编译glibc</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://sourceware.org/git/glibc.git</span><br><span class="line"><span class="built_in">cd</span> glibc</span><br><span class="line">git checkout glibc-2.32</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="built_in">export</span> glibc_install=<span class="string">&quot;<span class="subst">$(pwd)</span>/install&quot;</span></span><br><span class="line">../configure --prefix <span class="string">&quot;<span class="variable">$glibc_install</span>&quot;</span></span><br><span class="line">make -j `<span class="built_in">nproc</span>`</span><br><span class="line">make install -j `<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure>

<h2 id="用linux自带的gcc编译程序并链接glibc"><a href="#用linux自带的gcc编译程序并链接glibc" class="headerlink" title="用linux自带的gcc编译程序并链接glibc"></a>用linux自带的gcc编译程序并链接glibc</h2><p>test_glibc.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threads.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int</span> acnt;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">void</span>* thr_data)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        ++acnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="comment">/* Basic library version check. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gnu_get_libc_version() = %s\n&quot;</span>, gnu_get_libc_version());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exercise thrd_create from -pthread,</span></span><br><span class="line"><span class="comment">     * which is not present in glibc 2.27 in Ubuntu 18.04.</span></span><br><span class="line"><span class="comment">     * https://stackoverflow.com/questions/56810/how-do-i-start-threads-in-plain-c/52453291#52453291 */</span></span><br><span class="line">    <span class="type">thrd_t</span> thr[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">        thrd_create(&amp;thr[n], f, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; ++n)</span><br><span class="line">        thrd_join(thr[n], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The atomic counter is %u\n&quot;</span>, acnt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The non-atomic counter is %u\n&quot;</span>, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test_glibc.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">set</span> -eux</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> glibc_install=<span class="string">&quot;<span class="subst">$(pwd)</span>/build/install&quot;</span></span><br><span class="line"></span><br><span class="line">gcc \</span><br><span class="line">  -L <span class="string">&quot;<span class="variable">$&#123;glibc_install&#125;</span>/lib&quot;</span> \</span><br><span class="line">  -I <span class="string">&quot;<span class="variable">$&#123;glibc_install&#125;</span>/include&quot;</span> \</span><br><span class="line">  -Wl,--rpath=<span class="string">&quot;<span class="variable">$&#123;glibc_install&#125;</span>/lib&quot;</span> \</span><br><span class="line">  -Wl,--dynamic-linker=<span class="string">&quot;<span class="variable">$&#123;glibc_install&#125;</span>/lib/ld-linux-x86-64.so.2&quot;</span> \</span><br><span class="line">  -std=c11 \</span><br><span class="line">  -o test_glibc.out \</span><br><span class="line">  -v \</span><br><span class="line">  test_glibc.c \</span><br><span class="line">  -pthread \</span><br><span class="line">;</span><br><span class="line">ldd ./test_glibc.out</span><br><span class="line">./test_glibc.out</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统的Inode</title>
    <url>/2024/02/19/note/linux/inode/</url>
    <content><![CDATA[<h1 id="Inode-Iindex-Node"><a href="#Inode-Iindex-Node" class="headerlink" title="Inode (Iindex Node)"></a>Inode (Iindex Node)</h1><p>同一个文件系统内inode唯一。</p>
<h2 id="Inode上限"><a href="#Inode上限" class="headerlink" title="Inode上限"></a>Inode上限</h2><p>在文件系统创建时确定上限，一旦确定后，不能改了，因此要留意当前文件系统内inode数量。</p>
<h2 id="Inode结构"><a href="#Inode结构" class="headerlink" title="Inode结构"></a>Inode结构</h2><ul>
<li>File type</li>
<li>File size</li>
<li>Owner ID</li>
<li>Group ID</li>
<li>Read, write and execute permissions</li>
<li>Last access time</li>
<li>Last change time</li>
<li>Last modification time</li>
</ul>
<h2 id="有关命令"><a href="#有关命令" class="headerlink" title="有关命令"></a>有关命令</h2><blockquote>
<p>查看文件的inode号</p>
</blockquote>
<p>用 <code>stat</code> 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia cpp]<span class="comment"># stat demo.o </span></span><br><span class="line">  File: ‘demo.o’</span><br><span class="line">  Size: 138120          Blocks: 480        IO Block: 4096   regular file</span><br><span class="line">Device: 2h/2d   Inode: 2814749768200812  Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2024-02-06 11:27:22.232719400 +0800</span><br><span class="line">Modify: 2024-02-06 10:22:58.208382800 +0800</span><br><span class="line">Change: 2024-02-06 10:22:58.208382800 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>

<p>也可以用 <code>ls -i</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia cpp]<span class="comment"># ll -i</span></span><br><span class="line">total 4172</span><br><span class="line">200410183418259079 -rwxr-xr-x 1 root root     300 Feb  6 11:44 build.sh  </span><br><span class="line">  2814749768200812 -rw-r--r-- 1 root root  138120 Feb  6 10:22 demo.o    </span><br><span class="line"> 20829148276678876 -rw-r--r-- 1 root root      27 Feb  6 11:45 lib.cpp   </span><br><span class="line">  6755399442050607 -rw-r--r-- 1 root root    2576 Feb  6 11:46 lib.o     </span><br><span class="line">186617909559210440 -rw-r--r-- 1 root root    8585 Feb  6 11:46 lib.o.s   </span><br><span class="line"> 14355223812957764 -rw-r--r-- 1 root root     129 Feb  6 11:46 main.cpp  </span><br><span class="line">  3096224744960750 -rwxr-xr-x 1 root root   94744 Feb  6 11:46 main.exe  </span><br><span class="line"> 49539595902153707 -rw-r--r-- 1 root root 1865435 Feb  6 11:46 main.exe.s</span><br><span class="line"> 12947848928836777 -rw-r--r-- 1 root root  138448 Feb  6 11:46 main.o    </span><br><span class="line">247697979505656983 -rw-r--r-- 1 root root 1896009 Feb  6 11:46 main.o.s  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看文件夹inode号</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia cpp]<span class="comment"># ls -id .</span></span><br><span class="line">19140298416923551 .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有文件系统的inode数量</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia cpp]<span class="comment"># df -i</span></span><br><span class="line">Filesystem     Inodes   IUsed   IFree IUse% Mounted on</span><br><span class="line">rootfs            999 -999001 1000000     - /</span><br><span class="line">none              999 -999001 1000000     - /dev</span><br><span class="line">none              999 -999001 1000000     - /run</span><br><span class="line">none              999 -999001 1000000     - /run/lock</span><br><span class="line">none              999 -999001 1000000     - /run/shm</span><br><span class="line">none              999 -999001 1000000     - /run/user</span><br><span class="line">tmpfs             999 -999001 1000000     - /sys/fs/cgroup</span><br><span class="line">C:\               999 -999001 1000000     - /mnt/c</span><br><span class="line">D:\               999 -999001 1000000     - /mnt/d</span><br><span class="line">E:\               999 -999001 1000000     - /mnt/e</span><br><span class="line">F:\               999 -999001 1000000     - /mnt/f</span><br><span class="line">H:\               999 -999001 1000000     - /mnt/h</span><br></pre></td></tr></table></figure>

<h2 id="inode-复用问题"><a href="#inode-复用问题" class="headerlink" title="inode 复用问题"></a>inode 复用问题</h2><p>TLDF：跟文件系统相关，有的复用，有的不会。</p>
<p>删除文件后，新建个同名文件(内容即使与删除的不一样)，会复用原来的inode号，在xfs文件系统中复现。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 logs]$ ll -i file </span><br><span class="line">319997802 -rw-rw-r-- 1 game game 0 Feb  6 17:20 file</span><br><span class="line">[game@vm10-245-65-72 logs]$ <span class="built_in">rm</span> -f file &amp;&amp; <span class="built_in">touch</span> file &amp;&amp; ll -i file</span><br><span class="line">319997802 -rw-rw-r-- 1 game game 0 Feb  6 17:20 file</span><br><span class="line">[game@vm10-245-65-72 logs]$ <span class="built_in">rm</span> -f file &amp;&amp; <span class="built_in">touch</span> file &amp;&amp; ll -i file</span><br><span class="line">319997802 -rw-rw-r-- 1 game game 0 Feb  6 17:20 file</span><br><span class="line"></span><br><span class="line">[game@vm10-245-65-72 logs]$ <span class="built_in">df</span> -T .</span><br><span class="line">Filesystem     Type 1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/vdb       xfs  524032000 422586164 101445836  81% /export</span><br></pre></td></tr></table></figure>

<p>但在wsl1中无法复现，文件系统为 wslfs</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">94575592174828964 -rw-r--r-- 1 root root 0 Feb  6 17:19 file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm -f file &amp;&amp; touch file &amp;&amp; ll -i file</span></span><br><span class="line">94857067151539620 -rw-r--r-- 1 root root 0 Feb  6 17:23 file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm -f file &amp;&amp; touch file &amp;&amp; ll -i file</span></span><br><span class="line">95138542128250276 -rw-r--r-- 1 root root 0 Feb  6 17:23 file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm -f file &amp;&amp; touch file &amp;&amp; ll -i file</span></span><br><span class="line">95420017104960932 -rw-r--r-- 1 root root 0 Feb  6 17:23 file</span><br><span class="line"></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># df -T .</span></span><br><span class="line">Filesystem     Type  1K-blocks      Used Available Use% Mounted on</span><br><span class="line">rootfs         wslfs 487945212 405172080  82773132  84% /</span><br></pre></td></tr></table></figure>

<p><a href="https://stackoverflow.com/a/51019769/11850070">ext4也复用</a></p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux ld</title>
    <url>/2024/02/19/note/linux/ld/</url>
    <content><![CDATA[<p><a href="https://sourceware.org/binutils/docs/ld/index.html">LD用户手册</a></p>
<h1 id="Linker-Script"><a href="#Linker-Script" class="headerlink" title="Linker Script"></a>Linker Script</h1><p>主要作用是描述源目标文件的section怎么在最终生成的文件中排布。</p>
<p>linker script是必需的，如果没指明，则用默认的。</p>
<p>怎么查看默认的linker script？<br>文档中说用 <code>ld --verbose</code>，但ubuntu-20.04 wsl执行后报错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ld --verbose</span><br><span class="line">ld: fatal error: no input files</span><br></pre></td></tr></table></figure>

<p>用GDB跟下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="built_in">gldelf_x86_64_get_script</span> (isfile=<span class="number">0x7fffffffdfb4</span>) at eelf_x86_64.c:<span class="number">158</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000555555589ec9</span> <span class="function">in <span class="title">main</span> <span class="params">(argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;)</span> at ./ldmain.c:<span class="number">402</span></span></span><br></pre></td></tr></table></figure>

<p>发现linker script是由 <code>ld/genscripts.sh</code> 生成，截取<code>genscripts.sh</code>中的片段如下（针对某个cpu架构，有多个链接脚本可选，根据链接器所传参数使用对应的链接脚本。这里只关注链接可执行文件时用到的x后缀脚本，即 <code>elf_x86_64.x</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DATA_ALIGNMENT=<span class="variable">$&#123;DATA_ALIGNMENT_&#125;</span></span><br><span class="line">RELOCATING=<span class="string">&quot; &quot;</span></span><br><span class="line">LD_FLAG=</span><br><span class="line">( <span class="built_in">echo</span> <span class="string">&quot;/* Default linker script, for normal executables */&quot;</span></span><br><span class="line">  source_sh <span class="variable">$&#123;CUSTOMIZER_SCRIPT&#125;</span></span><br><span class="line">  source_sh <span class="variable">$&#123;srcdir&#125;</span>/scripttempl/<span class="variable">$&#123;SCRIPT_NAME&#125;</span>.sc</span><br><span class="line">) | sed -e <span class="string">&#x27;/^ *$/d;s/[	 ]*$//&#x27;</span> &gt; ldscripts/<span class="variable">$&#123;EMULATION_NAME&#125;</span>.x</span><br><span class="line"></span><br><span class="line">LD_FLAG=textonly</span><br><span class="line">( <span class="built_in">echo</span> <span class="string">&quot;/* Script for -z separate-code */&quot;</span></span><br><span class="line">  source_sh <span class="variable">$&#123;CUSTOMIZER_SCRIPT&#125;</span></span><br><span class="line">  source_sh <span class="variable">$&#123;srcdir&#125;</span>/scripttempl/<span class="variable">$&#123;SCRIPT_NAME&#125;</span>.sc</span><br><span class="line">) | sed -e <span class="string">&#x27;/^ *$/d;s/[	 ]*$//&#x27;</span> &gt; ldscripts/<span class="variable">$&#123;EMULATION_NAME&#125;</span>.xe</span><br></pre></td></tr></table></figure>

<p>在 Ubuntu-20.04 中，这些linker scripts放在 <code>/lib/x86_64-linux-gnu/ldscripts/</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ll /lib/x86_64-linux-gnu/ldscripts/elf_x86_64.x</span><br><span class="line">elf_x86_64.x     elf_x86_64.xce   elf_x86_64.xdce  elf_x86_64.xdwe  elf_x86_64.xr    elf_x86_64.xsce  elf_x86_64.xswe  elf_x86_64.xwe   </span><br><span class="line">elf_x86_64.xbn   elf_x86_64.xd    elf_x86_64.xde   elf_x86_64.xe    elf_x86_64.xs    elf_x86_64.xse   elf_x86_64.xu    </span><br><span class="line">elf_x86_64.xc    elf_x86_64.xdc   elf_x86_64.xdw   elf_x86_64.xn    elf_x86_64.xsc   elf_x86_64.xsw   elf_x86_64.xw  </span><br></pre></td></tr></table></figure>

<p>当前ld版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld --version</span><br><span class="line">GNU gold (GNU Binutils <span class="keyword">for</span> Ubuntu 2.34) 1.16</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This program is free software; you may redistribute it under the terms of</span><br><span class="line">the GNU General Public License version 3 or (at your option) a later version.</span><br><span class="line">This program has absolutely no warranty.</span><br></pre></td></tr></table></figure>

<p>可执行文件默认的链接脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Default linker script, for normal executables */</span><br><span class="line">/* Copyright (C) 2014-2020 Free Software Foundation, Inc.</span><br><span class="line">   Copying and distribution of this script, with or without modification,</span><br><span class="line">   are permitted in any medium without royalty provided the copyright</span><br><span class="line">   notice and this notice are preserved.  */</span><br><span class="line">OUTPUT_FORMAT(&quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;,</span><br><span class="line">	      &quot;elf64-x86-64&quot;)</span><br><span class="line">OUTPUT_ARCH(i386:x86-64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SEARCH_DIR(&quot;=/usr/local/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu&quot;); SEARCH_DIR(&quot;=/usr/lib/x86_64-linux-gnu64&quot;); SEARCH_DIR(&quot;=/usr/local/lib64&quot;); SEARCH_DIR(&quot;=/lib64&quot;); SEARCH_DIR(&quot;=/usr/lib64&quot;); SEARCH_DIR(&quot;=/usr/local/lib&quot;); SEARCH_DIR(&quot;=/lib&quot;); SEARCH_DIR(&quot;=/usr/lib&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib64&quot;); SEARCH_DIR(&quot;=/usr/x86_64-linux-gnu/lib&quot;);</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /* Read-only sections, merged into text segment: */</span><br><span class="line">  PROVIDE (__executable_start = SEGMENT_START(&quot;text-segment&quot;, 0x400000)); . = SEGMENT_START(&quot;text-segment&quot;, 0x400000) + SIZEOF_HEADERS;</span><br><span class="line">  .interp         : &#123; *(.interp) &#125;</span><br><span class="line">  .note.gnu.build-id  : &#123; *(.note.gnu.build-id) &#125;</span><br><span class="line">  .hash           : &#123; *(.hash) &#125;</span><br><span class="line">  .gnu.hash       : &#123; *(.gnu.hash) &#125;</span><br><span class="line">  .dynsym         : &#123; *(.dynsym) &#125;</span><br><span class="line">  .dynstr         : &#123; *(.dynstr) &#125;</span><br><span class="line">  .gnu.version    : &#123; *(.gnu.version) &#125;</span><br><span class="line">  .gnu.version_d  : &#123; *(.gnu.version_d) &#125;</span><br><span class="line">  .gnu.version_r  : &#123; *(.gnu.version_r) &#125;</span><br><span class="line">  .rela.init      : &#123; *(.rela.init) &#125;</span><br><span class="line">  .rela.text      : &#123; *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*) &#125;</span><br><span class="line">  .rela.fini      : &#123; *(.rela.fini) &#125;</span><br><span class="line">  .rela.rodata    : &#123; *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*) &#125;</span><br><span class="line">  .rela.data.rel.ro   : &#123; *(.rela.data.rel.ro .rela.data.rel.ro.* .rela.gnu.linkonce.d.rel.ro.*) &#125;</span><br><span class="line">  .rela.data      : &#123; *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*) &#125;</span><br><span class="line">  .rela.tdata	  : &#123; *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*) &#125;</span><br><span class="line">  .rela.tbss	  : &#123; *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*) &#125;</span><br><span class="line">  .rela.ctors     : &#123; *(.rela.ctors) &#125;</span><br><span class="line">  .rela.dtors     : &#123; *(.rela.dtors) &#125;</span><br><span class="line">  .rela.got       : &#123; *(.rela.got) &#125;</span><br><span class="line">  .rela.bss       : &#123; *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*) &#125;</span><br><span class="line">  .rela.ldata     : &#123; *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.*) &#125;</span><br><span class="line">  .rela.lbss      : &#123; *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.*) &#125;</span><br><span class="line">  .rela.lrodata   : &#123; *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.*) &#125;</span><br><span class="line">  .rela.ifunc     : &#123; *(.rela.ifunc) &#125;</span><br><span class="line">  .rela.plt       :</span><br><span class="line">    &#123;</span><br><span class="line">      *(.rela.plt)</span><br><span class="line">      PROVIDE_HIDDEN (__rela_iplt_start = .);</span><br><span class="line">      *(.rela.iplt)</span><br><span class="line">      PROVIDE_HIDDEN (__rela_iplt_end = .);</span><br><span class="line">    &#125;</span><br><span class="line">  .init           :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP (*(SORT_NONE(.init)))</span><br><span class="line">  &#125;</span><br><span class="line">  .plt            : &#123; *(.plt) *(.iplt) &#125;</span><br><span class="line">.plt.got        : &#123; *(.plt.got) &#125;</span><br><span class="line">.plt.sec        : &#123; *(.plt.sec) &#125;</span><br><span class="line">  .text           :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.text.unlikely .text.*_unlikely .text.unlikely.*)</span><br><span class="line">    *(.text.exit .text.exit.*)</span><br><span class="line">    *(.text.startup .text.startup.*)</span><br><span class="line">    *(.text.hot .text.hot.*)</span><br><span class="line">    *(SORT(.text.sorted.*))</span><br><span class="line">    *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">    /* .gnu.warning sections are handled specially by elf.em.  */</span><br><span class="line">    *(.gnu.warning)</span><br><span class="line">  &#125;</span><br><span class="line">  .fini           :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP (*(SORT_NONE(.fini)))</span><br><span class="line">  &#125;</span><br><span class="line">  PROVIDE (__etext = .);</span><br><span class="line">  PROVIDE (_etext = .);</span><br><span class="line">  PROVIDE (etext = .);</span><br><span class="line">  .rodata         : &#123; *(.rodata .rodata.* .gnu.linkonce.r.*) &#125;</span><br><span class="line">  .rodata1        : &#123; *(.rodata1) &#125;</span><br><span class="line">  .eh_frame_hdr   : &#123; *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) &#125;</span><br><span class="line">  .eh_frame       : ONLY_IF_RO &#123; KEEP (*(.eh_frame)) *(.eh_frame.*) &#125;</span><br><span class="line">  .gcc_except_table   : ONLY_IF_RO &#123; *(.gcc_except_table .gcc_except_table.*) &#125;</span><br><span class="line">  .gnu_extab   : ONLY_IF_RO &#123; *(.gnu_extab*) &#125;</span><br><span class="line">  /* These sections are generated by the Sun/Oracle C++ compiler.  */</span><br><span class="line">  .exception_ranges   : ONLY_IF_RO &#123; *(.exception_ranges*) &#125;</span><br><span class="line">  /* Adjust the address for the data segment.  We want to adjust up to</span><br><span class="line">     the same address within the page on the next page up.  */</span><br><span class="line">  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));</span><br><span class="line">  /* Exception handling  */</span><br><span class="line">  .eh_frame       : ONLY_IF_RW &#123; KEEP (*(.eh_frame)) *(.eh_frame.*) &#125;</span><br><span class="line">  .gnu_extab      : ONLY_IF_RW &#123; *(.gnu_extab) &#125;</span><br><span class="line">  .gcc_except_table   : ONLY_IF_RW &#123; *(.gcc_except_table .gcc_except_table.*) &#125;</span><br><span class="line">  .exception_ranges   : ONLY_IF_RW &#123; *(.exception_ranges*) &#125;</span><br><span class="line">  /* Thread Local Storage sections  */</span><br><span class="line">  .tdata	  :</span><br><span class="line">   &#123;</span><br><span class="line">     PROVIDE_HIDDEN (__tdata_start = .);</span><br><span class="line">     *(.tdata .tdata.* .gnu.linkonce.td.*)</span><br><span class="line">   &#125;</span><br><span class="line">  .tbss		  : &#123; *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) &#125;</span><br><span class="line">  .preinit_array    :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_start = .);</span><br><span class="line">    KEEP (*(.preinit_array))</span><br><span class="line">    PROVIDE_HIDDEN (__preinit_array_end = .);</span><br><span class="line">  &#125;</span><br><span class="line">  .init_array    :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_start = .);</span><br><span class="line">    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))</span><br><span class="line">    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))</span><br><span class="line">    PROVIDE_HIDDEN (__init_array_end = .);</span><br><span class="line">  &#125;</span><br><span class="line">  .fini_array    :</span><br><span class="line">  &#123;</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_start = .);</span><br><span class="line">    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))</span><br><span class="line">    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))</span><br><span class="line">    PROVIDE_HIDDEN (__fini_array_end = .);</span><br><span class="line">  &#125;</span><br><span class="line">  .ctors          :</span><br><span class="line">  &#123;</span><br><span class="line">    /* gcc uses crtbegin.o to find the start of</span><br><span class="line">       the constructors, so we make sure it is</span><br><span class="line">       first.  Because this is a wildcard, it</span><br><span class="line">       doesn&#x27;t matter if the user does not</span><br><span class="line">       actually link against crtbegin.o; the</span><br><span class="line">       linker won&#x27;t look for a file to match a</span><br><span class="line">       wildcard.  The wildcard also means that it</span><br><span class="line">       doesn&#x27;t matter which directory crtbegin.o</span><br><span class="line">       is in.  */</span><br><span class="line">    KEEP (*crtbegin.o(.ctors))</span><br><span class="line">    KEEP (*crtbegin?.o(.ctors))</span><br><span class="line">    /* We don&#x27;t want to include the .ctor section from</span><br><span class="line">       the crtend.o file until after the sorted ctors.</span><br><span class="line">       The .ctor section from the crtend file contains the</span><br><span class="line">       end of ctors marker and it must be last */</span><br><span class="line">    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))</span><br><span class="line">    KEEP (*(SORT(.ctors.*)))</span><br><span class="line">    KEEP (*(.ctors))</span><br><span class="line">  &#125;</span><br><span class="line">  .dtors          :</span><br><span class="line">  &#123;</span><br><span class="line">    KEEP (*crtbegin.o(.dtors))</span><br><span class="line">    KEEP (*crtbegin?.o(.dtors))</span><br><span class="line">    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))</span><br><span class="line">    KEEP (*(SORT(.dtors.*)))</span><br><span class="line">    KEEP (*(.dtors))</span><br><span class="line">  &#125;</span><br><span class="line">  .jcr            : &#123; KEEP (*(.jcr)) &#125;</span><br><span class="line">  .data.rel.ro : &#123; *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*) &#125;</span><br><span class="line">  .dynamic        : &#123; *(.dynamic) &#125;</span><br><span class="line">  .got            : &#123; *(.got) *(.igot) &#125;</span><br><span class="line">  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) &gt;= 24 ? 24 : 0, .);</span><br><span class="line">  .got.plt        : &#123; *(.got.plt) *(.igot.plt) &#125;</span><br><span class="line">  .data           :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.data .data.* .gnu.linkonce.d.*)</span><br><span class="line">    SORT(CONSTRUCTORS)</span><br><span class="line">  &#125;</span><br><span class="line">  .data1          : &#123; *(.data1) &#125;</span><br><span class="line">  _edata = .; PROVIDE (edata = .);</span><br><span class="line">  . = .;</span><br><span class="line">  __bss_start = .;</span><br><span class="line">  .bss            :</span><br><span class="line">  &#123;</span><br><span class="line">   *(.dynbss)</span><br><span class="line">   *(.bss .bss.* .gnu.linkonce.b.*)</span><br><span class="line">   *(COMMON)</span><br><span class="line">   /* Align here to ensure that the .bss section occupies space up to</span><br><span class="line">      _end.  Align after .bss to ensure correct alignment even if the</span><br><span class="line">      .bss section disappears because there are no input sections.</span><br><span class="line">      FIXME: Why do we need it? When there is no .bss section, we do not</span><br><span class="line">      pad the .data section.  */</span><br><span class="line">   . = ALIGN(. != 0 ? 64 / 8 : 1);</span><br><span class="line">  &#125;</span><br><span class="line">  .lbss   :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.dynlbss)</span><br><span class="line">    *(.lbss .lbss.* .gnu.linkonce.lb.*)</span><br><span class="line">    *(LARGE_COMMON)</span><br><span class="line">  &#125;</span><br><span class="line">  . = ALIGN(64 / 8);</span><br><span class="line">  . = SEGMENT_START(&quot;ldata-segment&quot;, .);</span><br><span class="line">  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.lrodata .lrodata.* .gnu.linkonce.lr.*)</span><br><span class="line">  &#125;</span><br><span class="line">  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. &amp; (CONSTANT (MAXPAGESIZE) - 1)) :</span><br><span class="line">  &#123;</span><br><span class="line">    *(.ldata .ldata.* .gnu.linkonce.l.*)</span><br><span class="line">    . = ALIGN(. != 0 ? 64 / 8 : 1);</span><br><span class="line">  &#125;</span><br><span class="line">  . = ALIGN(64 / 8);</span><br><span class="line">  _end = .; PROVIDE (end = .);</span><br><span class="line">  . = DATA_SEGMENT_END (.);</span><br><span class="line">  /* Stabs debugging sections.  */</span><br><span class="line">  .stab          0 : &#123; *(.stab) &#125;</span><br><span class="line">  .stabstr       0 : &#123; *(.stabstr) &#125;</span><br><span class="line">  .stab.excl     0 : &#123; *(.stab.excl) &#125;</span><br><span class="line">  .stab.exclstr  0 : &#123; *(.stab.exclstr) &#125;</span><br><span class="line">  .stab.index    0 : &#123; *(.stab.index) &#125;</span><br><span class="line">  .stab.indexstr 0 : &#123; *(.stab.indexstr) &#125;</span><br><span class="line">  .comment       0 : &#123; *(.comment) &#125;</span><br><span class="line">  .gnu.build.attributes : &#123; *(.gnu.build.attributes .gnu.build.attributes.*) &#125;</span><br><span class="line">  /* DWARF debug sections.</span><br><span class="line">     Symbols in the DWARF debugging sections are relative to the beginning</span><br><span class="line">     of the section so we begin them at 0.  */</span><br><span class="line">  /* DWARF 1 */</span><br><span class="line">  .debug          0 : &#123; *(.debug) &#125;</span><br><span class="line">  .line           0 : &#123; *(.line) &#125;</span><br><span class="line">  /* GNU DWARF 1 extensions */</span><br><span class="line">  .debug_srcinfo  0 : &#123; *(.debug_srcinfo) &#125;</span><br><span class="line">  .debug_sfnames  0 : &#123; *(.debug_sfnames) &#125;</span><br><span class="line">  /* DWARF 1.1 and DWARF 2 */</span><br><span class="line">  .debug_aranges  0 : &#123; *(.debug_aranges) &#125;</span><br><span class="line">  .debug_pubnames 0 : &#123; *(.debug_pubnames) &#125;</span><br><span class="line">  /* DWARF 2 */</span><br><span class="line">  .debug_info     0 : &#123; *(.debug_info .gnu.linkonce.wi.*) &#125;</span><br><span class="line">  .debug_abbrev   0 : &#123; *(.debug_abbrev) &#125;</span><br><span class="line">  .debug_line     0 : &#123; *(.debug_line .debug_line.* .debug_line_end) &#125;</span><br><span class="line">  .debug_frame    0 : &#123; *(.debug_frame) &#125;</span><br><span class="line">  .debug_str      0 : &#123; *(.debug_str) &#125;</span><br><span class="line">  .debug_loc      0 : &#123; *(.debug_loc) &#125;</span><br><span class="line">  .debug_macinfo  0 : &#123; *(.debug_macinfo) &#125;</span><br><span class="line">  /* SGI/MIPS DWARF 2 extensions */</span><br><span class="line">  .debug_weaknames 0 : &#123; *(.debug_weaknames) &#125;</span><br><span class="line">  .debug_funcnames 0 : &#123; *(.debug_funcnames) &#125;</span><br><span class="line">  .debug_typenames 0 : &#123; *(.debug_typenames) &#125;</span><br><span class="line">  .debug_varnames  0 : &#123; *(.debug_varnames) &#125;</span><br><span class="line">  /* DWARF 3 */</span><br><span class="line">  .debug_pubtypes 0 : &#123; *(.debug_pubtypes) &#125;</span><br><span class="line">  .debug_ranges   0 : &#123; *(.debug_ranges) &#125;</span><br><span class="line">  /* DWARF Extension.  */</span><br><span class="line">  .debug_macro    0 : &#123; *(.debug_macro) &#125;</span><br><span class="line">  .debug_addr     0 : &#123; *(.debug_addr) &#125;</span><br><span class="line">  .gnu.attributes 0 : &#123; KEEP (*(.gnu.attributes)) &#125;</span><br><span class="line">  /DISCARD/ : &#123; *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Relocation-重定向"><a href="#Relocation-重定向" class="headerlink" title="Relocation 重定向"></a>Relocation 重定向</h1><blockquote>
<p>A relocation is an action which the linker must take when linking.</p>
</blockquote>
<h2 id="静态重定向"><a href="#静态重定向" class="headerlink" title="静态重定向"></a>静态重定向</h2><h2 id="动态重定向"><a href="#动态重定向" class="headerlink" title="动态重定向"></a>动态重定向</h2><p>运行时由动态链接器(ld.so)修改符号的值，用gdb可观察该行为。</p>
<p>gdb抓取动态重定向调用栈，详见：<a href="https://stackoverflow.com/a/69490442/11850070">https://stackoverflow.com/a/69490442/11850070</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x00007ffff7fe01e0</span> in _dl_fixup (l=&lt;optimized out&gt;, reloc_arg=&lt;optimized out&gt;) at ../sysdeps/x86_64/dl-machine.h:<span class="number">242</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00007ffff7fe7c3e</span> in _dl_runtime_resolve_xsavec () at ../sysdeps/x86_64/dl-trampoline.h:<span class="number">126</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000004005a2</span> in <span class="title function_">main</span> <span class="params">()</span> at t.c:5</span><br></pre></td></tr></table></figure>

<p>符号 <code>_dl_fixup</code> 在 ld.so 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:~/glibc/build/install/lib$ nm ld-2.32.so | grep _dl_fixup</span><br><span class="line">000000000000f970 t _dl_fixup</span><br></pre></td></tr></table></figure>

<p>一个 <code>link_map</code> 对应一个so？</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux防火墙配置</title>
    <url>/2024/02/19/note/linux/linux%20firewall/</url>
    <content><![CDATA[<h1 id="linux-firewall"><a href="#linux-firewall" class="headerlink" title="linux firewall"></a>linux firewall</h1><p>To view open ports, use the following command.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>We use the following to see services whose ports are open.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-services</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>We use the following to see services whose ports are open and see open ports</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>To add a service to the firewall, we use the following command, in which case the service will use any port to open in the firewall.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-services=ntp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>For this service to be permanently open we use the following command.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd —add-service=ntp --permanent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>To add a port, use the following command</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-port=132/tcp  --permanent</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>To run the firewall must be reloaded using the following command.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux tee cmd</title>
    <url>/2024/02/19/note/linux/linux%20tee%20cmd/</url>
    <content><![CDATA[<h1 id="linux-tee-cmd"><a href="#linux-tee-cmd" class="headerlink" title="linux tee cmd"></a>linux tee cmd</h1><p>tee 是 字母T的发音，将 | 左边的stdin 同时分流到 stdout 和 file 一份。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wqj@ubuntu-server:~/demo$ echo <span class="string">&quot;hello&quot;</span> | tee demo.txt</span><br><span class="line">hello</span><br><span class="line">wqj@ubuntu-server:~/demo$ cat demo.txt </span><br><span class="line">hello</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux nm</title>
    <url>/2024/02/19/note/linux/nm/</url>
    <content><![CDATA[<h1 id="nm的使用"><a href="#nm的使用" class="headerlink" title="nm的使用"></a>nm的使用</h1><h2 id="按地址升序打印并demangle"><a href="#按地址升序打印并demangle" class="headerlink" title="按地址升序打印并demangle"></a>按地址升序打印并demangle</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-C demangle symbols</span><br><span class="line">-n 按地址升序</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nm -n -C demo</span><br><span class="line">                 U __cxa_atexit@@GLIBC_2.2.5</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">                 U std::ios_base::Init::Init()@@GLIBCXX_3.4</span><br><span class="line">0000000000400708 T _init</span><br><span class="line">00000000004007c0 T _start</span><br><span class="line">...</span><br><span class="line">0000000000601171 b std::__ioinit</span><br><span class="line">0000000000601178 B _end</span><br></pre></td></tr></table></figure>

<h2 id="分析C-vtable内容"><a href="#分析C-vtable内容" class="headerlink" title="分析C++ vtable内容"></a>分析C++ vtable内容</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;C::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先用objdump取出vtable内若干符号的地址，然后用nm找出地址对应的符号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -C demangle</span></span><br><span class="line"><span class="comment"># -d disassemble</span></span><br><span class="line">[root@ZLPC-wangqingjia demo]<span class="comment"># objdump -C -d --section=.rodata demo</span></span><br><span class="line"></span><br><span class="line">demo:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">00000000004009b0 &lt;_IO_stdin_used&gt;:</span><br><span class="line">  4009b0:       01 00 02 00 00 00 00 00                             ........        </span><br><span class="line"></span><br><span class="line">00000000004009b8 &lt;__dso_handle&gt;:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">00000000004009c0 &lt;std::piecewise_construct&gt;:</span><br><span class="line">  4009c0:       00 43 3a 3a 66 6f 6f 00                             .C::foo.        </span><br><span class="line"></span><br><span class="line">00000000004009c8 &lt;vtable <span class="keyword">for</span> C&gt;:</span><br><span class="line">        ...</span><br><span class="line">  4009d0:       e0 09 40 00 00 00 00 00 fa 08 40 00 00 00 00 00     ..@.......@.....</span><br><span class="line"></span><br><span class="line">00000000004009e0 &lt;typeinfo <span class="keyword">for</span> C&gt;:</span><br><span class="line">  4009e0:       b0 0d 60 00 00 00 00 00 f8 09 40 00 00 00 00 00     ..`.......@.....</span><br><span class="line">  4009f0:       00 0a 40 00 00 00 00 00                             ..@.....        </span><br><span class="line"></span><br><span class="line">00000000004009f8 &lt;typeinfo name <span class="keyword">for</span> C&gt;:</span><br><span class="line">  4009f8:       31 43 00 00 00 00 00 00                             1C......        </span><br><span class="line"></span><br><span class="line">0000000000400a00 &lt;typeinfo <span class="keyword">for</span> B&gt;:</span><br><span class="line">  400a00:       b0 0d 60 00 00 00 00 00 18 0a 40 00 00 00 00 00     ..`.......@.....</span><br><span class="line">  400a10:       20 0a 40 00 00 00 00 00                              .@.....        </span><br><span class="line"></span><br><span class="line">0000000000400a18 &lt;typeinfo name <span class="keyword">for</span> B&gt;:</span><br><span class="line">  400a18:       31 42 00 00 00 00 00 00                             1B......        </span><br><span class="line"></span><br><span class="line">0000000000400a20 &lt;typeinfo <span class="keyword">for</span> A&gt;:</span><br><span class="line">  400a20:       50 0d 60 00 00 00 00 00 30 0a 40 00 00 00 00 00     P.`.....0.@.....</span><br><span class="line"></span><br><span class="line">0000000000400a30 &lt;typeinfo name <span class="keyword">for</span> A&gt;:</span><br><span class="line">  400a30:       31 41 00                                            1A.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小端存储，数值低位在低地址</span></span><br><span class="line">[root@ZLPC-wangqingjia demo]<span class="comment"># nm -n -C demo | grep 4009e0</span></span><br><span class="line">00000000004009e0 V typeinfo <span class="keyword">for</span> C</span><br><span class="line">[root@ZLPC-wangqingjia demo]<span class="comment"># nm -n -C demo | grep 4008fa</span></span><br><span class="line">00000000004008fa W C::foo()</span><br></pre></td></tr></table></figure>

<p>而用 g++ -S 生成的反汇编为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vtable for C:</span><br><span class="line">	.quad	0</span><br><span class="line">	.quad	typeinfo for C</span><br><span class="line">	.quad	C::foo()</span><br><span class="line">	.weak	typeinfo for C</span><br><span class="line">	.section	.rodata._ZTI1C,&quot;aG&quot;,@progbits,typeinfo for C,comdat</span><br><span class="line">	.align 8</span><br><span class="line">	.type	typeinfo for C, @object</span><br><span class="line">	.size	typeinfo for C, 24</span><br></pre></td></tr></table></figure>

<p>每一列代表什么意思？</p>
<ul>
<li>符号值，即地址</li>
<li>符号类型, 一般小写是local，大写是global(external), 例外是：”u”,”v”,”w” 这三个小写的是global的。<ul>
<li>A - The symbol’s value is absolute, and will not be changed by further linking.</li>
<li>B&#x2F;b - The symbol is in the uninitialized data section (known as BSS).</li>
<li>C - The symbol is common.  Common symbols are uninitialized data.  When linking, multiple common symbols may appear with the same name.  If the symbol is defined anywhere, the common symbols are treated as undefined references. (没理解)</li>
<li>D&#x2F;d - The symbol is in the initialized data section.</li>
<li>G&#x2F;g - The symbol is in an initialized data section for small objects.  Some object file formats permit more efficient access to small data objects, such as a global int variable as opposed to a large global array.</li>
<li>I - The symbol is an indirect reference to another symbol.</li>
<li>i - For ELF format files this indicates that the symbol is an indirect function.  This is a GNU extension to the standard set of ELF symbol types.  It indicates a symbol which if referenced by a relocation does not evaluate to its address, but instead must be invoked at runtime. The runtime execution will then return the value to be used in the relocation.</li>
<li>N - The symbol is a debugging symbol.</li>
<li>p - The symbols is in a stack unwind section. (没理解)</li>
<li>R&#x2F;r - The symbol is in a read only data section.</li>
<li>S&#x2F;s - The symbol is in an uninitialized data section for small objects.</li>
<li>T&#x2F;t - The symbol is in the text (code) section.</li>
<li>U - The symbol is undefined.</li>
<li>u - The symbol is a unique global symbol.  This is a GNU extension to the standard set of ELF symbol bindings.  For such a symbol the dynamic linker will make sure that in the entire process there is just one symbol with this name and type in use.</li>
<li>V&#x2F;v - The symbol is a weak object.  When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the weak symbol becomes zero with no error.  On some systems, uppercase indicates that a default value has been specified.</li>
<li>W&#x2F;w - The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</li>
<li>‘-‘ - The symbol is a stabs symbol in an a.out object file.  In this case, the next values printed are the stabs other field, the stabs desc field, and the stab type.  Stabs symbols are used to hold debugging information.</li>
<li>‘?’ - The symbol type is unknown, or object file format specific.</li>
</ul>
</li>
<li>符号名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]# nm a.out -C | grep &quot;std::_Sp_counted_base&quot;</span><br><span class="line">0000000000400e40 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_destroy()</span><br><span class="line">0000000000400d48 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_release()</span><br><span class="line">0000000000400dc4 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_add_ref_copy()</span><br><span class="line">0000000000401370 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_Sp_counted_base()</span><br><span class="line">0000000000401370 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_Sp_counted_base()</span><br><span class="line">0000000000400eee W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_base()</span><br><span class="line">0000000000400ed6 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_base()</span><br><span class="line">0000000000400ed6 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_base()</span><br><span class="line">00000000004018a8 V typeinfo for std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">00000000004018c0 V typeinfo name for std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">00000000004017f8 V vtable for std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br></pre></td></tr></table></figure>


<h1 id="nm原理"><a href="#nm原理" class="headerlink" title="nm原理"></a>nm原理</h1><p>我很好奇 <code>nm</code> 怎么从elf目标文件中获取的符号信息。</p>
<p>用GDB跟一下，其实是调用 BFD 接口获取符号表。</p>
<blockquote>
<p>The first use is to read an object file. The object file readers are programs like ‘gdb’, ‘nm’, ‘objdump’, and ‘objcopy’. These programs use BFD to view an object file in a generic form. The official BFD interface is normally fully adequate for these programs. - bfd&#x2F;doc&#x2F;bfdint.texi</p>
</blockquote>
<p>gas、ld、nm、objdump、objcopy 这些工具，均借助BFD读写二进制目标文件。</p>
<p>所以要看BFD怎么从elf目标文件中获取符号表。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux objdump</title>
    <url>/2024/02/19/note/linux/objdump/</url>
    <content><![CDATA[<h1 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h1><p><a href="https://man7.org/linux/man-pages/man1/objdump.1.html">https://man7.org/linux/man-pages/man1/objdump.1.html</a></p>
<h1 id="disassemble-all-sections-of-an-exe"><a href="#disassemble-all-sections-of-an-exe" class="headerlink" title="disassemble all sections of an exe"></a>disassemble all sections of an exe</h1><p>问题：.rodata等数据段也被解释成指令了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objdump -C -S -D demo &gt; demo.exe.s</span><br><span class="line"></span><br><span class="line">-C demangle</span><br><span class="line">-S 插入源码</span><br><span class="line">-D 反汇编所有段</span><br></pre></td></tr></table></figure>

<h1 id="Dump-all-symbols-Dump-symbol-table"><a href="#Dump-all-symbols-Dump-symbol-table" class="headerlink" title="Dump all symbols &#x2F; Dump symbol table"></a>Dump all symbols &#x2F; Dump symbol table</h1><p>-t 选项</p>
<p>Display the contents of the symbol table(s)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]<span class="meta"># objdump -C -t demo | grep vtable</span></span><br><span class="line"><span class="number">0000000000400</span>ac8  w    O .rodata        <span class="number">0000000000000018</span>              vtable <span class="keyword">for</span> A</span><br><span class="line"><span class="number">0000000000600</span>d40  w    O .data.rel.ro   <span class="number">0000000000000058</span>              vtable <span class="keyword">for</span> __cxxabiv1::__class_type_info@@CXXABI_1<span class="number">.3</span></span><br><span class="line"><span class="number">0000000000400</span>a98  w    O .rodata        <span class="number">0000000000000018</span>              vtable <span class="keyword">for</span> C</span><br><span class="line"><span class="number">0000000000600</span>da0  w    O .data.rel.ro   <span class="number">0000000000000058</span>              vtable <span class="keyword">for</span> __cxxabiv1::__si_class_type_info@@CXXABI_1<span class="number">.3</span></span><br><span class="line"><span class="number">0000000000400</span>ab0  w    O .rodata        <span class="number">0000000000000018</span>              vtable <span class="keyword">for</span> B</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>Address Column (e.g., <code>0000000000400238</code>):</strong></p>
<ul>
<li>This column shows the memory address where the symbol is located.</li>
</ul>
</li>
<li><p><strong>Scope Column (e.g., <code>l</code>):</strong></p>
<ul>
<li>The symbol is a local (l), global (g), unique global (u),<br> neither global nor local (a space) or both global and<br> local (!).</li>
</ul>
</li>
<li><p><strong>Section Type Column (e.g., <code>d</code>):</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;w&quot; The symbol is weak (w) or strong (a space).</span><br><span class="line">    </span><br><span class="line">&quot;C&quot; The symbol denotes a constructor (C) or an ordinary</span><br><span class="line">    symbol (a space).</span><br><span class="line">    </span><br><span class="line">&quot;W&quot; The symbol is a warning (W) or a normal symbol (a space).</span><br><span class="line">    A warning symbol&#x27;s name is a message to be displayed if</span><br><span class="line">    the symbol following the warning symbol is ever</span><br><span class="line">    referenced.</span><br><span class="line">    </span><br><span class="line">&quot;I&quot;</span><br><span class="line">&quot;i&quot; The symbol is an indirect reference to another symbol</span><br><span class="line">    (I), a function to be evaluated during reloc processing</span><br><span class="line">    (i) or a normal symbol (a space).</span><br><span class="line">    </span><br><span class="line">&quot;d&quot;</span><br><span class="line">&quot;D&quot; The symbol is a debugging symbol (d) or a dynamic symbol</span><br><span class="line">    (D) or a normal symbol (a space).</span><br><span class="line">    </span><br><span class="line">&quot;F&quot;</span><br><span class="line">&quot;f&quot;</span><br><span class="line">&quot;O&quot; The symbol is the name of a function (F) or a file (f) or</span><br><span class="line">    an object (O) or just a normal symbol (a space).</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Section Name Column (e.g., <code>.interp</code>):</strong></p>
<ul>
<li>This column shows the name of the section in which the symbol is defined.</li>
</ul>
</li>
<li><p><strong>Size Column (e.g., <code>0000000000000000</code>):</strong></p>
<ul>
<li>For common symbols is the alignment and for other symbol is<br> the size.</li>
<li>e.g. 对象</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400</span>ae0 &lt;typeinfo <span class="keyword">for</span> C&gt;:</span><br><span class="line">  <span class="number">400</span>ae0:       b0 <span class="number">0</span>d <span class="number">60</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> f8 <span class="number">0</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ..`.......@.....</span><br><span class="line">  <span class="number">400</span>af0:       <span class="number">00</span> <span class="number">0b</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                             ..@.....</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400</span>ae0  w    O .rodata	<span class="number">0000000000000018</span>              typeinfo <span class="keyword">for</span> C</span><br><span class="line"></span><br><span class="line"><span class="number">0x18</span> = <span class="number">16</span>+<span class="number">8</span> = <span class="number">24B</span></span><br></pre></td></tr></table></figure>
<ul>
<li>e.g. 函数</li>
</ul>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400968</span> &lt;A::<span class="built_in">foo</span>()&gt;:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="number">400968</span>:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">400969</span>:	<span class="number">48</span> <span class="number">89</span> e5             	mov    %rsp,%rbp</span><br><span class="line">  <span class="number">40096</span>c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">10</span>          	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">  <span class="number">400970</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">7</span>d f8          	mov    %rdi,<span class="number">-0x8</span>(%rbp)</span><br><span class="line">  <span class="number">400974</span>:	be b1 <span class="number">0</span>a <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x400ab1</span>,%esi</span><br><span class="line">  <span class="number">400979</span>:	bf <span class="number">60</span> <span class="number">20</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x602060</span>,%edi</span><br><span class="line">  <span class="number">40097</span>e:	e8 <span class="number">0</span>d fe ff ff       	callq  <span class="number">400790</span> &lt;std::basic_ostream&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt; &gt;&amp; std::<span class="keyword">operator</span>&lt;&lt; &lt;std::char_traits&lt;<span class="type">char</span>&gt; &gt;(std::basic_ostream&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt; &gt;&amp;, <span class="type">char</span> <span class="type">const</span>*)@plt&gt;</span><br><span class="line">  <span class="number">400983</span>:	be b0 <span class="number">07</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4007b0</span>,%esi</span><br><span class="line">  <span class="number">400988</span>:	<span class="number">48</span> <span class="number">89</span> c7             	mov    %rax,%rdi</span><br><span class="line">  <span class="number">40098b</span>:	e8 <span class="number">10</span> fe ff ff       	callq  <span class="number">4007</span>a0 &lt;std::ostream::<span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))@plt&gt;</span><br><span class="line">  <span class="number">400990</span>:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">400991</span>:	c9                   	leaveq </span><br><span class="line">  <span class="number">400992</span>:	c3                   	retq   </span><br><span class="line">  <span class="number">400993</span>:	<span class="number">90</span>                   	nop</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000400968</span>  w    F .text	<span class="number">000000000000002b</span>              A::<span class="built_in">foo</span>()</span><br><span class="line"></span><br><span class="line"><span class="number">0x400993</span><span class="number">-0x400968</span> = <span class="number">0x2b</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Symbol Name Column (e.g., <code>.interp</code>):</strong></p>
<ul>
<li>This column lists the name of the symbol.</li>
</ul>
</li>
</ol>
<h1 id="Dump-all-symbols-inside-a-section"><a href="#Dump-all-symbols-inside-a-section" class="headerlink" title="Dump all symbols inside a section"></a>Dump all symbols inside a section</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]<span class="meta"># objdump -C -t -j .rodata demo </span></span><br><span class="line"></span><br><span class="line">demo:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"><span class="number">0000000000400</span>a70 l    d  .rodata        <span class="number">0000000000000000</span>              .rodata</span><br><span class="line"><span class="number">0000000000400</span>a80 l     O .rodata        <span class="number">0000000000000001</span>              std::piecewise_construct</span><br><span class="line"><span class="number">0000000000400</span>af8  w    O .rodata        <span class="number">0000000000000003</span>              typeinfo name <span class="keyword">for</span> C</span><br><span class="line"><span class="number">0000000000400</span>ac8  w    O .rodata        <span class="number">0000000000000018</span>              vtable <span class="keyword">for</span> A</span><br><span class="line"><span class="number">0000000000400</span>ae0  w    O .rodata        <span class="number">0000000000000018</span>              typeinfo <span class="keyword">for</span> C</span><br><span class="line"><span class="number">0000000000400</span>a70 g     O .rodata        <span class="number">0000000000000004</span>              _IO_stdin_used</span><br><span class="line"><span class="number">0000000000400b</span>30  w    O .rodata        <span class="number">0000000000000003</span>              typeinfo name <span class="keyword">for</span> A</span><br><span class="line"><span class="number">0000000000400</span>a78 g     O .rodata        <span class="number">0000000000000000</span>              .hidden __dso_handle</span><br><span class="line"><span class="number">0000000000400</span>a98  w    O .rodata        <span class="number">0000000000000018</span>              vtable <span class="keyword">for</span> C</span><br><span class="line"><span class="number">0000000000400b</span>20  w    O .rodata        <span class="number">0000000000000010</span>              typeinfo <span class="keyword">for</span> A</span><br><span class="line"><span class="number">0000000000400b</span>18  w    O .rodata        <span class="number">0000000000000003</span>              typeinfo name <span class="keyword">for</span> B</span><br><span class="line"><span class="number">0000000000400</span>ab0  w    O .rodata        <span class="number">0000000000000018</span>              vtable <span class="keyword">for</span> B</span><br><span class="line"><span class="number">0000000000400b</span>00  w    O .rodata        <span class="number">0000000000000018</span>              typeinfo <span class="keyword">for</span> B</span><br></pre></td></tr></table></figure>

<h1 id="list-all-sections-info"><a href="#list-all-sections-info" class="headerlink" title="list all sections info"></a>list all sections info</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]# objdump -h demo</span><br><span class="line">demo:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn     </span><br><span class="line">  0 .interp       0000001c  0000000000400238  0000000000400238  00000238  2**0     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.ABI-tag 00000020  0000000000400254  0000000000400254  00000254  2**2     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  0000000000400274  0000000000400274  00000274  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .gnu.hash     00000038  0000000000400298  0000000000400298  00000298  2**3     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .dynsym       00000120  00000000004002d0  00000000004002d0  000002d0  2**3     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynstr       00000190  00000000004003f0  00000000004003f0  000003f0  2**0     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .gnu.version  00000018  0000000000400580  0000000000400580  00000580  2**1     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version_r 00000050  0000000000400598  0000000000400598  00000598  2**3    </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  8 .rela.dyn     00000060  00000000004005e8  00000000004005e8  000005e8  2**3     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rela.plt     000000c0  0000000000400648  0000000000400648  00000648  2**3     </span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h1 id="disassemble-a-section"><a href="#disassemble-a-section" class="headerlink" title="disassemble a section"></a>disassemble a section</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s </span><br><span class="line">		打印section内所有内容</span><br><span class="line">-j xxx 或者 --section=xxx</span><br><span class="line">		只打印xxx段</span><br><span class="line">-d </span><br><span class="line">		反汇编</span><br><span class="line">-C </span><br><span class="line">		demangle输出</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]# objdump -C -j .rodata -d demo</span><br><span class="line"></span><br><span class="line">demo:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">0000000000400a70 &lt;_IO_stdin_used&gt;:</span><br><span class="line">  400a70:       01 00 02 00 00 00 00 00                             ........</span><br><span class="line"></span><br><span class="line">0000000000400a78 &lt;__dso_handle&gt;:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">0000000000400a80 &lt;std::piecewise_construct&gt;:</span><br><span class="line">  400a80:       00 41 3a 3a 66 6f 6f 00 42 3a 3a 66 6f 6f 00 43     .A::foo.B::foo.C</span><br><span class="line">  400a90:       3a 3a 66 6f 6f 00 00 00                             ::foo...</span><br><span class="line"></span><br><span class="line">0000000000400a98 &lt;vtable for C&gt;:</span><br><span class="line">        ...</span><br><span class="line">  400aa0:       e0 0a 40 00 00 00 00 00 c0 09 40 00 00 00 00 00     ..@.......@.....</span><br><span class="line"></span><br><span class="line">0000000000400ab0 &lt;vtable for B&gt;:</span><br><span class="line">        ...</span><br><span class="line">  400ab8:       00 0b 40 00 00 00 00 00 94 09 40 00 00 00 00 00     ..@.......@.....</span><br><span class="line"></span><br><span class="line">0000000000400ac8 &lt;vtable for A&gt;:</span><br><span class="line">        ...</span><br><span class="line">  400ad0:       20 0b 40 00 00 00 00 00 68 09 40 00 00 00 00 00      .@.....h.@.....</span><br><span class="line"></span><br><span class="line">0000000000400ae0 &lt;typeinfo for C&gt;:</span><br><span class="line">  400ae0:       b0 0d 60 00 00 00 00 00 f8 0a 40 00 00 00 00 00     ..`.......@.....</span><br><span class="line">  400af0:       00 0b 40 00 00 00 00 00                             ..@.....</span><br><span class="line"></span><br><span class="line">0000000000400af8 &lt;typeinfo name for C&gt;:</span><br><span class="line">  400af8:       31 43 00 00 00 00 00 00                             1C......</span><br><span class="line"></span><br><span class="line">0000000000400b00 &lt;typeinfo for B&gt;:</span><br><span class="line">  400b00:       b0 0d 60 00 00 00 00 00 18 0b 40 00 00 00 00 00     ..`.......@.....</span><br><span class="line">  400b10:       20 0b 40 00 00 00 00 00                              .@.....</span><br><span class="line"></span><br><span class="line">0000000000400b18 &lt;typeinfo name for B&gt;:</span><br><span class="line">  400b18:       31 42 00 00 00 00 00 00                             1B......</span><br><span class="line"></span><br><span class="line">0000000000400b20 &lt;typeinfo for A&gt;:</span><br><span class="line">  400b20:       50 0d 60 00 00 00 00 00 30 0b 40 00 00 00 00 00     P.`.....0.@.....</span><br><span class="line"></span><br><span class="line">0000000000400b30 &lt;typeinfo name for A&gt;:</span><br><span class="line">  400b30:       31 41 00                                            1A.</span><br></pre></td></tr></table></figure>

<h1 id="反汇编某个data-section"><a href="#反汇编某个data-section" class="headerlink" title="反汇编某个data section"></a>反汇编某个data section</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">wqj@WQJ:~/demo$ objdump -C -S -z -j .data.rel.ro.local a.out </span><br><span class="line"></span><br><span class="line">a.out:     file format elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .data.rel.ro.local:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000001</span>d28 &lt;vtable <span class="keyword">for</span> Derived&gt;:</span><br><span class="line">    <span class="number">1</span>d28:       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">78</span> <span class="number">1</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ........x.......</span><br><span class="line">    <span class="number">1</span>d38:       dc <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ................</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000001</span>d48 &lt;vtable <span class="keyword">for</span> Base&gt;:</span><br><span class="line">    <span class="number">1</span>d48:       <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">90</span> <span class="number">1</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ................</span><br><span class="line">    <span class="number">1</span>d58:       bc <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> cc <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ................</span><br></pre></td></tr></table></figure>

<h1 id="disassemble-text-and-rodata-sections"><a href="#disassemble-text-and-rodata-sections" class="headerlink" title="disassemble .text and .rodata sections"></a>disassemble .text and .rodata sections</h1><p>分析虚函数表用到</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objdump -C -j .rodata -j .text -z -S demo</span><br><span class="line"></span><br><span class="line">-d 反汇编会略去<span class="number">0</span></span><br><span class="line">-z 反汇编显示<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="d-vs-z"><a href="#d-vs-z" class="headerlink" title="-d vs -z"></a>-d vs -z</h1><p>-d 把 [0x400b50, 400b57] 8B的全0给省略了，带来困扰</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400b</span>50 &lt;vtable <span class="keyword">for</span> C&gt;:</span><br><span class="line">	...</span><br><span class="line">  <span class="number">400b</span>58:	b0 <span class="number">0b</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span> <span class="number">0</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ..@.......@.....</span><br><span class="line">  <span class="number">400b</span>68:	aa <span class="number">09</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                             ..@.....</span><br></pre></td></tr></table></figure>

<p>-z</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400b</span>50 &lt;vtable <span class="keyword">for</span> C&gt;:</span><br><span class="line">  <span class="number">400b</span>50:	<span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> b0 <span class="number">0b</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ..........@.....</span><br><span class="line">  <span class="number">400b</span>60:	<span class="number">02</span> <span class="number">0</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> aa <span class="number">09</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>     ..@.......@.....</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux readelf</title>
    <url>/2024/02/19/note/linux/readelf/</url>
    <content><![CDATA[<h2 id="Dump-section-header-table"><a href="#Dump-section-header-table" class="headerlink" title="Dump section header table"></a>Dump section header table</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -S -W a.o</span></span><br><span class="line">There are 13 section headers, starting at offset 0x298:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .text             PROGBITS        0000000000000000 000040 000010 00  AX  0   0  1</span><br><span class="line">  [ 2] .rela.text        RELA            0000000000000000 0001f8 000018 18   I 10   1  8</span><br><span class="line">  [ 3] .data             PROGBITS        0000000000000000 000050 000000 00  WA  0   0  1</span><br><span class="line">  [ 4] .bss              NOBITS          0000000000000000 000050 000000 00  WA  0   0  1</span><br><span class="line">  [ 5] .comment          PROGBITS        0000000000000000 000050 00002c 01  MS  0   0  1</span><br><span class="line">  [ 6] .note.GNU-stack   PROGBITS        0000000000000000 00007c 000000 00      0   0  1</span><br><span class="line">  [ 7] .note.gnu.property NOTE            0000000000000000 000080 000020 00   A  0   0  8</span><br><span class="line">  [ 8] .eh_frame         PROGBITS        0000000000000000 0000a0 000038 00   A  0   0  8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA            0000000000000000 000210 000018 18   I 10   8  8</span><br><span class="line">  [10] .symtab           SYMTAB          0000000000000000 0000d8 000108 18     11   9  8</span><br><span class="line">  [11] .strtab           STRTAB          0000000000000000 0001e0 000012 00      0   0  1</span><br><span class="line">  [12] .shstrtab         STRTAB          0000000000000000 000228 00006c 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="Dump-content-of-a-section"><a href="#Dump-content-of-a-section" class="headerlink" title="Dump content of a section"></a>Dump content of a section</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -x .rela.text a.o</span></span><br><span class="line"></span><br><span class="line">Hex dump of section &#x27;.rela.text&#x27;:</span><br><span class="line">  0x00000000 0a000000 00000000 02000000 0a000000 ................</span><br><span class="line">  0x00000010 fcffffff ffffffff                   ........</span><br></pre></td></tr></table></figure>

<h2 id="Dump-relocation-entries"><a href="#Dump-relocation-entries" class="headerlink" title="Dump relocation entries"></a>Dump relocation entries</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">readelf -r a.o</span></span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.text&#x27; at offset 0x1f8 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">00000000000a  000a00000002 R_X86_64_PC32     0000000000000000 foo - 4</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.eh_frame&#x27; at offset 0x210 contains 1 entry:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000000020  000200000002 R_X86_64_PC32     0000000000000000 .text + 0</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux sar</title>
    <url>/2024/02/19/note/linux/sar/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>sar &#x3D; <strong>s</strong>ystem <strong>a</strong>ctivity <strong>r</strong>eport</p>
<p>sar是一套组件，监控Linux系统整体各项运行参数（CPU，内存等），同时支持以文件形式保留过去N天的历史记录以备后续查看。</p>
<ul>
<li>sar(system activity reporter) - 收集、存储与展示各项参数</li>
<li>sadc(system activity data collector) - 收集各项参数，是sar背后的数据来源</li>
<li><a href="https://github.com/sysstat/sysstat/blob/master/sa1.in">sa1</a> - 是封装了sadc的shell脚本（<code>vim /usr/lib64/sa/sa1</code>查看实现），特别适配了跨天等特殊情况，专门用于cron定时任务</li>
<li><a href="https://github.com/sysstat/sysstat/blob/master/sa2.in">sa2</a> - 是封装了sar的shell脚本（<code>vim /usr/lib64/sa/sa2</code>），同sa1，专门用于cron</li>
<li>sadf(system activity data formatter) displays data collected by sar in multiple formats (CSV, XML, JSON, etc.)</li>
</ul>
<p>是否装了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> sar</span></span><br><span class="line">/usr/bin/sar</span><br></pre></td></tr></table></figure>

<p>如果没有，安装命令（sar包含在sysstat工具中）:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install sysstat</span><br></pre></td></tr></table></figure>

<h1 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h1><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>集收集、存储与展示与一体，输出为人可直接读格式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sar [options] [interval] [count]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>有interval则取实时数据，无则读取当天的 <code>/var/log/sa/sadd</code> 历史数据，或者-f指明读取那个文件</p>
</li>
<li><p>有count则执行count次，无count则按interval持续采样</p>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>只列出大部分常见的选项，完整选项及输出中各列的含义参考：<code>man sar</code></p>
<h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><blockquote>
<p>-u    Report CPU utilization.</p>
</blockquote>
<p>间隔1秒，实时采样cpu利用率</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sar -u 1</span><br><span class="line">Linux 3.10.0-957.21.2.el7.x86_64 (localhost.localdomain)        11/28/2023      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">02:01:31 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">02:01:32 PM     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">02:01:33 PM     all      0.00      0.00      0.00      0.12      0.00     99.88</span><br><span class="line">02:01:34 PM     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">Average:        all      0.00      0.00      0.00      0.04      0.00     99.96</span><br></pre></td></tr></table></figure>

<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><blockquote>
<p>-r     Report memory utilization statistics.</p>
<p>-R     Report memory statistics. </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 release]$ sar -r 1</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:41:09 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">03:41:10 PM    245456  32532996     99.25     52744  15628984  33275528    101.52  22506656   8187572       632</span><br><span class="line">03:41:11 PM    248036  32530416     99.24     52744  15629016  33276372    101.52  22506524   8187576       816</span><br><span class="line">03:41:12 PM    332940  32445512     98.98     52760  15561484  33257372    101.46  22454672   8154880       748</span><br><span class="line">03:41:13 PM    328256  32450196     99.00     52760  15562648  33260864    101.47  22457052   8155832       780</span><br><span class="line">03:41:14 PM    330184  32448268     98.99     52760  15562676  33260168    101.47  22457036   8155836       876</span><br><span class="line">03:41:15 PM    329732  32448720     98.99     52760  15562708  33258960    101.47  22455684   8155836       948</span><br></pre></td></tr></table></figure>

<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><blockquote>
<p>-n Report network statistics.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar -n TCP 1</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:55:51 PM  active/s passive/s    iseg/s    oseg/s</span><br><span class="line">03:55:52 PM      3.00      0.00   8188.00  10050.00</span><br><span class="line">03:55:53 PM      3.00      0.00   9427.00  11465.00</span><br><span class="line">03:55:54 PM      5.00      0.00   7342.00   8941.00</span><br></pre></td></tr></table></figure>

<h4 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h4><blockquote>
<p>-b     Report I&#x2F;O and transfer rate statistics. </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar -b 1</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:59:49 PM       tps      rtps      wtps   bread/s   bwrtn/s</span><br><span class="line">03:59:50 PM    134.00      0.00    134.00      0.00    588.00</span><br><span class="line">03:59:51 PM    123.00      0.00    123.00      0.00    543.00</span><br><span class="line">03:59:52 PM     94.00      0.00     94.00      0.00    407.00</span><br><span class="line">03:59:53 PM    150.00      0.00    150.00      0.00    659.00</span><br></pre></td></tr></table></figure>

<h4 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h4><blockquote>
<p>-d     Report activity for each block device. </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar -d 1</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">04:00:25 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line">04:00:26 PM  dev253-0      3.00      0.00    160.00     53.33      0.00      1.33      1.00      0.30</span><br><span class="line">04:00:26 PM dev253-16    202.00      0.00   2488.00     12.32      0.65      3.50      1.51     30.50</span><br><span class="line"></span><br><span class="line">04:00:26 PM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util</span><br><span class="line">04:00:27 PM  dev253-0      1.00      0.00      8.00      8.00      0.00      1.00      1.00      0.10</span><br><span class="line">04:00:27 PM dev253-16    108.00      0.00    499.00      4.62      0.09      2.07      0.75      8.10</span><br></pre></td></tr></table></figure>

<h4 id="页面系统"><a href="#页面系统" class="headerlink" title="页面系统"></a>页面系统</h4><blockquote>
<p>-B     Report paging statistics. </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar 1 -B</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:50:01 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class="line">03:50:02 PM      0.00    142.00  13400.00      0.00   9255.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:50:03 PM      0.00    250.00  18728.00      0.00  12830.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:50:04 PM      0.00    344.00  14404.00      0.00  10405.00      0.00      0.00      0.00      0.00</span><br><span class="line">03:50:05 PM      0.00    218.00  58759.00      0.00  22695.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>

<h4 id="任务创建与调度"><a href="#任务创建与调度" class="headerlink" title="任务创建与调度"></a>任务创建与调度</h4><blockquote>
<p>-w     Report task creation and system switching activity.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar -w 1</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">04:03:15 PM    proc/s   cswch/s</span><br><span class="line">04:03:16 PM      6.00 157005.00</span><br><span class="line">04:03:17 PM      8.00 154067.00</span><br><span class="line">04:03:18 PM     11.00 158563.00</span><br><span class="line">04:03:19 PM      7.00 154540.00</span><br><span class="line">04:03:20 PM      8.00 149415.00</span><br><span class="line">04:03:21 PM     10.00 153150.00</span><br><span class="line">04:03:22 PM      7.00 153668.00</span><br></pre></td></tr></table></figure>

<h4 id="任务队列负载"><a href="#任务队列负载" class="headerlink" title="任务队列负载"></a>任务队列负载</h4><blockquote>
<p>-q Report queue length and load averages.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar -q 1</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:52:59 PM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked</span><br><span class="line">03:53:00 PM         3      2451      6.25      8.25      9.51         0</span><br><span class="line">03:53:01 PM         8      2450      6.25      8.25      9.51         0</span><br><span class="line">03:53:02 PM        10      2453      6.25      8.25      9.51         0</span><br><span class="line">03:53:03 PM         3      2453      6.25      8.25      9.51         0</span><br></pre></td></tr></table></figure>

<h4 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h4><blockquote>
<p>-S     Report swap space utilization statistics. </p>
<p>-W     Report swapping statistics.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[game@vm10-245-65-72 glinkd]$ sar 1 -S</span><br><span class="line">Linux 3.10.0-1062.18.1.el7.x86_64 (vm10-245-65-72.cloud.local)  11/28/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:52:08 PM kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">03:52:09 PM         0         0      0.00         0      0.00</span><br><span class="line">03:52:10 PM         0         0      0.00         0      0.00</span><br><span class="line">03:52:11 PM         0         0      0.00         0      0.00</span><br><span class="line">03:52:12 PM         0         0      0.00         0      0.00</span><br><span class="line">03:52:13 PM         0         0      0.00         0      0.00</span><br></pre></td></tr></table></figure>

<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><blockquote>
<p>-I    Report  statistics  for a given interrupt.</p>
</blockquote>
<p>中断次数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost demo]# sar -I ALL 1</span><br><span class="line">Linux 3.10.0-957.21.2.el7.x86_64 (localhost.localdomain)        11/28/2023      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">03:20:01 PM      INTR    intr/s</span><br><span class="line">03:20:03 PM         0      0.00</span><br><span class="line">03:20:03 PM         1      0.00</span><br><span class="line">03:20:03 PM         2      0.00</span><br><span class="line">03:20:03 PM         3      0.00</span><br><span class="line">03:20:03 PM         4      0.00</span><br><span class="line">03:20:03 PM         5      0.00</span><br><span class="line">03:20:03 PM         6      0.00</span><br><span class="line">03:20:03 PM         7      0.00</span><br><span class="line">03:20:03 PM         8      0.00</span><br><span class="line">03:20:03 PM         9      0.00</span><br><span class="line">03:20:03 PM        10      0.00</span><br><span class="line">03:20:03 PM        11      0.00</span><br><span class="line">03:20:03 PM        12      0.00</span><br><span class="line">03:20:03 PM        13      0.00</span><br><span class="line">03:20:03 PM        14      0.00</span><br><span class="line">03:20:03 PM        15      1.89</span><br></pre></td></tr></table></figure>

<h2 id="sadc"><a href="#sadc" class="headerlink" title="sadc"></a>sadc</h2><p>专门用于收集运行参数，输出为二进制格式，人不可直接读，命令格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/lib64/sa/sadc [options] [interval [count] &gt; &lt;sadc_outfile&gt;</span><br></pre></td></tr></table></figure>

<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>以1秒间隔，收集3次所有参数，结果存到sadc.out文件（二进制格式），需要用sar解析为可读格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/lib64/sa/sadc 1 3 &gt; sadc.out</span><br></pre></td></tr></table></figure>

<p>用sar解析刚刚生成的sadc.out文件为可读格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sar -A -f &lt;sadc outfile&gt; &gt; &lt;sar outfile&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-A 所有运行参数</p>
</li>
<li><p>-f 指明二进制数据文件</p>
</li>
</ul>
<p>输出到命令行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost demo]# sar -A -f sadc.out</span><br><span class="line">Linux 3.10.0-957.21.2.el7.x86_64 (localhost.localdomain)        11/28/2023      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">02:21:15 PM     CPU      %usr     %nice      %sys   %iowait    %steal      %irq     %soft    %guest    %gnice     %idle</span><br><span class="line">02:21:16 PM     all      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">02:21:16 PM       0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">02:21:16 PM       1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">02:21:16 PM       2      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">02:21:15 PM    proc/s   cswch/s</span><br><span class="line">02:21:16 PM      1.00     37.00</span><br><span class="line">02:21:17 PM      0.00     34.00</span><br><span class="line">Average:         0.50     35.50</span><br><span class="line"></span><br><span class="line">02:21:15 PM  pswpin/s pswpout/s</span><br><span class="line">02:21:16 PM      0.00      0.00</span><br><span class="line">02:21:17 PM      0.00      0.00</span><br><span class="line">Average:         0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff</span><br><span class="line">02:21:16 PM      0.00      0.00     22.00      0.00     27.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM      0.00      0.00     17.00      0.00     28.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         0.00      0.00     19.50      0.00     27.50      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM       tps      rtps      wtps   bread/s   bwrtn/s</span><br><span class="line">02:21:16 PM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM   frmpg/s   bufpg/s   campg/s</span><br><span class="line">02:21:16 PM      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM     25.00      0.00     -1.00</span><br><span class="line">Average:        12.50      0.00     -0.50</span><br><span class="line"></span><br><span class="line">02:21:15 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">02:21:16 PM  11018224    969344      8.09      3140    408484    539808      3.83    303072    192240         0</span><br><span class="line">02:21:17 PM  11018324    969244      8.09      3140    408480    539808      3.83    303204    192240         8</span><br><span class="line">Average:     11018274    969294      8.09      3140    408482    539808      3.83    303138    192240         4</span><br><span class="line"></span><br><span class="line">02:21:15 PM kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">02:21:16 PM   2097148         0      0.00         0      0.00</span><br><span class="line">02:21:17 PM   2097148         0      0.00         0      0.00</span><br><span class="line">Average:      2097148         0      0.00         0      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM kbhugfree kbhugused  %hugused</span><br><span class="line">02:21:16 PM         0         0      0.00</span><br><span class="line">02:21:17 PM         0         0      0.00</span><br><span class="line">Average:            0         0      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM dentunusd   file-nr  inode-nr    pty-nr</span><br><span class="line">02:21:16 PM    108395      1760     91408         2</span><br><span class="line">02:21:17 PM    108395      1760     91408         2</span><br><span class="line">Average:       108395      1760     91408         2</span><br><span class="line"></span><br><span class="line">02:21:15 PM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked</span><br><span class="line">02:21:16 PM         0       210      0.00      0.01      0.05         0</span><br><span class="line">02:21:17 PM         0       210      0.00      0.01      0.05         0</span><br><span class="line">Average:            0       210      0.00      0.01      0.05         0</span><br><span class="line"></span><br><span class="line">02:21:15 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">02:21:16 PM    enp0s3      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:16 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:16 PM virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:16 PM    virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM    enp0s3      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM    virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       enp0s3      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:    virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM     IFACE   rxerr/s   txerr/s    coll/s  rxdrop/s  txdrop/s  txcarr/s  rxfram/s  rxfifo/s  txfifo/s</span><br><span class="line">02:21:16 PM    enp0s3      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:16 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:16 PM virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:16 PM    virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM    enp0s3      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM    virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       enp0s3      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:    virbr0-nic      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:       virbr0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM    call/s retrans/s    read/s   write/s  access/s  getatt/s</span><br><span class="line">02:21:16 PM      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM   scall/s badcall/s  packet/s     udp/s     tcp/s     hit/s    miss/s   sread/s  swrite/s saccess/s sgetatt/s</span><br><span class="line">02:21:16 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">02:21:17 PM      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">Average:         0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">02:21:15 PM    totsck    tcpsck    udpsck    rawsck   ip-frag    tcp-tw</span><br><span class="line">02:21:16 PM       294        10         5         0         0         0</span><br><span class="line">02:21:17 PM       294        10         5         0         0         0</span><br><span class="line">Average:          294        10         5         0         0         0</span><br></pre></td></tr></table></figure>

<h2 id="sa1-和-sa2"><a href="#sa1-和-sa2" class="headerlink" title="sa1 和 sa2"></a>sa1 和 sa2</h2><p>sa1和sa2分别是sadc和sar的定时任务版，特别适配了cron定时任务执行环境（如跨天等）。</p>
<p><code>/usr/lib64/sa/sa1</code> 封装了 sadc，收集的数据，以二进制形式写入 <code>/var/log/sa/saDD</code> (DD是天数占位符)</p>
<ul>
<li>例如：2023&#x2F;11&#x2F;28的所有sa1结果都存到：&#x2F;var&#x2F;log&#x2F;sa&#x2F;sa28</li>
</ul>
<p><code>/usr/local/lib64/sa/sa2</code> 封装了sar，取今天的 <code>/var/log/sa/saDD</code> 解析为人可直接读格式，另存为 <code>/var/log/sa/sarDD</code> (文件名多了个 r)</p>
<ul>
<li>例如：2023&#x2F;11&#x2F;28 执行后，sa2读取 &#x2F;var&#x2F;log&#x2F;sa&#x2F;sa28，另存为人可读的：&#x2F;var&#x2F;log&#x2F;sa&#x2F;sar28</li>
</ul>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>centos7 默认配置了每隔10分钟执行一次sadc，和每天 23:53:00 执行一次 sar 的定时任务。</p>
<p>定时任务</p>
<ul>
<li><p><code>*/10 * * * * root /usr/lib64/sa/sa1 1 1</code> 每隔10分钟运行一次sa1(即sadc)，收集一次系统所有运行参数，结果保存至 <code>/var/log/sa/sadd</code> 文件(以二进制格式存储), dd是占位符，代表具体天数，取值 [01, 31]，比如 2023&#x2F;11&#x2F;28 的结果都存到文件: <code>/var/log/sa/sa28</code>。</p>
</li>
<li><p><code>53 23 * * * root /usr/lib64/sa/sa2 -A</code> 每天的 23:53:00 执行一次 sa2(即sar), 读上一步每隔10分钟收集一次的定时任务生成的当天的所有数据 <code>/var/log/sa/sadd</code>，用sar解析成可读的版本存到文件 <code>/var/log/sa/sardd</code>，例如 2023&#x2F;11&#x2F;28 日，23:53:00 读取 <code>/var/log/sa/sa28</code> 生成可读版本 <code>/var/log/sa/sar28</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@vm10-245-65-72 ~]# cat /etc/cron.d/sysstat</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run system activity accounting tool every 10 minutes</span></span><br><span class="line">*/10 * * * * root /usr/lib64/sa/sa1 1 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">0 * * * * root /usr/lib64/sa/sa1 600 6 &amp;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Generate a daily summary of process accounting at 23:53</span></span><br><span class="line">53 23 * * * root /usr/lib64/sa/sa2 -A</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><ul>
<li><p><a href="https://linux.die.net/man/8/sadc">sadc(8) - Linux man page</a></p>
</li>
<li><p><a href="http://www.lostpenguin.net/index.php/sar-sadc-sa1/">Sar, Sadc &amp; Sa1</a></p>
</li>
<li><p><a href="https://luppeng.wordpress.com/2023/05/03/differences-between-sadc-and-sar-vs-sa1-and-sa2/">Differences Between sadc and sar, vs sa1 and sa2</a></p>
</li>
<li><p><a href="https://www.thegeekstuff.com/2011/03/sar-examples/">10 Useful Sar (Sysstat) Examples for UNIX &#x2F; Linux Performance Monitoring</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软链接和硬链接用法及区别</title>
    <url>/2024/02/19/note/linux/soft_link_and_hard_link/</url>
    <content><![CDATA[<h1 id="Linux软链接和硬链接"><a href="#Linux软链接和硬链接" class="headerlink" title="Linux软链接和硬链接"></a>Linux软链接和硬链接</h1><h2 id="创建软硬链接"><a href="#创建软硬链接" class="headerlink" title="创建软硬链接"></a>创建软硬链接</h2><p>Creating a symlink</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s myfile mylink</span><br></pre></td></tr></table></figure>

<p>Creating a hardlink</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ln somefile somelink</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接与源文件共享inode（<code>ll -i</code> 第三列显示当前文件inode引用计数），删除源文件后（inode引用减一），硬链接还引用着，inode引用数为1，文件不删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># echo &quot;hh&quot; &gt; file</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ln file file_hard_link</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">115686215428339169 -rw-r--r-- 2 root root 3 Feb  6 16:45 file</span><br><span class="line">115686215428339169 -rw-r--r-- 2 root root 3 Feb  6 16:45 file_hard_link</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm file</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">115686215428339169 -rw-r--r-- 1 root root 3 Feb  6 16:45 file_hard_link</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># cat file_hard_link </span></span><br><span class="line">hh</span><br></pre></td></tr></table></figure>

<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接指向源文件的路径，删除源文件后，软连接指向失效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ln -s file file_soft_link</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">115686215428339169 -rw-r--r-- 1 root root 3 Feb  6 16:45 file</span><br><span class="line">225179981368582177 lrwxrwxrwx 1 root root 4 Feb  6 16:48 file_soft_link -&gt; file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm -f file</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">225179981368582177 lrwxrwxrwx 1 root root 4 Feb  6 16:48 file_soft_link -&gt; file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># cat file_soft_link </span></span><br><span class="line"><span class="built_in">cat</span>: file_soft_link: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><p><img src="/../assets/image-66.png" alt="Alt text"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> file</span><br><span class="line">$ <span class="built_in">ln</span> -s file file_soft_link</span><br><span class="line">$ <span class="built_in">ln</span> file file_hard_link</span><br><span class="line">$ ll -i</span><br><span class="line">total 0</span><br><span class="line">21955048184376494 -rw-r--r-- 2 root root 0 Feb  6 16:30 file</span><br><span class="line">21955048184376494 -rw-r--r-- 2 root root 0 Feb  6 16:30 file_hard_link        </span><br><span class="line">11258999069499309 lrwxrwxrwx 1 root root 4 Feb  6 16:30 file_soft_link -&gt; file</span><br></pre></td></tr></table></figure>

<ul>
<li>软链接inode私有，硬链接inode共享；</li>
<li>由于硬链接共享inode，而inode各个文件系统独立，因此硬链接不能跨文件系统；软链接支持跨文件系统，因为软连接指向的是文件的路径。</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux strace</title>
    <url>/2024/02/19/note/linux/strace/</url>
    <content><![CDATA[<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="strace抓取ld链接器具体参数"><a href="#strace抓取ld链接器具体参数" class="headerlink" title="strace抓取ld链接器具体参数"></a>strace抓取ld链接器具体参数</h2><p><a href="https://stackoverflow.com/a/62562907/11850070">详见</a></p>
<p>strace参数解释：</p>
<ul>
<li><code>-o</code> forked.log save the output to forked.log  </li>
<li><code>-s</code> 1024 variables shorter than 1024 chars are not truncated (default 32 was not enough)  </li>
<li><code>-f</code> enables strace on forked processes  </li>
<li><code>-e trace=/exec</code> - filter system calls so only ones starting with exec are shown</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -o forked.log -s 1024 -f -e trace=/exec gcc hello.c.s -o hello_gcc</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl代理配置</title>
    <url>/2024/02/19/note/linux/wsl_proxy/</url>
    <content><![CDATA[<h1 id="wsl1-proxy"><a href="#wsl1-proxy" class="headerlink" title="wsl1 proxy"></a>wsl1 proxy</h1><p>勾选 “Allow LAN” 后，设置如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export ALL_PROXY=&quot;http://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure>

<h1 id="wsl2-proxy"><a href="#wsl2-proxy" class="headerlink" title="wsl2 proxy"></a>wsl2 proxy</h1><p><a href="https://zhuanlan.zhihu.com/p/592620059">https://zhuanlan.zhihu.com/p/592620059</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">hostip=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)</span><br><span class="line">wslip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"># 这里填写主机代理的端口</span><br><span class="line">port=7890</span><br><span class="line"></span><br><span class="line">PROXY_HTTP=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;</span><br><span class="line"></span><br><span class="line">set_proxy()&#123;</span><br><span class="line">    export http_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">    export HTTP_PROXY=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"></span><br><span class="line">    export https_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">    export HTTPS_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"></span><br><span class="line">    git config --global http.proxy &quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">    git config --global https.proxy &quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unset_proxy()&#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset HTTP_PROXY</span><br><span class="line">    unset https_proxy</span><br><span class="line">    unset HTTPS_PROXY</span><br><span class="line">    git config --global --unset http.proxy</span><br><span class="line">    git config --global --unset https.proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_setting()&#123;</span><br><span class="line">    echo &quot;Host ip:&quot; $&#123;hostip&#125;</span><br><span class="line">    echo &quot;WSL ip:&quot; $&#123;wslip&#125;</span><br><span class="line">    echo &quot;Current proxy:&quot; $https_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &quot;set&quot; ]</span><br><span class="line">then</span><br><span class="line">    set_proxy</span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;unset&quot; ]</span><br><span class="line">then</span><br><span class="line">    unset_proxy</span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;test&quot; ]</span><br><span class="line">then</span><br><span class="line">    test_setting</span><br><span class="line">else</span><br><span class="line">    echo &quot;Unsupported arguments.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux zombie process</title>
    <url>/2024/02/19/note/linux/zombie_process/</url>
    <content><![CDATA[<p>You cannot kill a <code>&lt;defunct&gt;</code> process (also known as zombie process) as it is already dead. The system keeps zombie processes for the parent to collect the exit status. If the parent does not collect the exit status then the zombie processes will stay around forever. The only way to get rid of those zombie processes are by killing the parent. If the parent is init then you can only reboot.</p>
<p>Zombie processes take up almost no resouces so there is no performance cost in letting them linger. Although having zombie processes around usually means there is a bug in some of your programs. Init should usually collect all children. If init has zombie children then there is a bug in init (or somehwere else but a bug it is).</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尝试复现：</span><br><span class="line"></span><br><span class="line">创建一个父进程是1的进程，然后kill掉它，他如果没有被init回收掉pid，就变成defunct</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis底层数据结构</title>
    <url>/2024/02/19/note/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 Redis 代码的（还未发布正式版本）。</p>
<img title="" src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png" alt="" width="808">

<p>可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如：</p>
<ul>
<li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li>
<li>在最新的 Redis 代码（还未发布正式版本）中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li>
</ul>
<p><strong>共有 9 种数据结构：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。</strong></p>
<img title="" src="https://cdn.xiaolincoding.com//mysql/other/a9c3e7dc4ac79363d8eb8eb2290a58e6.png" alt="" width="804">

<h2 id="键值对数据库是怎么实现的？"><a href="#键值对数据库是怎么实现的？" class="headerlink" title="键值对数据库是怎么实现的？"></a>键值对数据库是怎么实现的？</h2><p>在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。</p>
<p>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p>
<p>举个例子，我这里列出几种 Redis 新增键值对的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SET name &quot;xiaolincoding&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; HSET person name &quot;xiaolincoding&quot; age 18</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt; RPUSH stu &quot;xiaolin&quot; &quot;xiaomei&quot;</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p>这些命令代表着：</p>
<ul>
<li>第一条命令：name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>；</li>
<li>第二条命令：person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>；</li>
<li>第三条命令：stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>；</li>
</ul>
<p>这些键值对是如何保存在 Redis 中的呢？</p>
<p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢？</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<p>我这里画了一张 Redis 保存键值对所涉及到的数据结构。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f302fce6c92c0682024f47bf7579b44c.png"></p>
<p>这些数据结构的内部细节，我先不展开讲，后面在讲哈希表数据结构的时候，在详细的说说，因为用到的数据结构是一样的。这里先大概说下图中涉及到的数据结构的名字和用途：</p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， _key 指向的是 String 对象，而 _value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象__。</li>
</ul>
<p>特别说明下，void * key 和 void * value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/58d3987af2af868dca965193fb27c464.png"></p>
<p>对象结构里包含的成员变量：</p>
<ul>
<li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li>
<li>encoding，标识该对象使用了哪种底层的数据结构；</li>
<li><strong>ptr，指向底层数据结构的指针</strong>。</li>
</ul>
<p>我画了一张 Redis 键值对数据库的全景图，你就能清晰知道 Redis 对象和数据结构的关系了：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/3c386666e4e7638a07b230ba14b400fe.png"></p>
<p>接下里，就好好聊一下底层数据结构！</p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。</p>
<p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p>
<p>既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。</p>
<p>要了解这一点，得先来看看 char* 字符数组的结构。</p>
<h3 id="C-语言字符串的缺陷"><a href="#C-语言字符串的缺陷" class="headerlink" title="C 语言字符串的缺陷"></a>C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p>
<p>比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/376128646c75a893ad47914858fa2131.png"></p>
<p>没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\0”？</p>
<p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p>
<p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p>
<p>举个例子，C 语言获取字符串长度的函数 <code>strlen</code>，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/bcf6bde3b647bdc343efcbc1a8f10579.png"></p>
<p>很明显，**C 语言获取字符串长度的时间复杂度是 O（N）（<em>这是一个可以改进的地方</em>**）</p>
<p>C 语言字符串用 “\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\0” 字符，这时在操作这个字符串时就会<strong>提早结束</strong>，比如 “xiao\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6286480eb1840a8930e18fd215d82565.png"></p>
<p>因此，除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（_这也是一个可以改进的地方_）</strong></p>
<p>另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。</p>
<p>举个例子，strcat 函数是可以将两个字符串拼接在一起。</p>
<p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而**一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（<em>这是一个可以改进的地方</em>**）。</p>
<p>而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，<strong>对字符串的操作效率不高</strong>。</p>
<p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p>
<ul>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li>
<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li>
</ul>
<p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p>
<h3 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/516738c4058cdf9109e40a7812ef4239.png"></p>
<p>结构中的每个成员变量分别介绍下：</p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p>
<h4 id="O（1）复杂度获取字符串长度"><a href="#O（1）复杂度获取字符串长度" class="headerlink" title="O（1）复杂度获取字符串长度"></a>O（1）复杂度获取字符串长度</h4><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p>
<p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p>
<h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p>
<p>因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。</p>
<p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p>
<h4 id="不会发生缓冲区溢出"><a href="#不会发生缓冲区溢出" class="headerlink" title="不会发生缓冲区溢出"></a>不会发生缓冲区溢出</h4><p>C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p>
<p>所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>alloc - len</code> 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p>
<p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，以满足修改所需的大小。</p>
<p>SDS 扩容的规则代码如下：</p>
<ul>
<li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li>
<li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li>
</ul>
<p>在扩容 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。</p>
<p>这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，<strong>有效的减少内存分配次数</strong>。</p>
<p>所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。</p>
<h4 id="节省内存空间"><a href="#节省内存空间" class="headerlink" title="节省内存空间"></a>节省内存空间</h4><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p>
<p>Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p>
<p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p>
<p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p>
<p>可以看到：</p>
<ul>
<li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li>
<li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li>
</ul>
<p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p>
<p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。</p>
<p>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：</p>
<p>大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/35820959e8cf4376391c427ed7f81495.png"></p>
<p>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。</p>
<p>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 <code>__attribute__ ((packed))</code> 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p>
<p>比如，我用 <code>__attribute__ ((packed))</code> 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：</p>
<p>这时打印的结果是 5（1 个字节 char + 4 字节 int）。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/47e6c8fbc17fd6c89bdfcb5eedaaacff.png"></p>
<p>可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。</p>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>大家最熟悉的数据结构除了数组之外，我相信就是链表了。</p>
<p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。</p>
<h3 id="链表节点结构设计"><a href="#链表节点结构设计" class="headerlink" title="链表节点结构设计"></a>链表节点结构设计</h3><p>先来看看「链表节点」结构的样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>有前置节点和后置节点，可以看的出，这个是一个双向链表。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/4fecbf7f63c73ec284a4821e0bfe2843.png"></p>
<h3 id="链表结构设计"><a href="#链表结构设计" class="headerlink" title="链表结构设计"></a>链表结构设计</h3><p>不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p>
<p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/cadf797496816eb343a19c2451437f1e.png"></p>
<h3 id="链表的优势与缺陷"><a href="#链表的优势与缺陷" class="headerlink" title="链表的优势与缺陷"></a>链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；</li>
<li>list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；</li>
<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li>
</ul>
<p>链表的缺陷也是有的：</p>
<ul>
<li><p>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</p>
</li>
<li><p>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</p>
</li>
</ul>
<p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p>
<p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p>
<p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p>
<hr>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p>但是，压缩列表的缺陷也是有的：</p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<p>因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p>
<p>接下来，就跟大家详细聊下压缩列表。</p>
<h3 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/ab0b44f557f8b5bc7acb3a53d43ebfcb.png"></p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li><strong>zlbytes</strong>，记录整个压缩列表占用对内存字节数；</li>
<li><strong>zltail</strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><strong>zllen</strong>，记录压缩列表包含的节点数量；</li>
<li><strong>zlend</strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>另外，压缩列表节点（entry）的构成如下：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png"></p>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li>_<strong>prevlen</strong>_，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li>
<li>_<strong>encoding</strong>_，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li>
<li>_<strong>data</strong>_，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p>
<p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p>
<ul>
<li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关，如下图（下图中的 content 表示的是实际数据，即本文的 data 字段）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BC%96%E7%A0%81.png"></p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节&#x2F;2字节&#x2F;5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>压缩列表除了查找复杂度高的问题，还有一个问题。</p>
<p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<p>前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p>
<ul>
<li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/462c6a65531667f2bcf420953b0aded9.png"></p>
<p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p>
<p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/d1a6deff4672580609c99a5b06bf3429.png"></p>
<p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p>
<p>多米诺牌的效应就此开始。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/1f0e5ae7ab749078cadda5ba0ed98eac.png"></p>
<p>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p>
<p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。</p>
<p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，</p>
<h3 id="压缩列表的缺陷"><a href="#压缩列表的缺陷" class="headerlink" title="压缩列表的缺陷"></a>压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p>
<p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p>
<p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p>
<hr>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>Redis 的 Hash 对象的底层实现之一是压缩列表（最新 Redis 代码已将压缩列表替换成 listpack）。Hash 对象的另外一个底层实现就是哈希表。</p>
<p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。</p>
<p>但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p>
<p>解决哈希冲突的方式，有很多种。</p>
<p><strong>Redis 采用了「链式哈希」来解决哈希冲突</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p>
<h3 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h3><p>Redis 的哈希表结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于 size - 1，这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>图 4-1 展示了一个大小为 <code>4</code> 的空哈希表 （没有包含任何键值对）。</p>
<p><img src="/./assets/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png" alt="graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png (395×333)"></p>
<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数。</p>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<p>举个例子， 图 4-2 就展示了如何通过 <code>next</code> 指针， 将两个索引值相同的键 <code>k1</code> 和 <code>k0</code> 连接在一起。</p>
<p><img src="/./assets/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png" alt="graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png (740×346)"></p>
<h4 id="字典-哈希表"><a href="#字典-哈希表" class="headerlink" title="字典&#x2F;哈希表"></a>字典&#x2F;哈希表</h4><p>Redis 中的字典由 <code>dict</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：</p>
<p><img src="/./assets/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png" alt="graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png (721×532)"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[<span class="number">0</span>] 或者 ht[<span class="number">1</span>]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p><img src="/./assets/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png" alt="graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png (581×359)"></p>
<p>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 <code>k0</code> 和 <code>v0</code> 添加到字典里面， 那么程序会先使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>

<p>计算键 <code>k0</code> 的哈希值。</p>
<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>

<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上， 如图 4-5 所示。</p>
<p><img src="/./assets/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png" alt="graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png (721×381)"></p>
<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</p>
<p>MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</p>
<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a href="http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a> 。</p>
<h4 id="哈希冲突解决"><a href="#哈希冲突解决" class="headerlink" title="哈希冲突解决"></a>哈希冲突解决</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>举个例子， 假设程序要将键值对 <code>k2</code> 和 <code>v2</code> 添加到图 4-6 所示的哈希表里面， 并且计算得出 <code>k2</code> 的索引值为 <code>2</code> ， 那么键 <code>k1</code> 和 <code>k2</code> 将产生冲突， 而解决冲突的办法就是使用 <code>next</code> 指针将键 <code>k2</code> 和 <code>k1</code> 所在的节点连接起来， 如图 4-7 所示。</p>
<p><img src="/./assets/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png" alt="graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png (569×367)"></p>
<p><img src="/./assets/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png" alt="graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png (740×367)"></p>
<p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 用头插法总是将新节点添加到链表的表头位置（因此插入操作的时间复杂度为 O(1)）。</p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的 <code>ht[1]</code>哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 <code>ht[0]</code> 当前包含的键值对数量 （也即是 <code>ht[0].used</code> 的值）<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。（TODO：没理解）</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<h5 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h5><p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>计算得出。</p>
<p>比如说， 对于一个大小为 <code>4</code> ， 包含 <code>4</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_factor = 4 / 4 = 1</span><br></pre></td></tr></table></figure>

<p>又比如说， 对于一个大小为 <code>512</code> ， 包含 <code>256</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_factor = 256 / 512 = 0.5</span><br></pre></td></tr></table></figure>

<h5 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h5><p>触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作</li>
<li>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</li>
</ul>
<p>触发 rehash 收缩条件：（TODO：待验证）</p>
<ul>
<li>当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</li>
</ul>
<h5 id="扩展哈希表"><a href="#扩展哈希表" class="headerlink" title="扩展哈希表"></a>扩展哈希表</h5><p>举个例子， 假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。 图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子。</li>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 <code>4</code> 改为了现在的 <code>8</code> 。</p>
<p><img src="/./assets/graphviz-93608325578e8e45848938ef420115bf2227639e.png" alt="graphviz-93608325578e8e45848938ef420115bf2227639e.png (721×533)"></p>
<p><img src="/./assets/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png" alt="graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png (721×678)"></p>
<p><img src="/./assets/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png" alt="graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png (721×676)"></p>
<p><img src="/./assets/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png" alt="graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png (721×517)"></p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>上一节说过， 扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 <code>ht[0]</code> 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 <code>ht[1]</code> ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>图 4-12 至图 4-17 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 <code>rehashidx</code> 属性是如何变化的。</p>
<p><img src="/./assets/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png" alt="graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png (721×678)"></p>
<p><img src="/./assets/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png" alt="graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png (721×524)"></p>
<p><img src="/./assets/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png" alt="graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png (721×528)"></p>
<p><img src="/./assets/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png" alt="graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png (721×609)"></p>
<p><img src="/./assets/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png" alt="graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png (721×676)"></p>
<p><img src="/./assets/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png" alt="graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png (721×517)"></p>
<h5 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h5><p>在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<p>在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删（delete）、改（update），查（find）在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找。</p>
<h3 id="字典-哈希表API"><a href="#字典-哈希表API" class="headerlink" title="字典&#x2F;哈希表API"></a>字典&#x2F;哈希表API</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>dictCreate</code></td>
<td align="left">创建一个新的字典。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictAdd</code></td>
<td align="left">将给定的键值对添加到字典里面。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictReplace</code></td>
<td align="left">将给定的键值对添加到字典里面， 如果键已经存在于字典，那么用新值取代原有的值。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictFetchValue</code></td>
<td align="left">返回给定键的值。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictGetRandomKey</code></td>
<td align="left">从字典中随机返回一个键值对。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictDelete</code></td>
<td align="left">从字典中删除给定键所对应的键值对。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictRelease</code></td>
<td align="left">释放给定字典，以及字典中包含的所有键值对。</td>
<td align="left">O(N) ， <code>N</code> 为字典包含的键值对数量。</td>
</tr>
</tbody></table>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合（intset）是集合键(Set)的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD numbers 1 3 5 7 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<h3 id="整数集合实现"><a href="#整数集合实现" class="headerlink" title="整数集合实现"></a>整数集合实现</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合元素<strong>唯一</strong>且<strong>升序排列</strong>。</p>
<p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code> 数组是整数集合的底层实现： 整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p><code>length</code> 是 <code>contents</code> 数组中元素的总个数。</p>
<p>虽然 <code>intset</code> 结构将 <code>contents</code> 属性声明为 <code>int8_t</code> 类型的数组， 但实际上 <code>contents</code> 数组并不保存任何 <code>int8_t</code> 类型的值 —— <code>contents</code> 数组的真正类型取决于 <code>encoding</code> 属性的值：</p>
<ul>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 那么 <code>contents</code> 就是一个 <code>int16_t</code> 类型的数组， 数组里的每个项都是一个 <code>int16_t</code> 类型的整数值 （最小值为 <code>-32,768</code> ，最大值为 <code>32,767</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT32</code> ， 那么 <code>contents</code> 就是一个 <code>int32_t</code> 类型的数组， 数组里的每个项都是一个 <code>int32_t</code> 类型的整数值 （最小值为 <code>-2,147,483,648</code> ，最大值为 <code>2,147,483,647</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 那么 <code>contents</code> 就是一个 <code>int64_t</code> 类型的数组， 数组里的每个项都是一个 <code>int64_t</code> 类型的整数值 （最小值为 <code>-9,223,372,036,854,775,808</code> ，最大值为 <code>9,223,372,036,854,775,807</code> ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li><code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 表示整数集合的底层实现为 <code>int16_t</code> 类型的数组， 而集合保存的都是 <code>int16_t</code> 类型的整数值。</li>
<li><code>length</code> 属性的值为 <code>5</code> ， 表示整数集合包含五个元素。</li>
<li><code>contents</code> 数组按从小到大的顺序保存着集合中的五个元素。</li>
<li>因为每个集合元素都是 <code>int16_t</code> 类型的整数值， 所以 <code>contents</code> 数组的大小等于 <code>sizeof(int16_t) * 5 = 16 * 5 = 80</code> 位。</li>
</ul>
<p><img src="/./assets/graphviz-acf7fe010d7b09c5d2500c72eb555863e67ad74f-1698850011048-11.png" alt="graphviz-acf7fe010d7b09c5d2500c72eb555863e67ad74f.png (514×234)"></p>
<p>图 6-2 展示了另一个整数集合示例：</p>
<ul>
<li><code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 表示整数集合的底层实现为 <code>int64_t</code> 类型的数组， 而数组中保存的都是 <code>int64_t</code> 类型的整数值。</li>
<li><code>length</code> 属性的值为 <code>4</code> ， 表示整数集合包含四个元素。</li>
<li><code>contents</code> 数组按从小到大的顺序保存着集合中的四个元素。</li>
<li>因为每个集合元素都是 <code>int64_t</code> 类型的整数值， 所以 <code>contents</code> 数组的大小为 <code>sizeof(int64_t) * 4 = 64 * 4 = 256</code> 位。</li>
</ul>
<p><img src="/./assets/graphviz-878c08b90e7bbd02863d3e5cad116b36785ea30e.png" alt="graphviz-878c08b90e7bbd02863d3e5cad116b36785ea30e.png (552×234)"></p>
<p>虽然 <code>contents</code> 数组保存的四个整数值中， 只有 <code>-2675256175807981027</code> 是真正需要用 <code>int64_t</code> 类型来保存的， 而其他的 <code>1</code> 、 <code>3</code> 、 <code>5</code> 三个值都可以用 <code>int16_t</code> 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 <code>int16_t</code> 数组的整数集合添加一个 <code>int64_t</code> 类型的整数值时， 整数集合已有的所有元素都会被转换成 <code>int64_t</code> 类型， 所以 <code>contents</code> 数组保存的四个整数值都是 <code>int64_t</code> 类型的， 不仅仅是 <code>-2675256175807981027</code> 。</p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>举个例子， 假设现在有一个 <code>INTSET_ENC_INT16</code> 编码的整数集合， 集合中包含三个 <code>int16_t</code> 类型的元素， 如图 6-3 所示。</p>
<p><img src="/./assets/graphviz-21955e71222114585926ca37959be5d948b9ad2b.png" alt="graphviz-21955e71222114585926ca37959be5d948b9ad2b.png (464×234)"></p>
<p>因为每个元素都占用 <code>16</code> 位空间， 所以整数集合底层数组的大小为 <code>3 * 16 = 48</code> 位， 图 6-4 展示了整数集合的三个元素在这 <code>48</code> 位里的位置。</p>
<p><img src="/./assets/graphviz-eac3e19de3f8dd9c40f2302c7b2d10e73983cd5c.png" alt="graphviz-eac3e19de3f8dd9c40f2302c7b2d10e73983cd5c.png (469×144)"></p>
<p>现在， 假设我们要将类型为 <code>int32_t</code> 的整数值 <code>65535</code> 添加到整数集合里面， 因为 <code>65535</code> 的类型 <code>int32_t</code> 比整数集合当前所有元素的类型都要长， 所以在将 <code>65535</code> 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 <code>65535</code> ， 整数集合需要分配四个元素的空间， 因为每个 <code>int32_t</code> 整数值需要占用 <code>32</code> 位空间， 所以在空间重分配之后， 底层数组的大小将是 <code>32 * 4 = 128</code> 位， 如图 6-5 所示。</p>
<p><img src="/./assets/graphviz-63f486a40c957eb449a5836555915601a1be61d6.png" alt="graphviz-63f486a40c957eb449a5836555915601a1be61d6.png (542×144)"></p>
<p>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 <code>1</code> 、 <code>2</code> 、 <code>3</code> 仍然是 <code>int16_t</code> 类型， 这些元素还保存在数组的前 <code>48</code> 位里面， 所以程序接下来要做的就是将这三个元素转换成 <code>int32_t</code> 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 <code>3</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第三， 所以它将被移动到 <code>contents</code> 数组的索引 <code>2</code> 位置上， 也即是数组 <code>64</code> 位至 <code>95</code> 位的空间内， 如图 6-6 所示。</p>
<p><img src="/./assets/graphviz-b8d54b0b6f077fd7a618a9fc198350cb3301fe8a.png" alt="graphviz-b8d54b0b6f077fd7a618a9fc198350cb3301fe8a.png (823×207)"></p>
<p>接着， 因为元素 <code>2</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第二， 所以它将被移动到 <code>contents</code> 数组的索引 <code>1</code> 位置上， 也即是数组的 <code>32</code> 位至 <code>63</code> 位的空间内， 如图 6-7 所示。</p>
<p><img src="/./assets/graphviz-851e799be7671b59d22c1360c757f70871b1460a.png" alt="graphviz-851e799be7671b59d22c1360c757f70871b1460a.png (671×207)"></p>
<p>之后， 因为元素 <code>1</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第一， 所以它将被移动到 <code>contents</code> 数组的索引 <code>0</code> 位置上， 也即是数组的 <code>0</code> 位至 <code>31</code> 位的空间内， 如图 6-8 所示。</p>
<p><img src="/./assets/graphviz-a6e1fc86a05aa7dab4284dbdb027cedb96a5259a.png" alt="graphviz-a6e1fc86a05aa7dab4284dbdb027cedb96a5259a.png (561×207)"></p>
<p>然后， 因为元素 <code>65535</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第四， 所以它将被添加到 <code>contents</code> 数组的索引 <code>3</code> 位置上， 也即是数组的 <code>96</code> 位至 <code>127</code> 位的空间内， 如图 6-9 所示。</p>
<p><img src="/./assets/graphviz-c0a4fd52c53de90a8b70888f89c7b39df564fc6b.png" alt="graphviz-c0a4fd52c53de90a8b70888f89c7b39df564fc6b.png (547×240)"></p>
<p>最后， 程序将整数集合 <code>encoding</code> 属性的值从 <code>INTSET_ENC_INT16</code> 改为 <code>INTSET_ENC_INT32</code> ， 并将 <code>length</code> 属性的值从 <code>3</code> 改为 <code>4</code> ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p><img src="/./assets/graphviz-a1be785cf70da6f653415d42642a25931656fe76.png" alt="graphviz-a1be785cf70da6f653415d42642a25931656fe76.png (415×234)"></p>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 <code>INTSET_ENC_INT16</code> 编码升级为 <code>INTSET_ENC_INT64</code> 编码， 或者从 <code>INTSET_ENC_INT32</code> 编码升级为 <code>INTSET_ENC_INT64</code> 编码， 升级的过程都和上面展示的升级过程类似。</p>
<blockquote>
<p>升级之后新元素的摆放位置</p>
</blockquote>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 <code>0</code> ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 <code>length-1</code> ）。</li>
</ul>
<h4 id="升级好处"><a href="#升级好处" class="headerlink" title="升级好处"></a>升级好处</h4><h5 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h5><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 <code>int16_t</code> 类型的数组来保存 <code>int16_t</code> 类型的值， 只使用 <code>int32_t</code> 类型的数组来保存 <code>int32_t</code> 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h5 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h5><p>当然， 要让一个数组可以同时保存 <code>int16_t</code> 、 <code>int32_t</code> 、 <code>int64_t</code> 三种类型的值， 最简单的做法就是直接使用 <code>int64_t</code> 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 <code>int16_t</code> 类型或者 <code>int32_t</code> 类型的值， 数组都需要使用 <code>int64_t</code> 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 <code>int16_t</code> 类型的值， 那么整数集合的底层实现就会一直是 <code>int16_t</code> 类型的数组， 只有在我们要将 <code>int32_t</code> 类型或者 <code>int64_t</code> 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h4 id="降级？"><a href="#降级？" class="headerlink" title="降级？"></a>降级？</h4><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 <code>int64_t</code> 类型来保存的元素 <code>4294967295</code> 删除了， 整数集合的编码仍然会维持 <code>INTSET_ENC_INT64</code> ， 底层数组也仍然会是 <code>int64_t</code> 类型的， 如图 6-12 所示。</p>
<p><img src="/./assets/graphviz-66791e1245ddf710a39196b431ac5c90c287c64e.png" alt="graphviz-66791e1245ddf710a39196b431ac5c90c287c64e.png (548×234)"></p>
<p><img src="/./assets/graphviz-d3355e08bf0d2f1639075046eb80c940da7e5fc5.png" alt="graphviz-d3355e08bf0d2f1639075046eb80c940da7e5fc5.png (433×234)"></p>
<hr>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><ul>
<li><p>跳跃表是有序集合（zset）的底层实现之一， 除此之外它在 Redis 中没有其他应用。</p>
</li>
<li><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能用跳表进行高效的范围查询，也能用哈希表进行高效单点查询。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Zset 对象在使用跳表作为数据结构的时候，是使用由「哈希表+跳表」组成的 struct zset，但是我们讨论的时候，都会说跳表是 Zset 对象的底层数据结构，而不会提及哈希表，是因为 struct zset 中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。</li>
</ul>
<h3 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h3><p>Redis 的跳跃表由 <code>zskiplistNode</code> 和 <code>zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于表示整个跳表，其中保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p>
<ul>
<li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code> 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<h4 id="跳表节点"><a href="#跳表节点" class="headerlink" title="跳表节点"></a>跳表节点</h4><p>跳跃表节点的实现由 <code>zskiplistNode</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>跳跃表节点的 <code>level</code> 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 <code>1</code> 层、 <code>3</code> 层和 <code>5</code> 层的节点， 因为 C 语言的数组索引总是从 <code>0</code> 开始的， 所以节点的第一层是 <code>level[0]</code> ， 而第二层是 <code>level[1]</code> ， 以此类推。</p>
<p><img src="/./assets/graphviz-1983e65fd518acd94a59d64f018bfa4d83655cb6.png" alt="img"></p>
<h4 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针（<code>level[i].forward</code> 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：</p>
<ol>
<li>迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。</li>
<li>在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。</li>
<li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 <code>NULL</code> ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</li>
</ol>
<p><img src="/./assets/graphviz-e252c0a9575f171b9721162311df23889699cac9.png" alt="img"></p>
<h4 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h4><p>层的跨度（<code>level[i].span</code> 属性）用于记录同一层相邻两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 <code>NULL</code> 的所有前进指针的跨度都为 <code>0</code> ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 <code>3.0</code> 、 成员对象为 <code>o3</code> 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 <code>3</code> ， 所以目标节点在跳跃表中的排位为 <code>3</code> 。</p>
<p><img src="/./assets/graphviz-b5f725abb2be0255dce02cc1b9b404595edff320.png" alt="graphviz-b5f725abb2be0255dce02cc1b9b404595edff320.png (699×543)"></p>
<p>再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 <code>2.0</code> 、 成员对象为 <code>o2</code> 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 <code>1</code> 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。</p>
<p><img src="/./assets/graphviz-35aacc5673063633ae0decd516137022c304ac1b.png" alt="img"></p>
<h4 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h4><p>节点的后退指针（<code>backward</code> 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 <code>tail</code> 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 <code>NULL</code> 的后退指针， 于是访问结束。</p>
<p><img src="/./assets/graphviz-35029fe9a9dbed7001f6fee063c0b376bca6e54d.png" alt="img"></p>
<h4 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h4><p>节点的分值（<code>score</code> 属性）是一个 <code>double</code> 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（<code>obj</code> 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<p>举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 <code>10086.0</code> ， 但保存成员对象 <code>o1</code> 的节点却排在保存成员对象 <code>o2</code> 和 <code>o3</code> 的节点之前， 而保存成员对象 <code>o2</code> 的节点又排在保存成员对象 <code>o3</code> 的节点之前， 由此可见， <code>o1</code> 、 <code>o2</code> 、 <code>o3</code> 三个成员对象在字典中的排序为 <code>o1 &lt;= o2 &lt;= o3</code> 。</p>
<p><img src="/./assets/graphviz-2eca5f315d20b6ceb145dbce294dc00f979605f2.png" alt="graphviz-2eca5f315d20b6ceb145dbce294dc00f979605f2.png (772×543)"></p>
<h3 id="跳表API"><a href="#跳表API" class="headerlink" title="跳表API"></a>跳表API</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zslCreate</code></td>
<td align="left">创建一个新的跳跃表。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>zslFree</code></td>
<td align="left">释放给定跳跃表，以及表中包含的所有节点。</td>
<td align="left">O(N) ， <code>N</code> 为跳跃表的长度。</td>
</tr>
<tr>
<td align="left"><code>zslInsert</code></td>
<td align="left">将包含给定成员和分值的新节点添加到跳跃表中。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslDelete</code></td>
<td align="left">删除跳跃表中包含给定成员和分值的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslGetRank</code></td>
<td align="left">返回包含给定成员和分值的节点在跳跃表中的排位。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslGetElementByRank</code></td>
<td align="left">返回跳跃表在给定排位上的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslIsInRange</code></td>
<td align="left">给定一个分值范围（range）， 比如 <code>0</code> 到 <code>15</code> ， <code>20</code> 到 <code>28</code> ，诸如此类， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 <code>1</code> ，否则返回 <code>0</code> 。</td>
<td align="left">通过跳跃表的表头节点和表尾节点， 这个检测可以用 O(1) 复杂度完成。</td>
</tr>
<tr>
<td align="left"><code>zslFirstInRange</code></td>
<td align="left">给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) 。 <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslLastInRange</code></td>
<td align="left">给定一个分值范围， 返回跳跃表中最后一个符合这个范围的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) 。 <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByScore</code></td>
<td align="left">给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td align="left">O(N) ， <code>N</code> 为被删除节点数量。</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByRank</code></td>
<td align="left">给定一个排位范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td align="left">O(N) ， <code>N</code> 为被删除节点数量。</td>
</tr>
</tbody></table>
<h3 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<p>举个例子，下图有个 3 层级的跳表。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png"></p>
<p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p>
<ul>
<li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li>
<li>但是该层的下一个节点是空节点（ leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li>
<li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li>
<li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li>
</ul>
<h3 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p>举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2802786ab4f52c1e248904e5cef33a74.png"></p>
<p>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。</p>
<p>**跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)**。</p>
<p>下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/cdc14698f629c74bf5a239cc8a611aeb.png"></p>
<blockquote>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p>
</blockquote>
<p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p>
<p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<p>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p>
<p>如下代码，创建跳表时，头节点的 level 数组有 ZSKIPLIST_MAXLEVEL个元素（层），节点不存储任何 member 和 score 值，level 数组元素的 forward 都指向NULL， span值都为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ZSKIPLIST_MAXLEVEL 定义的是最高的层数，Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32。</p>
<h3 id="为什么用跳表而不用平衡树？"><a href="#为什么用跳表而不用平衡树？" class="headerlink" title="为什么用跳表而不用平衡树？"></a>为什么用跳表而不用平衡树？</h3><p>这里插一个常见的面试题：为什么 Zset 的实现用跳表而不用平衡树（如 AVL树、红黑树等）？</p>
<p>简单翻译一下，主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p>
<ul>
<li>它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。</li>
<li>Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</li>
<li>它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。</li>
</ul>
<p>我再详细补充点：</p>
<ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p>
<p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p>
<p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p>
<h3 id="quicklist-结构设计"><a href="#quicklist-结构设计" class="headerlink" title="quicklist 结构设计"></a>quicklist 结构设计</h3><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">//quicklist的链表头</span></span><br><span class="line">    <span class="comment">//quicklist的链表尾</span></span><br><span class="line">    quicklistNode *tail; </span><br><span class="line">    <span class="comment">//所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNodes的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;       </span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p>接下来看看，quicklistNode 的结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="comment">//下一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="comment">//quicklistNode指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;              </span><br><span class="line">    <span class="comment">//压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;                </span><br><span class="line">    <span class="comment">//压缩列表的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;        <span class="comment">//ziplist中的元素个数 </span></span><br><span class="line">    ....</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p>
<p>我画了一张图，方便你理解 quicklist 数据结构。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png"></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p><strong>我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p>
<h3 id="listpack-结构设计"><a href="#listpack-结构设计" class="headerlink" title="listpack 结构设计"></a>listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p>
<p>我们先看看 listpack 结构：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/4d2dc376b5fd68dae70d9284ae82b73a.png"></p>
<p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p>
<p>每个 listpack 节点结构如下：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png"></p>
<p>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<hr>
<blockquote>
<p>压缩列表的entry为什么要保存prevlen呢？listpack改成len之后不会影响功能吗？</p>
</blockquote>
<p>压缩列表的 entry 保存 prevlen 是为了实现节点从后往前遍历，知道前一个节点的长度，就可以计算前一个节点的偏移量。</p>
<p>listpack 一样可以支持从后往前遍历的。详细的算法可以看：<a href="https://github.com/antirez/listpack/blob/master/listpack.c">https://github.com/antirez/listpack/blob/master/listpack.c</a> 里的lpDecodeBacklen函数，lpDecodeBacklen 函数就可以从当前列表项起始位置的指针开始，向左逐个字节解析，得到前一项的 entry-len 值。</p>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::vector::emplace_back</title>
    <url>/2024/02/19/note/cpp/stl/emplace_back/</url>
    <content><![CDATA[<p>emplace_back可传入对象的参数列表，在容器末尾的位置用 placement new 原地构造，连move都省去了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">President</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::string country;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(std::string p_name, std::string p_country, <span class="type">int</span> p_year)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(p_country)), <span class="built_in">year</span>(p_year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; being constructed.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">President</span>(President&amp;&amp; other)</span><br><span class="line">        : <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">country</span>(std::<span class="built_in">move</span>(other.country)), <span class="built_in">year</span>(other.year)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot; being moved.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    President&amp; <span class="keyword">operator</span>=(<span class="type">const</span> President&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;President&gt; elections;</span><br><span class="line">    elections.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;emplace_back obj&#x27;s args:\n&quot;</span>;</span><br><span class="line">    elections.<span class="built_in">emplace_back</span>(<span class="string">&quot;Nelson&quot;</span>, <span class="string">&quot;South Africa&quot;</span>, <span class="number">1994</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果emplace_back一个对象，则是先构造，后移动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nemplace_back an obj:\n&quot;</span>;</span><br><span class="line">    elections.<span class="built_in">emplace_back</span>(<span class="built_in">President</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;usa&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    std::vector&lt;President&gt; reElections;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\npush_back:\n&quot;</span>;</span><br><span class="line">    reElections.<span class="built_in">push_back</span>(<span class="built_in">President</span>(<span class="string">&quot;Franklin&quot;</span>, <span class="string">&quot;the USA&quot;</span>, <span class="number">1936</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emplace_back obj&#x27;s args:</span><br><span class="line">Nelson being constructed.</span><br><span class="line"></span><br><span class="line">emplace_back an obj:</span><br><span class="line">aaa being constructed.</span><br><span class="line">aaa being moved.</span><br><span class="line"></span><br><span class="line">push_back:</span><br><span class="line">Franklin being constructed.</span><br><span class="line">Franklin being moved.</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据类型</title>
    <url>/2024/02/19/note/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>用来存这些类型的值：</p>
<ul>
<li>字节字符串</li>
<li>整数</li>
<li>浮点数</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h3><table>
<thead>
<tr>
<th>Command</th>
<th align="left">Example use and description</th>
</tr>
</thead>
<tbody><tr>
<td>INCR</td>
<td align="left">INCR key-name—Increments the value stored at the key by 1</td>
</tr>
<tr>
<td>DECR</td>
<td align="left">DECR key-name—Decrements the value stored at the key by 1</td>
</tr>
<tr>
<td>INCRBY</td>
<td align="left">INCRBY key-name amount—Increments the value stored at the key by the provided integer value</td>
</tr>
<tr>
<td>DECRBY</td>
<td align="left">DECRBY key-name amount—Decrements the value stored at the key by the provided integer value</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td align="left">INCRBYFLOAT key-name amount—Increments the value stored at the key by the provided float value (available in &gt;&#x3D; Redis 2.6)</td>
</tr>
</tbody></table>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Example use and description</th>
</tr>
</thead>
<tbody><tr>
<td>APPEND</td>
<td>APPEND key-name value—Concatenates the provided value to the string already stored at the given key</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>GETRANGE key-name start end—Fetches the substring, including all characters from the start offset to the end offset, inclusive</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>SETRANGE key-name offset value—Sets the substring starting at the provided offset to the given value</td>
</tr>
<tr>
<td>GETBIT</td>
<td>GETBIT key-name offset—Treats the byte string as a bit string, and returns the value of the bit in the string at the provided bit offset</td>
</tr>
<tr>
<td>SETBIT</td>
<td>SETBIT key-name offset value—Treats the byte string as a bit string, and sets the value of the bit in the string at the provided bit offset</td>
</tr>
<tr>
<td>BITCOUNT</td>
<td>BITCOUNT key-name [start end]—Counts the number of 1 bits in the string, optionally starting and finishing at the provided byte offsets</td>
</tr>
<tr>
<td>BITOP</td>
<td>BITOP operation dest-key key-name [key-name …]—Performs one of the bitwise operations, AND , OR, XOR, or NOT , on the strings provided, storing the result in the destination key</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>GETRANGE</strong> AND <strong>SUBSTR</strong> In the past, GETRANGE was named SUBSTR, and the<br>Python client continues to use the substr() method name to fetch ranges from<br>the string. When using a version of Redis later than 2.6, you should use the get-<br>range() method, and use substr() for Redis versions before 2.6.</p>
</blockquote>
<blockquote>
<p>When writing to strings using SETRANGE and SETBIT , if the STRING wasn’t previously<br>long enough, Redis will automatically extend the STRING with nulls before updating<br>and writing the new data. When reading STRINGs with GETRANGE, any request for data<br>beyond the end of the STRING won’t be returned, but when reading bits with GETBIT ,<br>any bit beyond the end of the STRING is considered zero.</p>
</blockquote>
<p><img src="/./assets/image-20231108132049463.png" alt="image-20231108132049463"></p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="普通字符串的基本操作："><a href="#普通字符串的基本操作：" class="headerlink" title="普通字符串的基本操作："></a>普通字符串的基本操作：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置 key-value 类型的值</span><br><span class="line">&gt; SET name lin</span><br><span class="line">OK</span><br><span class="line"># 根据 key 获得对应的 value</span><br><span class="line">&gt; GET name</span><br><span class="line">&quot;lin&quot;</span><br><span class="line"># 判断某个 key 是否存在</span><br><span class="line">&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line"># 返回 key 所储存的字符串值的长度</span><br><span class="line">&gt; STRLEN name</span><br><span class="line">(integer) 3</span><br><span class="line"># 删除某个 key 对应的值</span><br><span class="line">&gt; DEL name</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h3 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置 :"></a>批量设置 :</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 批量设置 key-value 类型的值</span><br><span class="line">&gt; MSET key1 value1 key2 value2 </span><br><span class="line">OK</span><br><span class="line"># 批量获取多个 key 对应的 value</span><br><span class="line">&gt; MGET key1 key2 </span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="计数器（字符串的内容为整数的时候可以使用）："><a href="#计数器（字符串的内容为整数的时候可以使用）：" class="headerlink" title="计数器（字符串的内容为整数的时候可以使用）："></a>计数器（字符串的内容为整数的时候可以使用）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置 key-value 类型的值</span><br><span class="line">&gt; SET number 0</span><br><span class="line">OK</span><br><span class="line"># 将 key 中储存的数字值增一</span><br><span class="line">&gt; INCR number</span><br><span class="line">(integer) 1</span><br><span class="line"># 将key中存储的数字值加 10</span><br><span class="line">&gt; INCRBY number 10</span><br><span class="line">(integer) 11</span><br><span class="line"># 将 key 中储存的数字值减一</span><br><span class="line">&gt; DECR number</span><br><span class="line">(integer) 10</span><br><span class="line"># 将key中存储的数字值键 10</span><br><span class="line">&gt; DECRBY number 10</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h3 id="过期（默认为永不过期）："><a href="#过期（默认为永不过期）：" class="headerlink" title="过期（默认为永不过期）："></a>过期（默认为永不过期）：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间）</span><br><span class="line">&gt; EXPIRE name  60 </span><br><span class="line">(integer) 1</span><br><span class="line"># 查看数据还有多久过期</span><br><span class="line">&gt; TTL name </span><br><span class="line">(integer) 51</span><br><span class="line"></span><br><span class="line">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span><br><span class="line">&gt; SET key  value EX 60</span><br><span class="line">OK</span><br><span class="line">&gt; SETEX key  60 value</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="不存在就插入："><a href="#不存在就插入：" class="headerlink" title="不存在就插入："></a>不存在就插入：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不存在就插入（not exists）</span><br><span class="line">&gt;SETNX key value</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>使用 String 来缓存对象有两种方式：</p>
<ul>
<li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li>
<li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li>
</ul>
<h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p>比如计算文章的阅读量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化文章的阅读量</span><br><span class="line">&gt; SET aritcle:readcount:1001 0</span><br><span class="line">OK</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 1</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 2</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 3</span><br><span class="line"># 获取对应文章的阅读量</span><br><span class="line">&gt; GET aritcle:readcount:1001</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p>
<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p>
<h3 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h3><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>分布式系统单独存储 Session 流程图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session1.png"></p>
<p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<p>分布式系统使用同一个 Redis 存储 Session 流程图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session2.png"></p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>列表存储有序字符串，两头增删</p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul>
<li>工作队列</li>
<li>最近浏览过的文章</li>
<li>收藏</li>
</ul>
<h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="left">Command</th>
<th>Example use and description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RPUSH</td>
<td>RPUSH key-name value [value …]—Pushes the value(s) onto the right end of the list</td>
</tr>
<tr>
<td align="left">LPUSH</td>
<td>LPUSH key-name value [value …]—Pushes the value(s) onto the left end of the list</td>
</tr>
<tr>
<td align="left">RPOP</td>
<td>RPOP key-name—Removes and returns the rightmost item from the list</td>
</tr>
<tr>
<td align="left">LPOP</td>
<td>LPOP key-name—Removes and returns the leftmost item from the list</td>
</tr>
<tr>
<td align="left">LINDEX</td>
<td>LINDEX key-name offset—Returns the item at the given offset</td>
</tr>
<tr>
<td align="left">LRANGE</td>
<td>LRANGE key-name start end—Returns the items in the list at the offsets from start to end, inclusive</td>
</tr>
<tr>
<td align="left">LTRIM</td>
<td>LTRIM key-name start end—Trims the list to only include items at indices between start and end, inclusive</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"># 将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span><br><span class="line">LRANGE key start stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。</p>
<p>我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。</p>
<h5 id="1、如何满足消息保序需求？"><a href="#1、如何满足消息保序需求？" class="headerlink" title="1、如何满足消息保序需求？"></a>1、如何满足消息保序需求？</h5><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" title="" alt="" width="792">

<ul>
<li><p>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</p>
</li>
<li><p>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</p>
</li>
</ul>
<p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p>
<p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p>
<p>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p>
<p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p>
<img title="" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="" width="774">

<h5 id="2、如何处理重复的消息？"><a href="#2、如何处理重复的消息？" class="headerlink" title="2、如何处理重复的消息？"></a>2、如何处理重复的消息？</h5><p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p>
<ul>
<li>每个消息都有一个全局的 ID。</li>
<li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li>
</ul>
<p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p>
<p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; LPUSH mq &quot;111000102:stock:99&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="3、如何保证消息可靠性？"><a href="#3、如何保证消息可靠性？" class="headerlink" title="3、如何保证消息可靠性？"></a>3、如何保证消息可靠性？</h5><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p>
<p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<h5 id="List-作为消息队列有什么缺陷？"><a href="#List-作为消息队列有什么缺陷？" class="headerlink" title="List 作为消息队列有什么缺陷？"></a>List 作为消息队列有什么缺陷？</h5><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p>
<p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p>
<p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 存储一个哈希表key的键值</span><br><span class="line">HSET key field value   </span><br><span class="line"># 获取哈希表key对应的field键值</span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line"># 在一个哈希表key中存储多个键值对</span><br><span class="line">HMSET key field value [field value...] </span><br><span class="line"># 批量获取哈希表key中多个field键值</span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"># 删除哈希表key中的field键值</span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"></span><br><span class="line"># 返回哈希表key中field的数量</span><br><span class="line">HLEN key       </span><br><span class="line"># 返回哈希表key中所有的键值</span><br><span class="line">HGETALL key </span><br><span class="line"></span><br><span class="line"># 为哈希表key中field键的值加上增量n</span><br><span class="line">HINCRBY key field n             </span><br></pre></td></tr></table></figure>

<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象-1"><a href="#缓存对象-1" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%B4%AD%E7%89%A9%E8%BD%A6.png" title="" alt="" width="345">

<p>涉及的命令如下：</p>
<ul>
<li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li>
<li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li>
</ul>
<p>当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>The max size of a Redis set is 2^32 - 1 (4,294,967,295) members.</p>
<p>支持多个集合取交集、并集、差集。</p>
<h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><p>Set常用操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SADD key member [member ...]</span><br><span class="line"># 从集合key中删除元素</span><br><span class="line">SREM key member [member ...] </span><br><span class="line"># 获取集合key中所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line"># 获取集合key中的元素个数</span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"># 判断member元素是否存在于集合key中</span><br><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line"># 从集合key中随机选出count个元素，元素不从key中删除</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"># 从集合key中随机选出count个元素，元素从key中删除</span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure>

<p>Set运算操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><p>去重</p>
</li>
<li><p>集合间运算</p>
</li>
</ul>
<p>这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># uid:1 用户对文章 article:1 点赞</span><br><span class="line">&gt; SADD article:1 uid:1</span><br><span class="line">(integer) 1</span><br><span class="line"># uid:2 用户对文章 article:1 点赞</span><br><span class="line">&gt; SADD article:1 uid:2</span><br><span class="line">(integer) 1</span><br><span class="line"># uid:3 用户对文章 article:1 点赞</span><br><span class="line">&gt; SADD article:1 uid:3</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><code>uid:1</code> 取消了对 article:1 文章点赞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>获取 article:1 文章所有点赞用户 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SMEMBERS article:1</span><br><span class="line">1) &quot;uid:3&quot;</span><br><span class="line">2) &quot;uid:2&quot;</span><br></pre></td></tr></table></figure>

<p>获取 article:1 文章的点赞用户数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SCARD article:1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SISMEMBER article:1 uid:1</span><br><span class="line">(integer) 0  # 返回0说明没点赞，返回1则说明点赞了</span><br></pre></td></tr></table></figure>

<h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span><br><span class="line">&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(integer) 5</span><br><span class="line"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span><br><span class="line">&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取共同关注</span><br><span class="line">&gt; SINTER uid:1 uid:2</span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;9&quot;</span><br></pre></td></tr></table></figure>

<p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SDIFF uid:1 uid:2</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; SISMEMBER uid:1 5</span><br><span class="line">(integer) 1 # 返回0，说明关注了</span><br><span class="line">&gt; SISMEMBER uid:2 5</span><br><span class="line">(integer) 0 # 返回0，说明没关注</span><br></pre></td></tr></table></figure>

<h3 id="抽奖"><a href="#抽奖" class="headerlink" title="抽奖"></a>抽奖</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 抽取 1 个一等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky 1</span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line"># 抽取 2 个二等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky 2</span><br><span class="line">1) &quot;Mark&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br><span class="line"># 抽取 3 个三等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky 3</span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>

<p>如果不允许重复中奖，可以使用 SPOP 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 抽取一等奖1个</span><br><span class="line">&gt; SPOP lucky 1</span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line"># 抽取二等奖2个</span><br><span class="line">&gt; SPOP lucky 2</span><br><span class="line">1) &quot;Jerry&quot;</span><br><span class="line">2) &quot;Mark&quot;</span><br><span class="line"># 抽取三等奖3个</span><br><span class="line">&gt; SPOP lucky 3</span><br><span class="line">1) &quot;John&quot;</span><br><span class="line">2) &quot;Sean&quot;</span><br><span class="line">3) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure>

<h1 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h1><p>有序集合。</p>
<blockquote>
<p>A Redis sorted set is a collection of unique strings (members) ordered by an associated score. When more than one string has the same score, the strings are ordered lexicographically.</p>
</blockquote>
<h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li><p>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用 <strong>压缩列表(ziplist)</strong> 作为 Zset 类型的底层数据结构；</p>
<ul>
<li><pre><code class="python"># redis.conf

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；</span><br><span class="line"></span><br><span class="line">**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**</span><br><span class="line"></span><br><span class="line">哈希表维护redis对象-&gt;分值映射，实现O(1)复杂度查找redis对象的分值；</span><br><span class="line"></span><br><span class="line">跳表维护分值-&gt;redis对象的映射，分值有序存储，实现有序集合。</span><br><span class="line"></span><br><span class="line">&gt;  * The elements are added to a hash table mapping Redis objects to scores.</span><br><span class="line">&gt; </span><br><span class="line">&gt;  * At the same time the elements are added to a skip list mapping scores</span><br><span class="line">&gt; </span><br><span class="line">&gt;  * to Redis objects (so objects are sorted by scores in this &quot;view&quot;).</span><br><span class="line"></span><br><span class="line">## 常用命令</span><br><span class="line"></span><br><span class="line">Zset 常用操作：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="往有序集合key中加入带分值元素"><a href="#往有序集合key中加入带分值元素" class="headerlink" title="往有序集合key中加入带分值元素"></a>往有序集合key中加入带分值元素</h1><p>ZADD key score member [[score member]…]   </p>
<h1 id="往有序集合key中删除元素"><a href="#往有序集合key中删除元素" class="headerlink" title="往有序集合key中删除元素"></a>往有序集合key中删除元素</h1><p>ZREM key member [member…]                 </p>
<h1 id="返回有序集合key中元素member的分值"><a href="#返回有序集合key中元素member的分值" class="headerlink" title="返回有序集合key中元素member的分值"></a>返回有序集合key中元素member的分值</h1><p>ZSCORE key member</p>
<h1 id="获取member的排名（从0开始）"><a href="#获取member的排名（从0开始）" class="headerlink" title="获取member的排名（从0开始）"></a>获取member的排名（从0开始）</h1><p>ZRANK key member</p>
<h1 id="返回有序集合key中元素个数"><a href="#返回有序集合key中元素个数" class="headerlink" title="返回有序集合key中元素个数"></a>返回有序集合key中元素个数</h1><p>ZCARD key </p>
<h1 id="为有序集合key中元素member的分值加上increment"><a href="#为有序集合key中元素member的分值加上increment" class="headerlink" title="为有序集合key中元素member的分值加上increment"></a>为有序集合key中元素member的分值加上increment</h1><p>ZINCRBY key increment member </p>
<h1 id="正序获取有序集合key从start下标到stop下标的元素"><a href="#正序获取有序集合key从start下标到stop下标的元素" class="headerlink" title="正序获取有序集合key从start下标到stop下标的元素"></a>正序获取有序集合key从start下标到stop下标的元素</h1><p>ZRANGE key start stop [WITHSCORES]</p>
<h1 id="倒序获取有序集合key从start下标到stop下标的元素"><a href="#倒序获取有序集合key从start下标到stop下标的元素" class="headerlink" title="倒序获取有序集合key从start下标到stop下标的元素"></a>倒序获取有序集合key从start下标到stop下标的元素</h1><p>ZREVRANGE key start stop [WITHSCORES]</p>
<h1 id="返回有序集合中指定分数区间内的成员，分数由低到高排序。"><a href="#返回有序集合中指定分数区间内的成员，分数由低到高排序。" class="headerlink" title="返回有序集合中指定分数区间内的成员，分数由低到高排序。"></a>返回有序集合中指定分数区间内的成员，分数由低到高排序。</h1><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p>
<h1 id="返回指定成员区间内的成员，按字典正序排列-分数必须相同。"><a href="#返回指定成员区间内的成员，按字典正序排列-分数必须相同。" class="headerlink" title="返回指定成员区间内的成员，按字典正序排列, 分数必须相同。"></a>返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</h1><p>ZRANGEBYLEX key min max [LIMIT offset count]</p>
<h1 id="返回指定成员区间内的成员，按字典倒序排列-分数必须相同"><a href="#返回指定成员区间内的成员，按字典倒序排列-分数必须相同" class="headerlink" title="返回指定成员区间内的成员，按字典倒序排列, 分数必须相同"></a>返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</h1><p>ZREVRANGEBYLEX key max min [LIMIT offset count]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="并集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"><a href="#并集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积" class="headerlink" title="并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"></a>并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</h1><p>ZUNIONSTORE destkey numberkeys key [key…] </p>
<h1 id="交集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"><a href="#交集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积" class="headerlink" title="交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"></a>交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</h1><p>ZINTERSTORE destkey numberkeys key [key…]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># Connect to local Redis instance</span><br><span class="line">r = redis.Redis()</span><br><span class="line"></span><br><span class="line"># Define the name of your sorted set</span><br><span class="line">zset_name = &#x27;myzset&#x27;</span><br><span class="line"></span><br><span class="line"># ZADD: Add members to a sorted set, or update its score if it already exists</span><br><span class="line">r.zadd(zset_name, &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;)</span><br><span class="line"></span><br><span class="line"># ZRANGE: Get a range of members in a sorted set, by index. -1 means the end of range.</span><br><span class="line"># Output: [b&#x27;one&#x27;, b&#x27;two&#x27;, b&#x27;three&#x27;]</span><br><span class="line">print(r.zrange(zset_name, 0, -1))  </span><br><span class="line"></span><br><span class="line"># ZRANK: Determine the index of a member in a sorted set</span><br><span class="line">print(r.zrank(zset_name, &#x27;one&#x27;))  # Output: 0</span><br><span class="line"></span><br><span class="line"># ZREM: Remove one or more members from a sorted set</span><br><span class="line">r.zrem(zset_name, &#x27;one&#x27;)</span><br><span class="line"></span><br><span class="line"># ZSCORE: Get the score associated with the given member in a sorted set</span><br><span class="line">print(r.zscore(zset_name, &#x27;two&#x27;))  # Output: 2.0</span><br><span class="line"></span><br><span class="line"># ZINCRBY: Increment the score of a member in a sorted set</span><br><span class="line">r.zincrby(zset_name, 1, &#x27;two&#x27;)</span><br><span class="line"></span><br><span class="line"># ZREVRANGE: Return a range of members in a sorted set, by index, with scores ordered from high to low.</span><br><span class="line"># Descending lexicographical order is used for elements with equal score, so &#x27;tw&#x27; is left to &#x27;th&#x27;</span><br><span class="line">print(r.zrevrange(zset_name, 0, -1))  # Output: [b&#x27;two&#x27;, b&#x27;three&#x27;]</span><br><span class="line"></span><br><span class="line"># ZCOUNT: Count the members in a sorted set with scores within the given values</span><br><span class="line">print(r.zcount(zset_name, 1, 3))  # Output: 2</span><br><span class="line"></span><br><span class="line"># ZCARD: Get the number of members in a sorted set</span><br><span class="line">print(r.zcard(zset_name))  # Output: 2</span><br><span class="line"></span><br><span class="line"># ZREMRANGEBYRANK: Remove all members in a sorted set within the given indexes</span><br><span class="line">r.zremrangebyrank(zset_name, 0, 1)</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># arcticle:1 文章获得了200个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 200 arcticle:1</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:2 文章获得了40个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 40 arcticle:2</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:3 文章获得了100个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 100 arcticle:3</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:4 文章获得了50个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 50 arcticle:4</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:5 文章获得了150个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 150 arcticle:5</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZINCRBY user:xiaolin:ranking 1 arcticle:4</span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure>

<p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZSCORE user:xiaolin:ranking arcticle:4</span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure>

<p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># WITHSCORES 表示把 score 也显示出来</span><br><span class="line">&gt; ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span><br><span class="line">1) &quot;arcticle:1&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:3&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span><br><span class="line">1) &quot;arcticle:3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:1&quot;</span><br><span class="line">6) &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h3 id="电话或姓名排序"><a href="#电话或姓名排序" class="headerlink" title="电话或姓名排序"></a>电话或姓名排序</h3><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p>
<h4 id="电话排序"><a href="#电话排序" class="headerlink" title="电话排序"></a>电话排序</h4><p>我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZADD phone 0 13100111100 0 13110114300 0 13132110901 </span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZADD phone 0 13200111100 0 13210414300 0 13252110901 </span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZADD phone 0 13300111100 0 13310414300 0 13352110901 </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>获取所有号码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line">1) &quot;13100111100&quot;</span><br><span class="line">2) &quot;13110114300&quot;</span><br><span class="line">3) &quot;13132110901&quot;</span><br><span class="line">4) &quot;13200111100&quot;</span><br><span class="line">5) &quot;13210414300&quot;</span><br><span class="line">6) &quot;13252110901&quot;</span><br><span class="line">7) &quot;13300111100&quot;</span><br><span class="line">8) &quot;13310414300&quot;</span><br><span class="line">9) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>

<p>获取 132 号段的号码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [132 (133</span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br></pre></td></tr></table></figure>

<p>获取132、133号段的号码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [132 (134</span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br><span class="line">4) &quot;13300111100&quot;</span><br><span class="line">5) &quot;13310414300&quot;</span><br><span class="line">6) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>

<h4 id="姓名排序"><a href="#姓名排序" class="headerlink" title="姓名排序"></a>姓名排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua </span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<p>获取所有人的名字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names - +</span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br><span class="line">3) &quot;Bluetuo&quot;</span><br><span class="line">4) &quot;Gaodeng&quot;</span><br><span class="line">5) &quot;Jake&quot;</span><br><span class="line">6) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure>

<p>获取名字中大写字母A开头的所有人：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [A (B</span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br></pre></td></tr></table></figure>

<p>获取名字中大写字母 C 到 Z 的所有人：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [C [Z</span><br><span class="line">1) &quot;Gaodeng&quot;</span><br><span class="line">2) &quot;Jake&quot;</span><br><span class="line">3) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure>

<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/bitmap.png" title="" alt="" width="695">

<h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>用 String 类型。</p>
<h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><p>bitmap 基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置值，其中value只能是 0 和 1</span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line"># 获取值</span><br><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line"># 获取指定范围内值为 1 的个数</span><br><span class="line"># start 和 end 以字节为单位</span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure>

<p>bitmap 运算操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">  AND 与运算 &amp;</span><br><span class="line">  OR 或运算 |</span><br><span class="line">  XOR 异或 ^</span><br><span class="line">  NOT 取反 ~</span><br><span class="line"># result 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定value(0/1)的位置</span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h2><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p>
<h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p>
<p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p>
<p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETBIT uid:sign:100:202206 2 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户 6 月 3 日是否签到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GETBIT uid:sign:100:202206 2 </span><br></pre></td></tr></table></figure>

<p>第三步，统计该用户在 6 月份的签到次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BITCOUNT uid:sign:100:202206</span><br></pre></td></tr></table></figure>

<p>这样，我们就知道该用户在 6 月份的签到情况了。</p>
<blockquote>
<p>如何统计这个月首次打卡时间呢？</p>
</blockquote>
<p>Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。</p>
<p>在默认情况下， 命令将检测整个位图， 用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID &#x3D; 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BITPOS uid:sign:100:202206 1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1 。</p>
<h3 id="判断用户登陆状态"><a href="#判断用户登陆状态" class="headerlink" title="判断用户登陆状态"></a>判断用户登陆状态</h3><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<p>只需要一个 key &#x3D; login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。 5000 万用户只需要 6 MB 的空间。</p>
<p>假如我们要判断 ID &#x3D; 10086 的用户的登陆情况：</p>
<p>第一步，执行以下指令，表示用户已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GETBIT login_status 10086</span><br></pre></td></tr></table></figure>

<p>第三步，登出，将 offset 对应的 value 设置成 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure>

<h3 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h3><p>如何统计出这连续 7 天连续打卡用户总数呢？</p>
<p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p>
<p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p>
<p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p>
<p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p>
<p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p>
<ul>
<li><code>operation</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li>
</ul>
<p>假设要统计 3 天连续打卡的用户数，则是将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计，如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line"># 统计 bit 位 =  1 的个数</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure>

<p>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8&#x2F;8&#x2F;1024&#x2F;1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>消息队列。 </p>
<p>TODO</p>
<p>针对 Redis 是否适合做消息队列，关键看你的业务场景：</p>
<ul>
<li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li>
<li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li>
</ul>
]]></content>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ std::shared_ptr</title>
    <url>/2024/02/19/note/cpp/stl/smart_ptr/smart_pointer/</url>
    <content><![CDATA[<h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><p>总结：内部是一个指向对象的指针，两个引用计数int（用atomic接口修改计数值，保证引用计数修改的线程安全），但是所指对象的线程安全没用保证。</p>
<p>打印shared_ptr <code>p1</code>的引用计数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p p1._M_refcount._M_pi._M_use_count</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">17 = 1</span></span><br></pre></td></tr></table></figure>

<p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#shared_ptr.thread">gcc shared_ptr imp doc</a></p>
<p>x86_64下一个shared_ptr是16字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) pt /o p1</span><br><span class="line">/* offset    |  size */  type = class std::shared_ptr&lt;int&gt; [with _Tp = int] : public std::__shared_ptr&lt;_Tp, (__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line"></span><br><span class="line">/* total size (bytes):   16 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体构成:</p>
<ul>
<li>真正的指针8字节</li>
<li>use_count4字节</li>
<li>weak_count4字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) pt /o p1._M_refcount</span><br><span class="line">/* offset    |  size */  type = class std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line">                         private:</span><br><span class="line">/*    0      |     8 */    std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt; *_M_pi;</span><br><span class="line"></span><br><span class="line">/* total size (bytes):    8 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(gdb) pt /o p1._M_ptr</span><br><span class="line">type = int *</span><br><span class="line"></span><br><span class="line">(gdb) pt /o p1._M_refcount._M_pi</span><br><span class="line">type = class std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt; : public std::_Mutex_base&lt;(__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line">                         private:</span><br><span class="line">/*    8      |     4 */    _Atomic_word _M_use_count;</span><br><span class="line">/*   12      |     4 */    _Atomic_word _M_weak_count;</span><br><span class="line"></span><br><span class="line"> /* total size (bytes):   16 */</span><br><span class="line">&#125; *</span><br></pre></td></tr></table></figure></li>
</ul>
<p>完整的内存布局为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*    0      |     8 */    int * _M_ptr</span><br><span class="line">/*    8      |     4 */    _Atomic_word _M_use_count;</span><br><span class="line">/*   12      |     4 */    _Atomic_word _M_weak_count;</span><br></pre></td></tr></table></figure>

<p><code>0x0000000000604020</code> 是 _M_ptr 所指地址，这么看，两个counter是放在了对象的前面（地址小于对象指针）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p &amp;p1</span><br><span class="line">$23 = (std::shared_ptr&lt;int&gt; *) 0x7ffffffed730</span><br><span class="line"></span><br><span class="line">(gdb) p sizeof(p1)</span><br><span class="line">$24 = 16</span><br><span class="line"></span><br><span class="line">(gdb) p p1._M_ptr</span><br><span class="line">$14 = (std::__shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2&gt;::element_type *) 0x604020</span><br><span class="line"></span><br><span class="line">(gdb) x/2gx &amp;p1._M_ptr</span><br><span class="line">0x7ffffffed730: 0x0000000000604020      0x0000000000604010</span><br><span class="line"></span><br><span class="line">(gdb) x/2gx 0x0000000000604020</span><br><span class="line">0x604020:       0x000000000000000a      0x0000000000020fe1</span><br><span class="line"></span><br><span class="line">(gdb) p *p1</span><br><span class="line">$25 = 10</span><br><span class="line"></span><br><span class="line">(gdb) p/x &#123;&amp;p1, &amp;p1._M_ptr&#125;</span><br><span class="line">$26 = &#123;0x7ffffffed730, 0x7ffffffed730&#125;</span><br><span class="line"></span><br><span class="line">(gdb) p &amp;p1._M_refcount._M_pi._M_weak_count</span><br><span class="line">$16 = (_Atomic_word *) 0x60401c</span><br><span class="line">(gdb) p &amp;p1._M_refcount._M_pi._M_use_count</span><br><span class="line">$17 = (_Atomic_word *) 0x604018</span><br></pre></td></tr></table></figure>

<h2 id="std-shared-ptr-成员构成"><a href="#std-shared-ptr-成员构成" class="headerlink" title="std::shared_ptr 成员构成"></a>std::shared_ptr 成员构成</h2><p><code>std::shared_ptr</code> 本身是空的，成员都继承自 <code>std::__shared_ptr</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) pt /mt p1</span><br><span class="line">type = class std::shared_ptr&lt;int&gt; [with _Tp = int] : public std::__shared_ptr&lt;_Tp, (__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::__shared_ptr</code> 里面是：</p>
<ul>
<li>指向实际对象的 <code>_M_ptr</code></li>
<li>引用计数 <code>_M_refcount</code>, 这个包了一个指向两个引用计数int的指针。</li>
</ul>
<p>注意:</p>
<ul>
<li>pt能直接打印实例化的类型，注意替换 <code>_Tp</code> 为 <code>int</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) pt /mt std::__shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">type = class std::__shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2&gt; [with _Tp = int] : public std::__shared_ptr_access&lt;_Tp, (__gnu_cxx::_Lock_policy)2, false, false&gt; &#123;</span><br><span class="line">  private:</span><br><span class="line">    _Tp *_M_ptr;</span><br><span class="line">    std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt; _M_refcount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_M_ptr</code> 就是指向实际对象的指针。这里实例化为 int*</p>
<p><code>_M_refcount</code> 里是 <code>_M_pi</code>指针</p>
<ul>
<li>pi could stand for “pointer to implementation”</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) pt /mt std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">type = class std::__shared_count&lt;(__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line">  private:</span><br><span class="line">    std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt; *_M_pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_M_pi</code>指向两个<code>int</code>的结构体, 这是引用计数变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) pt /mt std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">type = class std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt; : public std::_Mutex_base&lt;(__gnu_cxx::_Lock_policy)2&gt; &#123;</span><br><span class="line">  private:</span><br><span class="line">    _Atomic_word _M_use_count;</span><br><span class="line">    _Atomic_word _M_weak_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(gdb) pt _Atomic_word</span><br><span class="line">type = int</span><br></pre></td></tr></table></figure>

<h2 id="引用计数机制"><a href="#引用计数机制" class="headerlink" title="引用计数机制"></a>引用计数机制</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 <code>std::shared_ptr&lt;int&gt; p2 = p1;</code>，底层调用 <code>std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_add_ref_copy</code> 增加引用计数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  __gnu_cxx::__atomic_add_dispatch (__mem=<span class="number">0x55555556aeb8</span>, __val=<span class="number">1</span>) at /usr/include/c++/<span class="number">9</span>/ext/atomicity.h:<span class="number">98</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000055555555520d</span> in std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)<span class="number">2</span>&gt;::_M_add_ref_copy (<span class="keyword">this</span>=<span class="number">0x55555556aeb0</span>) at /usr/include/c++/<span class="number">9</span>/bits/shared_ptr_base.h:<span class="number">139</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00005555555550d3</span> in std::__shared_count&lt;(__gnu_cxx::_Lock_policy)<span class="number">2</span>&gt;::__shared_count (<span class="keyword">this</span>=<span class="number">0x7fffffffe278</span>, __r=...) at /usr/include/c++/<span class="number">9</span>/bits/shared_ptr_base.h:<span class="number">737</span></span><br><span class="line">#<span class="number">3</span>  <span class="number">0x0000555555554f9b</span> in std::__shared_ptr&lt;<span class="type">int</span>, (__gnu_cxx::_Lock_policy)<span class="number">2</span>&gt;::__shared_ptr (<span class="keyword">this</span>=<span class="number">0x7fffffffe270</span>) at /usr/include/c++/<span class="number">9</span>/bits/shared_ptr_base.h:<span class="number">1167</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000555555554fc5</span> in std::shared_ptr&lt;<span class="type">int</span>&gt;::<span class="built_in">shared_ptr</span> (<span class="keyword">this</span>=<span class="number">0x7fffffffe270</span>) at /usr/include/c++/<span class="number">9</span>/bits/shared_ptr.h:<span class="number">129</span></span><br><span class="line">#<span class="number">5</span>  <span class="number">0x0000555555554d50</span> <span class="function">in <span class="title">main</span> <span class="params">()</span> at shared_ptr.cpp:<span class="number">6</span></span></span><br></pre></td></tr></table></figure>

<p>多个 <code>shared_ptr</code> 共享 <code>_M_pi</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) p p1._M_refcount._M_pi</span><br><span class="line">$11 = (std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt; *) 0x55555556aeb0</span><br><span class="line">(gdb) p p2._M_refcount._M_pi</span><br><span class="line">$12 = (std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt; *) 0x55555556aeb0</span><br></pre></td></tr></table></figure>

<h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><p>unique_ptr的拷贝构造函数和拷贝赋值运算符函数都是delete。</p>
<p>用std::tuple保存指针和deleter，tuple可以通过空基类优化做到在使用默认的deleter时，只占用一个指针的大小。</p>
<h2 id="实现unique-ptr"><a href="#实现unique-ptr" class="headerlink" title="实现unique_ptr"></a>实现unique_ptr</h2>]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
