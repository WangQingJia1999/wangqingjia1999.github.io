<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="折纸飞向麦田的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="折纸飞向麦田的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="折纸飞向麦田">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>折纸飞向麦田的博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?81afe862f494d24a95a49966a87c3b00"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">折纸飞向麦田的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">折纸飞向麦田</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/20/note/linux/elf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/20/note/linux/elf/" class="post-title-link" itemprop="url">Linux ELF文件分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-02-20 10:24:13 / 修改时间：10:30:35" itemprop="dateCreated datePublished" datetime="2024-02-20T10:24:13+08:00">2024-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>38 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computing">computing</a>, the <strong>Executable and Linkable Format</strong>[<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#cite_note-linuxfoundation-elf-2">2]</a> (<strong>ELF</strong>, formerly named <strong>Extensible Linking Format</strong>), is a common standard <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/File_format">file format</a> for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Executable">executable</a> files, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object_code">object code</a>, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shared_library">shared libraries</a>, and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Core_dump">core dumps</a>. – wikipedia</p>
</blockquote>
<p>本文分析ELF文件内容，以备日后查询。</p>
<h1 id="Object-File-Format"><a href="#Object-File-Format" class="headerlink" title="Object File Format"></a>Object File Format</h1><p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220102711.png" alt="image.png"></p>
<h1 id="ELF-Format-Overview"><a href="#ELF-Format-Overview" class="headerlink" title="ELF Format Overview"></a>ELF Format Overview</h1><p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220102739.png" alt="image.png"></p>
<h1 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h1><blockquote>
<p>Strictly speaking, the division into sections is intended to provide a convenient organization for use by the linker. Sections are intended to provide a view for the linker only.</p>
</blockquote>
<p>由 <code>section header table</code> 定义 sections.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">wqj@WQJ:/home/cpp/build/self_mutate$ readelf --sections --wide demo</span><br><span class="line">There are 31 section headers, starting at offset 0x3ac8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        00000000004002a8 0002a8 00001c 00   A  0   0  1</span><br><span class="line">  [ 2] .note.gnu.build-id NOTE            00000000004002c4 0002c4 000024 00   A  0   0  4</span><br><span class="line">  [ 3] .note.ABI-tag     NOTE            00000000004002e8 0002e8 000020 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        0000000000400308 000308 00001c 00   A  5   0  8</span><br><span class="line">  [ 5] .dynsym           DYNSYM          0000000000400328 000328 000048 18   A  6   1  8</span><br><span class="line">  [ 6] .dynstr           STRTAB          0000000000400370 000370 000038 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          00000000004003a8 0003a8 000006 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         00000000004003b0 0003b0 000020 00   A  6   1  8</span><br><span class="line">  [ 9] .rela.dyn         RELA            00000000004003d0 0003d0 000030 18   A  5   0  8</span><br><span class="line">  [10] .init             PROGBITS        0000000000401000 001000 00001b 00  AX  0   0  4</span><br><span class="line">  [11] .text             PROGBITS        0000000000401020 001020 0001a5 00  AX  0   0 16</span><br><span class="line">  [12] .fini             PROGBITS        00000000004011c8 0011c8 00000d 00  AX  0   0  4</span><br><span class="line">  [13] .rodata           PROGBITS        0000000000402000 002000 000004 04  AM  0   0  4</span><br><span class="line">  [14] .eh_frame_hdr     PROGBITS        0000000000402004 002004 00002c 00   A  0   0  4</span><br><span class="line">  [15] .eh_frame         PROGBITS        0000000000402030 002030 0000a0 00   A  0   0  8</span><br><span class="line">  [16] .init_array       INIT_ARRAY      0000000000403e50 002e50 000008 08  WA  0   0  8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY      0000000000403e58 002e58 000008 08  WA  0   0  8</span><br><span class="line">  [18] .dynamic          DYNAMIC         0000000000403e60 002e60 000190 10  WA  6   0  8</span><br><span class="line">  [19] .got              PROGBITS        0000000000403ff0 002ff0 000010 08  WA  0   0  8</span><br><span class="line">  [20] .got.plt          PROGBITS        0000000000404000 003000 000018 08  WA  0   0  8</span><br><span class="line">  [21] .data             PROGBITS        0000000000404018 003018 000010 00  WA  0   0  8</span><br><span class="line">  [22] .bss              NOBITS          0000000000404028 003028 000008 00  WA  0   0  1</span><br><span class="line">  [23] .comment          PROGBITS        0000000000000000 003028 00002b 01  MS  0   0  1</span><br><span class="line">  [24] .debug_aranges    PROGBITS        0000000000000000 003053 000030 00      0   0  1</span><br><span class="line">  [25] .debug_info       PROGBITS        0000000000000000 003083 0000b2 00      0   0  1</span><br><span class="line">  [26] .debug_abbrev     PROGBITS        0000000000000000 003135 000028 00      0   0  1</span><br><span class="line">  [27] .debug_line       PROGBITS        0000000000000000 00315d 000054 00      0   0  1</span><br><span class="line">  [28] .symtab           SYMTAB          0000000000000000 0031b8 000600 18     29  47  8</span><br><span class="line">  [29] .strtab           STRTAB          0000000000000000 0037b8 0001e1 00      0   0  1</span><br><span class="line">  [30] .shstrtab         STRTAB          0000000000000000 003999 00012e 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h2 id="Section-Header-Table"><a href="#Section-Header-Table" class="headerlink" title="Section Header Table"></a>Section Header Table</h2><table>
<thead>
<tr>
<th>typedef struct {</th>
</tr>
</thead>
<tbody><tr>
<td>uint32_t sh_name;  &#x2F;* Section name (string tbl index) *&#x2F;</td>
</tr>
<tr>
<td>uint32_t sh_type;  &#x2F;* Section type  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_flags;  &#x2F;* Section flags  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_addr;  &#x2F;* Section virtual addr at execution *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_offset;  &#x2F;* Section file offset  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_size;  &#x2F;* Section size in bytes  *&#x2F;</td>
</tr>
<tr>
<td>uint32_t sh_link;  &#x2F;* Link to another section  *&#x2F;</td>
</tr>
<tr>
<td>uint32_t sh_info;  &#x2F;* Additional section information  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_addralign;  &#x2F;* Section alignment  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t sh_entsize;  &#x2F;* Entry size if section holds table *&#x2F;</td>
</tr>
<tr>
<td>} Elf64_Shdr;</td>
</tr>
</tbody></table>
<blockquote>
<p> Files used during linking must have a section header table; </p>
</blockquote>
<h3 id="sh-name"><a href="#sh-name" class="headerlink" title="sh_name"></a>sh_name</h3><p>If set, it contains an index into the string table. If the index is zero, it means the section doesn’t have a name.</p>
<blockquote>
<p>a special section called .shstrtab, which<br>contains an array of NULL-terminated strings, one for every section name.<br>The index of the section header describing the string table is given in the<br>e_shstrndx field of the executable header. This allows tools like readelf to<br>easily find the .shstrtab section and then index it with the sh_name field of<br>every section header (including the header of .shstrtab) to find the string<br>describing the name of the section in question. This allows a human analyst<br>to easily identify the purpose of each section.2</p>
</blockquote>
<p>TODO: test above </p>
<h3 id="sh-type"><a href="#sh-type" class="headerlink" title="sh_type"></a>sh_type</h3><p><code>sh_type</code> tells the linker something about the structure of a section’s contents. </p>
<p><img src="/./assets/image-20231028162640052.png" alt="image-20231028162640052"></p>
<h4 id="SHT-PROGBITS"><a href="#SHT-PROGBITS" class="headerlink" title="SHT_PROGBITS"></a>SHT_PROGBITS</h4><blockquote>
<p>Sections with type SHT_PROGBITS contain program data, such as machine<br>instructions or constants. These sections have no particular structure for the<br>linker to parse.</p>
</blockquote>
<h4 id="SHT-SYMTAB"><a href="#SHT-SYMTAB" class="headerlink" title="SHT_SYMTAB"></a>SHT_SYMTAB</h4><p>static symbol tables. Symbol tables contain symbols in a well-defined format (struct Elf64_Sym in elf.h)</p>
<h4 id="SHT-DYNSYM"><a href="#SHT-DYNSYM" class="headerlink" title="SHT_DYNSYM"></a>SHT_DYNSYM</h4><p>symbol tables used by the dynamic linker.</p>
<h4 id="SHT-STRTAB"><a href="#SHT-STRTAB" class="headerlink" title="SHT_STRTAB"></a>SHT_STRTAB</h4><p>string tables, which simply contain an array of NULL-terminated strings, with the first byte in the string table set to NULL by convention.</p>
<h4 id="SHT-REL-SHT-RELA"><a href="#SHT-REL-SHT-RELA" class="headerlink" title="SHT_REL &#x2F; SHT_RELA"></a>SHT_REL &#x2F; SHT_RELA</h4><blockquote>
<p>Sections with type SHT_REL or SHT_RELA are particularly important for<br>the linker because they contain relocation entries in a well-defined format<br>(struct Elf64_Rel and struct Elf64_Rela in elf.h), which the linker can parse<br>to perform the necessary relocations in other sections. Each relocation entry<br>tells the linker about a particular location in the binary where a relocation is<br>needed and which symbol the relocation should be resolved to.</p>
</blockquote>
<h4 id="SHT-DYNAMIC"><a href="#SHT-DYNAMIC" class="headerlink" title="SHT_DYNAMIC"></a>SHT_DYNAMIC</h4><blockquote>
<p>Sections of type SHT_DYNAMIC contain information needed for dynamic<br>linking. This information is formatted using struct Elf64_Dyn as specified<br>in elf.h.</p>
</blockquote>
<h3 id="sh-flags"><a href="#sh-flags" class="headerlink" title="sh_flags"></a>sh_flags</h3><h4 id="SHF-WRITE"><a href="#SHF-WRITE" class="headerlink" title="SHF_WRITE"></a>SHF_WRITE</h4><p>SHF_WRITE indicates that the section is writable at runtime. </p>
<h4 id="SHF-ALLOC"><a href="#SHF-ALLOC" class="headerlink" title="SHF_ALLOC"></a>SHF_ALLOC</h4><blockquote>
<p>The SHF_ALLOC flag indicates that the contents of the section are to be loaded into virtual memory when executing the binary (though the actual loading happens using the segment view of the binary, not the section view).</p>
</blockquote>
<h4 id="SHF-EXECINSTR"><a href="#SHF-EXECINSTR" class="headerlink" title="SHF_EXECINSTR"></a>SHF_EXECINSTR</h4><blockquote>
<p>SHF_EXECINSTR tells you that the section contains executable instructions, which is useful to know when disassembling a binary.</p>
</blockquote>
<h3 id="sh-addr"><a href="#sh-addr" class="headerlink" title="sh_addr"></a>sh_addr</h3><p>virtual address of section.</p>
<blockquote>
<p>the linker sometimes needs to know at which addresses partic-<br>ular pieces of code and data will end up at runtime to do relocations. The<br>sh_addr field provides this information. Sections that aren’t intended to be<br>loaded into virtual memory when setting up the process have an sh_addr<br>value of zero.</p>
</blockquote>
<h3 id="sh-offset"><a href="#sh-offset" class="headerlink" title="sh_offset"></a>sh_offset</h3><p>file offset (in bytes from the start of the file)</p>
<h3 id="sh-size"><a href="#sh-size" class="headerlink" title="sh_size"></a>sh_size</h3><p>size (in bytes) of the section</p>
<h3 id="sh-info"><a href="#sh-info" class="headerlink" title="sh_info"></a>sh_info</h3><blockquote>
<p>The sh_info field contains additional information about the section. The<br>meaning of the additional information varies depending on the section type.<br>For instance, for relocation sections, sh_info denotes the index of the section<br>to which the relocations are to be applied.</p>
</blockquote>
<h3 id="sh-addralign"><a href="#sh-addralign" class="headerlink" title="sh_addralign"></a>sh_addralign</h3><blockquote>
<p>Some sections may need to be aligned in memory in a particular way for effi-<br>ciency of memory accesses. For example, a section may need to be loaded<br>at some address that is a multiple of 8 bytes or 16 bytes. These alignment<br>requirements are specified in the sh_addralign field. For instance, if this field<br>is set to 16, it means the base address of the section (as chosen by the linker)<br>must be some multiple of 16. The values 0 and 1 are reserved to indicate no<br>special alignment needs.</p>
</blockquote>
<h3 id="sh-entsize"><a href="#sh-entsize" class="headerlink" title="sh_entsize"></a>sh_entsize</h3><blockquote>
<p>Some sections, such as symbol tables or relocation tables, contain a table<br>of well-defined data structures (such as Elf64_Sym or Elf64_Rela). For such<br>sections, the sh_entsize field indicates the size in bytes of each entry in the<br>table. When the field is unused, it is set to zero</p>
</blockquote>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><h4 id="data"><a href="#data" class="headerlink" title=".data"></a>.data</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [24] .data             PROGBITS        0000000000002000 001000 000010 00  WA  0   0  8</span><br></pre></td></tr></table></figure>

<h4 id="plt"><a href="#plt" class="headerlink" title=".plt"></a>.plt</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [13] .plt              PROGBITS        0000000000000550 000550 000050 10  AX  0   0 16</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">0000000000000550 &lt;.plt&gt;:</span><br><span class="line"> 550:    ff 35 8a 1a 00 00        pushq  0x1a8a(%rip)        # 1fe0 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line"> 556:    f2 ff 25 8b 1a 00 00     bnd jmpq *0x1a8b(%rip)        # 1fe8 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line"> 55d:    0f 1f 00                 nopl   (%rax)</span><br><span class="line"> 560:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 564:    68 00 00 00 00           pushq  $0x0</span><br><span class="line"> 569:    f2 e9 e1 ff ff ff        bnd jmpq 550 &lt;_init+0x28&gt;</span><br><span class="line"> 56f:    90                       nop</span><br><span class="line"> 570:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 574:    68 01 00 00 00           pushq  $0x1</span><br><span class="line"> 579:    f2 e9 d1 ff ff ff        bnd jmpq 550 &lt;_init+0x28&gt;</span><br><span class="line"> 57f:    90                       nop</span><br><span class="line"> 580:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 584:    f2 ff 25 65 1a 00 00     bnd jmpq *0x1a65(%rip)        # 1ff0 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br><span class="line"> 58b:    0f 1f 04 00              nopl   (%rax,%rax,1)</span><br><span class="line"> 58f:    90                       nop</span><br><span class="line"> 590:    f3 0f 1e fa              endbr64 </span><br><span class="line"> 594:    f2 ff 25 5d 1a 00 00     bnd jmpq *0x1a5d(%rip)        # 1ff8 &lt;putchar@GLIBC_2.2.5&gt;</span><br><span class="line"> 59b:    0f 1f 04 00              nopl   (%rax,%rax,1)</span><br><span class="line"> 59f:    90                       nop</span><br></pre></td></tr></table></figure>

<h4 id="got"><a href="#got" class="headerlink" title=".got"></a>.got</h4><p>A GOT is simply a table of addresses, residing in the data section. The GOT entry, in turn, will contain the absolute address of the variable:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [22] .got              PROGBITS        0000000000001fb0 000fb0 000028 00  WA  0   0  8</span><br></pre></td></tr></table></figure>

<h4 id="got-plt"><a href="#got-plt" class="headerlink" title=".got.plt"></a>.got.plt</h4><p><code>.got.plt</code> 的前三项是有特殊意义的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOT[0]：保存的是“.dynamic”节的地址，这个节描述了本模块动态链接相关的信息</span><br><span class="line">GOT[1]：保存的是本模块的link_map结构的地址，动态链接器利用该地址来对符号进行解析。</span><br><span class="line">GOT[2]：保存的是_dl_runtime_resolve()的地址。</span><br></pre></td></tr></table></figure>

<p>其中第二项和第三项由动态链接器在装载共享模块的时候负责将它们初始化。</p>
<p><code>.got.plt</code>的其余项分别对应每个外部函数的引用</p>
<p><code>.got.plt</code> contains the addresses of the external <em>functions</em> used by the program.</p>
<p>PLT(Procedure Linkage Table) which is, put simply, used to call external procedures&#x2F;functions whose address isn’t known in the time of linking, and is left to be resolved by the dynamic linker at run time.</p>
<p>for code, things are a bit more complicated.</p>
<p>Whenever a function from a shared library is called, the linker makes us jump to an address in the PLT.</p>
<p>The first time the function is called, the PLT code uses offsets stored in the GOT to decide the actual final location of the function, and then:</p>
<ul>
<li>stores this pre-calculated value</li>
<li>jumps there</li>
</ul>
<p>The next times the function is called, the value has already been calculated, so it just jumps there directly.</p>
<p>Due to this lazy resolution mechanism:</p>
<ul>
<li>programs can start running quickly even if the shared libraries have a lot of symbols</li>
<li>we can replace functions on the fly by playing with the <code>LD_PRELOAD</code> variable</li>
</ul>
<h4 id="rela-text"><a href="#rela-text" class="headerlink" title=".rela.text"></a>.rela.text</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;        <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword    r_info;            <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword    r_addend;        <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220102811.png" alt="image.png"></p>
<h4 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h4><p>专门用于动态链接</p>
<p>动态链接ELF中<code>最重要的结构</code>应该是 **<code>.dynamic</code>**，这个节里面保存了<code>动态链接器</code>所需要的<code>基本信息</code>，比如依赖于哪些<code>共享对象</code>、<code>动态链接符号表</code>的位置、<code>动态链接重定位表</code>的位置、<code>共享对象初始化代码</code>的地址等。</p>
<p>使用<code>readelf</code>工具可以查看<code>“.dynamic”节</code>的内容：</p>
<ul>
<li><blockquote>
<p>-d –dynamic           Display the dynamic section (if present)</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -d a.out</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x750 contains 25 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048328</span><br><span class="line"> 0x0000000d (FINI)                       0x8048650</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049744</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049748</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x00000004 (HASH)                       0x804818c</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481c0</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048260</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481e0</span><br><span class="line"> 0x0000000a (STRSZ)                      95 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x8049844</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   48 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x80482f8</span><br><span class="line"> 0x00000011 (REL)                        0x80482f0</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482d0</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482c0</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure>



<h1 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h1><blockquote>
<p>segments, which are used at execution time (as opposed to sections, which are used at link time).</p>
</blockquote>
<blockquote>
<p>The program header table provides a segment view of the binary, as opposed to<br>the section view provided by the section header table. The section view of an<br>ELF binary, which I discussed earlier, is meant for static linking purposes<br>only. In contrast, the segment view, which I’ll discuss next, is used by the<br>operating system and dynamic linker when loading an ELF into a process for<br>execution to locate the relevant code and data and decide what to load into<br>virtual memory.</p>
</blockquote>
<p>由 <code>program header table</code> 定义 segments。由于 segment 提供运行时视角，因此只有可执行目标文件才有这个，不可执行的目标文件没有。</p>
<h2 id="Program-Header-Table"><a href="#Program-Header-Table" class="headerlink" title="Program Header Table"></a>Program Header Table</h2><table>
<thead>
<tr>
<th>typedef struct {</th>
</tr>
</thead>
<tbody><tr>
<td>uint32_t p_type;  &#x2F;* Segment type  *&#x2F;</td>
</tr>
<tr>
<td>uint32_t p_flags;  &#x2F;* Segment flags  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_offset; &#x2F;* Segment file offset  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_vaddr;  &#x2F;* Segment virtual address  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_paddr;  &#x2F;* Segment physical address *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_filesz; &#x2F;* Segment size in file  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_memsz;  &#x2F;* Segment size in memory  *&#x2F;</td>
</tr>
<tr>
<td>uint64_t p_align;  &#x2F;* Segment alignment  *&#x2F;</td>
</tr>
<tr>
<td>} Elf64_Phdr;</td>
</tr>
</tbody></table>
<blockquote>
<p>A program header table, if present, tells the system how to create a process image.</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">wqj@WQJ:/home/cpp/build/self_mutate$ readelf --wide --segments demo</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x401020</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000400 0x000400 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x0001d5 0x0001d5 R E 0x1000</span><br><span class="line">  LOAD           0x002000 0x0000000000402000 0x0000000000402000 0x0000d0 0x0000d0 R   0x1000</span><br><span class="line">  LOAD           0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001d8 0x0001e0 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002e60 0x0000000000403e60 0x0000000000403e60 0x000190 0x000190 RW  0x8</span><br><span class="line">  NOTE           0x0002c4 0x00000000004002c4 0x00000000004002c4 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x002004 0x0000000000402004 0x0000000000402004 0x00002c 0x00002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line">  GNU_RELRO      0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001b0 0x0001b0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn </span><br><span class="line">   03     .init .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   06     .dynamic </span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<h3 id="p-type"><a href="#p-type" class="headerlink" title="p_type"></a>p_type</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># /usr/include/elf.h</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Legal values for p_type (segment type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    PT_NULL        0        <span class="comment">/* Program header table entry unused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD        1        <span class="comment">/* Loadable program segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DYNAMIC    2        <span class="comment">/* Dynamic linking information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_INTERP    3        <span class="comment">/* Program interpreter */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_NOTE        4        <span class="comment">/* Auxiliary information */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SHLIB    5        <span class="comment">/* Reserved */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_PHDR        6        <span class="comment">/* Entry for header table itself */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TLS        7        <span class="comment">/* Thread-local storage segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    PT_NUM        8        <span class="comment">/* Number of defined types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOOS        0x60000000    <span class="comment">/* Start of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_EH_FRAME    0x6474e550    <span class="comment">/* GCC .eh_frame_hdr segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_STACK    0x6474e551    <span class="comment">/* Indicates stack executability */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_GNU_RELRO    0x6474e552    <span class="comment">/* Read-only after relocation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOSUNW    0x6ffffffa</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUNWBSS    0x6ffffffa    <span class="comment">/* Sun Specific segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUNWSTACK    0x6ffffffb    <span class="comment">/* Stack segment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HISUNW    0x6fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIOS        0x6fffffff    <span class="comment">/* End of OS-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOPROC    0x70000000    <span class="comment">/* Start of processor-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_HIPROC    0x7fffffff    <span class="comment">/* End of processor-specific */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="PT-PHDR"><a href="#PT-PHDR" class="headerlink" title="PT_PHDR"></a>PT_PHDR</h4><blockquote>
<p>PT_PHDR segment, which encompasses the program header table.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line"></span><br><span class="line">Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br></pre></td></tr></table></figure>

<h4 id="PT-LOAD"><a href="#PT-LOAD" class="headerlink" title="PT_LOAD"></a>PT_LOAD</h4><blockquote>
<p>Segments of type PT_LOAD, as the name implies, are intended to be loaded<br>into memory when setting up the process. The size of the loadable chunk<br>and the address to load it at are described in the rest of the program header.<br>As you can see in the readelf output, there are usually at least two PT_LOAD<br>segments—one encompassing the nonwritable sections and one containing<br>the writable data sections.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000400 0x000400 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x0001d5 0x0001d5 R E 0x1000</span><br><span class="line">  LOAD           0x002000 0x0000000000402000 0x0000000000402000 0x0000d0 0x0000d0 R   0x1000</span><br><span class="line">  LOAD           0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001d8 0x0001e0 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002e60 0x0000000000403e60 0x0000000000403e60 0x000190 0x000190 RW  0x8</span><br><span class="line">  NOTE           0x0002c4 0x00000000004002c4 0x00000000004002c4 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x002004 0x0000000000402004 0x0000000000402004 0x00002c 0x00002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line">  GNU_RELRO      0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001b0 0x0001b0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn </span><br><span class="line">   03     .init .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   06     .dynamic </span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<h4 id="PT-DYNAMIC"><a href="#PT-DYNAMIC" class="headerlink" title="PT_DYNAMIC"></a>PT_DYNAMIC</h4><blockquote>
<p>PT_DYNAMIC segment contains the .dynamic section, which tells the interpreter how to parse and prepare the binary for execution. </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">wqj@WQJ:/home/cpp/build/self_mutate$ readelf --wide --segments demo</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x401020</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8       0</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1       1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000400 0x000400 R   0x1000    2</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x0001d5 0x0001d5 R E 0x1000    3</span><br><span class="line">  LOAD           0x002000 0x0000000000402000 0x0000000000402000 0x0000d0 0x0000d0 R   0x1000    4</span><br><span class="line">  LOAD           0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001d8 0x0001e0 RW  0x1000    5</span><br><span class="line"></span><br><span class="line">  DYNAMIC        0x002e60 0x0000000000403e60 0x0000000000403e60 0x000190 0x000190 RW  0x8       6</span><br><span class="line"></span><br><span class="line">  NOTE           0x0002c4 0x00000000004002c4 0x00000000004002c4 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_EH_FRAME   0x002004 0x0000000000402004 0x0000000000402004 0x00002c 0x00002c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RWE 0x10</span><br><span class="line">  GNU_RELRO      0x002e50 0x0000000000403e50 0x0000000000403e50 0x0001b0 0x0001b0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn </span><br><span class="line">   03     .init .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line"></span><br><span class="line">   06     .dynamic </span><br><span class="line"></span><br><span class="line">   07     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   08     .eh_frame_hdr </span><br><span class="line">   09     </span><br><span class="line">   10     .init_array .fini_array .dynamic .got </span><br></pre></td></tr></table></figure>

<h4 id="PT-INTERP"><a href="#PT-INTERP" class="headerlink" title="PT_INTERP"></a>PT_INTERP</h4><blockquote>
<p>The PT_INTERP segment contains the .interp section, which provides the name of the interpreter that is to be used to load the binary.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000400040 0x0000000000400040 0x000268 0x000268 R   0x8</span><br><span class="line">  INTERP         0x0002a8 0x00000000004002a8 0x00000000004002a8 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br></pre></td></tr></table></figure>

<h3 id="p-flag"><a href="#p-flag" class="headerlink" title="p_flag"></a>p_flag</h3><p>The flags specify the runtime access permissions for the segment.</p>
<h4 id="PF-X"><a href="#PF-X" class="headerlink" title="PF_X"></a>PF_X</h4><p>The PF_X flag indicates that the segment is executable and is set for code segments (readelf displays it as an E rather than an X in the Flg column</p>
<h4 id="PF-W"><a href="#PF-W" class="headerlink" title="PF_W"></a>PF_W</h4><p>The PF_W flag means that the segment is writable, and it is normally set only for writable data segments, never for code segments.</p>
<h4 id="PF-R"><a href="#PF-R" class="headerlink" title="PF_R"></a>PF_R</h4><p>PF_R means that the segment is readable, as is normally the case for both code and data segments.</p>
<h3 id="p-offset-p-vaddr-and-p-filesz"><a href="#p-offset-p-vaddr-and-p-filesz" class="headerlink" title="p_offset, p_vaddr, and p_filesz"></a>p_offset, p_vaddr, and p_filesz</h3><p>They specify the file offset at which the segment starts, the virtual address at which it is to be loaded, and the file size of the segment, respectively. </p>
<h3 id="p-paddr"><a href="#p-paddr" class="headerlink" title="p_paddr"></a>p_paddr</h3><p>On modern operating systems such as Linux, this field is unused and set to zero since they execute all binaries in virtual memory.</p>
<h3 id="p-memsz"><a href="#p-memsz" class="headerlink" title="p_memsz"></a>p_memsz</h3><p><code>p_filesz</code> is the file size of the segment and <code>p_memsz</code> is the size in memory. To understand this, recall that some sections only indicate the need to allocate some bytes in memory but don’t actually occupy these bytes in the binary file. For instance, the <code>.bss</code> section contains zero-initialized data. Since all data in this section is known to be zero anyway, there’s no need to actually include all these zeros in the binary. However, when loading the segment containing <code>.bss</code> into virtual memory, all the bytes in <code>.bss</code> should be allocated. Thus, it’s possible for <code>p_memsz</code> to be larger than <code>p_filesz</code>. When this happens, the loader adds the extra bytes at the end of the segment when loading the binary and initializes them to zero.</p>
<h3 id="p-align"><a href="#p-align" class="headerlink" title="p_align"></a>p_align</h3><p>It indicates the required memory alignment (in bytes) for the segment. An alignment value of 0 or 1 indicates that no particular alignment is required. If <code>p_align</code> isn’t set to 0 or 1, then its value must be a power of 2, and <code>p_vaddr</code> must be equal to <code>p_offset</code>, modulo p_align.</p>
<h1 id="Relocation"><a href="#Relocation" class="headerlink" title="Relocation"></a>Relocation</h1><p>主要参考这篇文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">Position Independent Code (PIC) in shared libraries - Eli Bendersky’s website</a></p>
</blockquote>
<blockquote>
<p>Relocation is the process of connecting symbolic references with symbolic definitions. For<br>example, when a program calls a function, the associated call instruction must transfer control<br>to the proper destination address at execution. In other words, relocatable files must have<br>information that describes how to modify their section contents, thus allowing executable and<br>shared object files to hold the right information for a process’s program image. Relocation<br>entries are these data.</p>
</blockquote>
<p>Transform a relocatable file into either an executable or a shared object file. The link editor merges one or more relocatable files to form the output. It first decides how to combine and locate the input files, then updates the symbol values, and finally performs the relocation. Relocations applied to executable or shared object files are similar and accomplish the same result.</p>
<p><em>relocations</em> are entries in binaries that are left to be filled in later – at link time by the toolchain linker or at runtime by the dynamic linker.</p>
<blockquote>
<p>Briefly, when the linker creates a shared library, it doesn’t know in advance where it might be loaded.</p>
<p>There are two main approaches to solve this problem in Linux ELF shared libraries:</p>
<ol>
<li>Load-time relocation</li>
<li>Position independent code (PIC)</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/">Position Independent Code (PIC) in shared libraries - Eli Bendersky’s website</a></p>
</blockquote>
<h2 id="Static-Relocation"><a href="#Static-Relocation" class="headerlink" title="Static Relocation"></a>Static Relocation</h2><p>静态链接器</p>
<h2 id="Dynamic-Relocation"><a href="#Dynamic-Relocation" class="headerlink" title="Dynamic Relocation"></a>Dynamic Relocation</h2><p>动态链接器 <code>/lib/ld-linux.so</code> 重定位程序对共享库中符号的引用的过程。</p>
<h3 id="PIC-Variable"><a href="#PIC-Variable" class="headerlink" title="PIC Variable"></a>PIC Variable</h3><p>单独由 <code>.got</code> section实现。</p>
<h4 id="Example-PIC变量"><a href="#Example-PIC变量" class="headerlink" title="Example - PIC变量"></a>Example - PIC变量</h4><p>读取动态库中的全局变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataonly.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myglob;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataonly.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> myglob + a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dataonly.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    ml_func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -fpic -shared -m32 -o libmlpic_dataonly.so dataonly.c</span><br><span class="line">gcc -m32 -o dataonlymain dataonlymain.c -L. -lmlpic_dataonly -g</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:. gdb dataonlymain</span></span><br><span class="line">(gdb) b ml_func</span><br></pre></td></tr></table></figure>

<p>从 .got 中取得 myglob 的绝对地址，.got中的绝对地址是 ld-linux.so 将 libmlpic_dataonly.so 加载后立刻解析出填充的。</p>
<p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220102847.png"></p>
<p>.got 是静态链接器和动态连接器协商的结果，静态链接器将所有对 myglob 的访问都改成从.got取绝对地址，动态链接器加载动态库时，填充对应的绝对地址。</p>
<h3 id="PIC-Function-Lazy-Binding"><a href="#PIC-Function-Lazy-Binding" class="headerlink" title="PIC Function (Lazy Binding)"></a>PIC Function (Lazy Binding)</h3><p>PIC函数符号的绝对地址不是像PIC变量一样直接填充到<code>.got</code>，而是通过 lazy binding 实现，又多绕一层。首先，动态库中函数比全局变量多，开销更大；其次，有很多动态库函数，比如处理错误的，有可能在运行时根本不会调用到。为优化效率，PIC函数借助PLT实现lazy binding。</p>
<blockquote>
<p>When a shared library refers to some function, the real address of that function is not known until load time. Resolving this address is called <em>binding</em>, and it’s something the dynamic loader does when it loads the shared library into the process’s memory space. This binding process is non-trivial, since the loader has to actually <em>look up</em> the function symbol in special tables <a target="_blank" rel="noopener" href="https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/#id13">[5]</a>.</p>
<p>So, resolving each function takes time. Not a lot of time, but it adds up since the amount of functions in libraries is typically much larger than the amount of global variables. Moreover, most of these resolutions are done in vain, because in a typical run of a program only a fraction of functions actually get called (think about various functions handling error and special conditions, which typically don’t get called at all).</p>
<p>So, to speed up this process, a clever lazy binding scheme was devised. “Lazy” is a generic name for a family of optimizations in computer programming, where work is delayed until the last moment when it’s actually needed, with the intention of avoiding doing this work if its results are never required during a specific run of a program. Good examples of laziness are <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> and <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>.</p>
</blockquote>
<p>由<code>.plt</code> + <code>.got.plt</code> 两个section配合实现。</p>
<p>函数首次调用时：</p>
<p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220102952.png" alt="image.png"></p>
<p>上图的 GOT 是 <code>.got.plt</code></p>
<p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220103009.png" alt="image.png"></p>
<p>后续的函数调用：</p>
<p><img src="https://raw.githubusercontent.com/wangqingjia1999/img/master/20240220103030.png" alt="image.png"></p>
<h4 id="Example-PIC函数"><a href="#Example-PIC函数" class="headerlink" title="Example - PIC函数"></a>Example - PIC函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> myglob = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_util_func</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ml_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = b + ml_util_func(a);</span><br><span class="line">    myglob += c;</span><br><span class="line">    <span class="keyword">return</span> b + myglob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dynamic linker 听好了，你找到 ml_util_func 的绝对地址后，给我写入 0x2008 这个地址。</p>
<blockquote>
<p>The last line means that the dynamic loader should place the value (address) of symbol ml_util_func into 0x2008 (which, recall, is the GOT entry for this function).</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">readelf -r libmlpic.so</span></span><br><span class="line">[...] snip output</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x328 contains 3 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">00002000  00000107 R_386_JUMP_SLOT   00000000   __cxa_finalize</span><br><span class="line">00002004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span><br><span class="line">00002008  00000707 R_386_JUMP_SLOT   0000046c   ml_util_func</span><br></pre></td></tr></table></figure>





<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://refspecs.linuxbase.org/elf/elf.pdf">ELF标准定义文档</a></p>
</li>
<li><p>动态链接详解 - 你说起一个什么名的文章 - 知乎<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/263094043">https://zhuanlan.zhihu.com/p/263094043</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gnuemacs/p/14523720.html">https://www.cnblogs.com/gnuemacs/p/14523720.html</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/20/note/linux/bfd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/20/note/linux/bfd/" class="post-title-link" itemprop="url">Linux bfd</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-20 10:20:04" itemprop="dateCreated datePublished" datetime="2024-02-20T10:20:04+08:00">2024-02-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>573</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="arelent"><a href="#arelent" class="headerlink" title="arelent"></a>arelent</h2><blockquote>
<p>BFD represents a relocation as a pointer to the ‘arelent’ type. A relocation describes an action which the linker must take to modify the section contents. Relocations have a symbol, an address, an addend, and a pointer to a howto structure which describes how to perform the relocation. </p>
</blockquote>
<blockquote>
<p>In BFD, each section has an array of ‘arelent’ structures. Each structure has a pointer to a symbol, an address within the section, an addend, and a pointer to a ‘reloc_howto_struct’ structure. The howto structure has a bunch of fields describing the reloc, including a type field. The type field is specific to the object file format backend; none of the generic code in BFD examines it.</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/redis/redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">Redis底层数据结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>27k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>45 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 Redis 代码的（还未发布正式版本）。</p>
<img title="" src="https://cdn.xiaolincoding.com//mysql/other/9fa26a74965efbf0f56b707a03bb9b7f-20230309232518487.png" alt="" width="808">

<p>可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如：</p>
<ul>
<li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li>
<li>在最新的 Redis 代码（还未发布正式版本）中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li>
</ul>
<p><strong>共有 9 种数据结构：SDS、双向链表、压缩列表、哈希表、跳表、整数集合、quicklist、listpack。</strong></p>
<img title="" src="https://cdn.xiaolincoding.com//mysql/other/a9c3e7dc4ac79363d8eb8eb2290a58e6.png" alt="" width="804">

<h2 id="键值对数据库是怎么实现的？"><a href="#键值对数据库是怎么实现的？" class="headerlink" title="键值对数据库是怎么实现的？"></a>键值对数据库是怎么实现的？</h2><p>在开始讲数据结构之前，先给介绍下 Redis 是怎样实现键值对（key-value）数据库的。</p>
<p>Redis 的键值对中的 key 就是字符串对象，而 <strong>value 可以是字符串对象，也可以是集合数据类型的对象</strong>，比如 List 对象、Hash 对象、Set 对象和 Zset 对象。</p>
<p>举个例子，我这里列出几种 Redis 新增键值对的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET name &quot;xiaolincoding&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; HSET person name &quot;xiaolincoding&quot; age 18</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt; RPUSH stu &quot;xiaolin&quot; &quot;xiaomei&quot;</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p>这些命令代表着：</p>
<ul>
<li>第一条命令：name 是一个<strong>字符串键</strong>，因为键的<strong>值是一个字符串对象</strong>；</li>
<li>第二条命令：person 是一个<strong>哈希表键</strong>，因为键的<strong>值是一个包含两个键值对的哈希表对象</strong>；</li>
<li>第三条命令：stu 是一个<strong>列表键</strong>，因为键的<strong>值是一个包含两个元素的列表对象</strong>；</li>
</ul>
<p>这些键值对是如何保存在 Redis 中的呢？</p>
<p>Redis 是使用了一个「哈希表」保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>Redis 的哈希桶是怎么保存键值对数据的呢？</p>
<p>哈希桶存放的是指向键值对数据的指针（dictEntry*），这样通过指针就能找到键值对数据，然后因为键值对的值可以保存字符串对象和集合数据类型的对象，所以键值对的数据结构中并不是直接保存值本身，而是保存了 void * key 和 void * value 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 void * value 指针找到。</p>
<p>我这里画了一张 Redis 保存键值对所涉及到的数据结构。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f302fce6c92c0682024f47bf7579b44c.png"></p>
<p>这些数据结构的内部细节，我先不展开讲，后面在讲哈希表数据结构的时候，在详细的说说，因为用到的数据结构是一样的。这里先大概说下图中涉及到的数据结构的名字和用途：</p>
<ul>
<li>redisDb 结构，表示 Redis 数据库的结构，结构体里存放了指向了 dict 结构的指针；</li>
<li>dict 结构，结构体里存放了 2 个哈希表，正常情况下都是用「哈希表1」，「哈希表2」只有在 rehash 的时候才用，具体什么是 rehash，我在本文的哈希表数据结构会讲；</li>
<li>ditctht 结构，表示哈希表的结构，结构里存放了哈希表数组，数组中的每个元素都是指向一个哈希表节点结构（dictEntry）的指针；</li>
<li>dictEntry 结构，表示哈希表节点的结构，结构里存放了 **void * key 和 void * value 指针， _key 指向的是 String 对象，而 _value 则可以指向 String 对象，也可以指向集合类型的对象，比如 List 对象、Hash 对象、Set 对象和 Zset 对象__。</li>
</ul>
<p>特别说明下，void * key 和 void * value 指针指向的是 <strong>Redis 对象</strong>，Redis 中的每个对象都由 redisObject 结构表示，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/58d3987af2af868dca965193fb27c464.png"></p>
<p>对象结构里包含的成员变量：</p>
<ul>
<li>type，标识该对象是什么类型的对象（String 对象、 List 对象、Hash 对象、Set 对象和 Zset 对象）；</li>
<li>encoding，标识该对象使用了哪种底层的数据结构；</li>
<li><strong>ptr，指向底层数据结构的指针</strong>。</li>
</ul>
<p>我画了一张 Redis 键值对数据库的全景图，你就能清晰知道 Redis 对象和数据结构的关系了：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/3c386666e4e7638a07b230ba14b400fe.png"></p>
<p>接下里，就好好聊一下底层数据结构！</p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p>字符串在 Redis 中是很常用的，键值对中的键是字符串类型，值有时也是字符串类型。</p>
<p>Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。</p>
<p>既然 Redis 设计了 SDS 结构来表示字符串，肯定是 C 语言的 char* 字符数组存在一些缺陷。</p>
<p>要了解这一点，得先来看看 char* 字符数组的结构。</p>
<h3 id="C-语言字符串的缺陷"><a href="#C-语言字符串的缺陷" class="headerlink" title="C 语言字符串的缺陷"></a>C 语言字符串的缺陷</h3><p>C 语言的字符串其实就是一个字符数组，即数组中每个元素是字符串中的一个字符。</p>
<p>比如，下图就是字符串“xiaolin”的 char* 字符数组的结构：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/376128646c75a893ad47914858fa2131.png"></p>
<p>没学过 C 语言的同学，可能会好奇为什么最后一个字符是“\0”？</p>
<p>在 C 语言里，对字符串操作时，char * 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p>
<p>因此，C 语言标准库中的字符串操作函数就通过判断字符是不是 “\0” 来决定要不要停止操作，如果当前字符不是 “\0” ，说明字符串还没结束，可以继续操作，如果当前字符是 “\0” 是则说明字符串结束了，就要停止操作。</p>
<p>举个例子，C 语言获取字符串长度的函数 <code>strlen</code>，就是通过字符数组中的每一个字符，并进行计数，等遇到字符为 “\0” 后，就会停止遍历，然后返回已经统计到的字符个数，即为字符串长度。下图显示了 strlen 函数的执行流程：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/bcf6bde3b647bdc343efcbc1a8f10579.png"></p>
<p>很明显，**C 语言获取字符串长度的时间复杂度是 O（N）（<em>这是一个可以改进的地方</em>**）</p>
<p>C 语言字符串用 “\0” 字符作为结尾标记有个缺陷。假设有个字符串中有个 “\0” 字符，这时在操作这个字符串时就会<strong>提早结束</strong>，比如 “xiao\0lin” 字符串，计算字符串长度的时候则会是 4，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/6286480eb1840a8930e18fd215d82565.png"></p>
<p>因此，除了字符串的末尾之外，<strong>字符串里面不能含有 “\0” 字符</strong>，否则最先被程序读入的 “\0” 字符将被误认为是字符串结尾，这个限制使得 C 语言的字符串只能保存文本数据，<strong>不能保存像图片、音频、视频文化这样的二进制数据（_这也是一个可以改进的地方_）</strong></p>
<p>另外， C 语言标准库中字符串的操作函数是很不安全的，对程序员很不友好，稍微一不注意，就会导致缓冲区溢出。</p>
<p>举个例子，strcat 函数是可以将两个字符串拼接在一起。</p>
<p><strong>C 语言的字符串是不会记录自身的缓冲区大小的</strong>，所以 strcat 函数假定程序员在执行这个函数时，已经为 dest 分配了足够多的内存，可以容纳 src 字符串中的所有内容，而**一旦这个假定不成立，就会发生缓冲区溢出将可能会造成程序运行终止，（<em>这是一个可以改进的地方</em>**）。</p>
<p>而且，strcat 函数和 strlen 函数类似，时间复杂度也很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加，<strong>对字符串的操作效率不高</strong>。</p>
<p>好了， 通过以上的分析，我们可以得知 C 语言的字符串不足之处以及可以改进的地方：</p>
<ul>
<li>获取字符串长度的时间复杂度为 O（N）；</li>
<li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li>
<li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li>
</ul>
<p>Redis 实现的 SDS 的结构就把上面这些问题解决了，接下来我们一起看看 Redis 是如何解决的。</p>
<h3 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h3><p>下图就是 Redis 5.0 的 SDS 的数据结构：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/516738c4058cdf9109e40a7812ef4239.png"></p>
<p>结构中的每个成员变量分别介绍下：</p>
<ul>
<li><strong>len，记录了字符串长度</strong>。这样获取字符串长度的时候，只需要返回这个成员变量值就行，时间复杂度只需要 O（1）。</li>
<li><strong>alloc，分配给字符数组的空间长度</strong>。这样在修改字符串的时候，可以通过 <code>alloc - len</code> 计算出剩余的空间大小，可以用来判断空间是否满足修改需求，如果不满足的话，就会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出的问题。</li>
<li><strong>flags，用来表示不同类型的 SDS</strong>。一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64，后面在说明区别之处。</li>
<li><strong>buf[]，字符数组，用来保存实际数据</strong>。不仅可以保存字符串，也可以保存二进制数据。</li>
</ul>
<p>总的来说，Redis 的 SDS 结构在原本字符数组之上，增加了三个元数据：len、alloc、flags，用来解决 C 语言字符串的缺陷。</p>
<h4 id="O（1）复杂度获取字符串长度"><a href="#O（1）复杂度获取字符串长度" class="headerlink" title="O（1）复杂度获取字符串长度"></a>O（1）复杂度获取字符串长度</h4><p>C 语言的字符串长度获取 strlen 函数，需要通过遍历的方式来统计字符串长度，时间复杂度是 O（N）。</p>
<p>而 Redis 的 SDS 结构因为加入了 len 成员变量，那么<strong>获取字符串长度的时候，直接返回这个成员变量的值就行，所以复杂度只有 O（1）</strong>。</p>
<h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而是<strong>有个专门的 len 成员变量来记录长度，所以可存储包含 “\0” 的数据</strong>。但是 SDS 为了兼容部分 C 语言标准库的函数， SDS 字符串结尾还是会加上 “\0” 字符。</p>
<p>因此， SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。</p>
<p>通过使用二进制安全的 SDS，而不是 C 字符串，使得 Redis 不仅可以保存文本数据，也可以保存任意格式的二进制数据。</p>
<h4 id="不会发生缓冲区溢出"><a href="#不会发生缓冲区溢出" class="headerlink" title="不会发生缓冲区溢出"></a>不会发生缓冲区溢出</h4><p>C 语言的字符串标准库提供的字符串操作函数，大多数（比如 strcat 追加字符串函数）都是不安全的，因为这些函数把缓冲区大小是否满足操作需求的工作交由开发者来保证，程序内部并不会判断缓冲区大小是否足够用，当发生了缓冲区溢出就有可能造成程序异常结束。</p>
<p>所以，Redis 的 SDS 结构里引入了 alloc 和 len 成员变量，这样 SDS API 通过 <code>alloc - len</code> 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用。</p>
<p>而且，<strong>当判断出缓冲区大小不够用时，Redis 会自动将扩大 SDS 的空间大小</strong>，以满足修改所需的大小。</p>
<p>SDS 扩容的规则代码如下：</p>
<ul>
<li>如果所需的 sds 长度<strong>小于 1 MB</strong>，那么最后的扩容是按照<strong>翻倍扩容</strong>来执行的，即 2 倍的newlen</li>
<li>如果所需的 sds 长度<strong>超过 1 MB</strong>，那么最后的扩容长度应该是 newlen <strong>+ 1MB</strong>。</li>
</ul>
<p>在扩容 SDS 空间之前，SDS API 会优先检查未使用空间是否足够，如果不够的话，API 不仅会为 SDS 分配修改所必须要的空间，还会给 SDS 分配额外的「未使用空间」。</p>
<p>这样的好处是，下次在操作 SDS 时，如果 SDS 空间够的话，API 就会直接使用「未使用空间」，而无须执行内存分配，<strong>有效的减少内存分配次数</strong>。</p>
<p>所以，使用 SDS 即不需要手动修改 SDS 的空间大小，也不会出现缓冲区溢出的问题。</p>
<h4 id="节省内存空间"><a href="#节省内存空间" class="headerlink" title="节省内存空间"></a>节省内存空间</h4><p>SDS 结构中有个 flags 成员变量，表示的是 SDS 类型。</p>
<p>Redis 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。</p>
<p>这 5 种类型的主要<strong>区别就在于，它们数据结构中的 len 和 alloc 成员变量的数据类型不同</strong>。</p>
<p>比如 sdshdr16 和 sdshdr32 这两个类型，它们的定义分别如下：</p>
<p>可以看到：</p>
<ul>
<li>sdshdr16 类型的 len 和 alloc 的数据类型都是 uint16_t，表示字符数组长度和分配空间大小不能超过 2 的 16 次方。</li>
<li>sdshdr32 则都是 uint32_t，表示表示字符数组长度和分配空间大小不能超过 2 的 32 次方。</li>
</ul>
<p><strong>之所以 SDS 设计不同类型的结构体，是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。比如，在保存小字符串时，结构头占用空间也比较少。</p>
<p>除了设计不同类型的结构体，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<p>比如，sdshdr16 类型的 SDS，默认情况下，编译器会按照 2 字节对齐的方式给变量分配内存，这意味着，即使一个变量的大小不到 2 个字节，编译器也会给它分配 2 个字节。</p>
<p>举个例子，假设下面这个结构体，它有两个成员变量，类型分别是 char 和 int，如下所示：</p>
<p>大家猜猜这个结构体大小是多少？我先直接说答案，这个结构体大小计算出来是 8。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/35820959e8cf4376391c427ed7f81495.png"></p>
<p>这是因为默认情况下，编译器是使用「字节对齐」的方式分配内存，虽然 char 类型只占一个字节，但是由于成员变量里有 int 类型，它占用了 4 个字节，所以在成员变量为 char 类型分配内存时，会分配 4 个字节，其中这多余的 3 个字节是为了字节对齐而分配的，相当于有 3 个字节被浪费掉了。</p>
<p>如果不想编译器使用字节对齐的方式进行分配内存，可以采用了 <code>__attribute__ ((packed))</code> 属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p>
<p>比如，我用 <code>__attribute__ ((packed))</code> 属性定义下面的结构体 ，同样包含 char 和 int 两个类型的成员变量，代码如下所示：</p>
<p>这时打印的结果是 5（1 个字节 char + 4 字节 int）。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/47e6c8fbc17fd6c89bdfcb5eedaaacff.png"></p>
<p>可以看得出，这是按照实际占用字节数进行分配内存的，这样可以节省内存空间。</p>
<hr>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>大家最熟悉的数据结构除了数组之外，我相信就是链表了。</p>
<p>Redis 的 List 对象的底层实现之一就是链表。C 语言本身没有链表这个数据结构的，所以 Redis 自己设计了一个链表数据结构。</p>
<h3 id="链表节点结构设计"><a href="#链表节点结构设计" class="headerlink" title="链表节点结构设计"></a>链表节点结构设计</h3><p>先来看看「链表节点」结构的样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>有前置节点和后置节点，可以看的出，这个是一个双向链表。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/4fecbf7f63c73ec284a4821e0bfe2843.png"></p>
<h3 id="链表结构设计"><a href="#链表结构设计" class="headerlink" title="链表结构设计"></a>链表结构设计</h3><p>不过，Redis 在 listNode 结构体基础上又封装了 list 这个数据结构，这样操作起来会更方便，链表结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p>
<p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/cadf797496816eb343a19c2451437f1e.png"></p>
<h3 id="链表的优势与缺陷"><a href="#链表的优势与缺陷" class="headerlink" title="链表的优势与缺陷"></a>链表的优势与缺陷</h3><p>Redis 的链表实现优点如下：</p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；</li>
<li>list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；</li>
<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li>
</ul>
<p>链表的缺陷也是有的：</p>
<ul>
<li><p>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</p>
</li>
<li><p>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</p>
</li>
</ul>
<p>因此，Redis 3.0 的 List 对象在数据量比较少的情况下，会采用「压缩列表」作为底层数据结构的实现，它的优势是节省内存空间，并且是内存紧凑型的数据结构。</p>
<p>不过，压缩列表存在性能问题（具体什么问题，下面会说），所以 Redis 在 3.2 版本设计了新的数据结构 quicklist，并将 List 对象的底层数据结构改由 quicklist 实现。</p>
<p>然后在 Redis 5.0 设计了新的数据结构 listpack，沿用了压缩列表紧凑型的内存布局，最终在最新的 Redis 版本，将 Hash 对象和 Zset 对象的底层数据结构实现之一的压缩列表，替换成由 listpack 实现。</p>
<hr>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p>但是，压缩列表的缺陷也是有的：</p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<p>因此，Redis 对象（List 对象、Hash 对象、Zset 对象）包含的元素数量较少，或者元素值不大的情况才会使用压缩列表作为底层数据结构。</p>
<p>接下来，就跟大家详细聊下压缩列表。</p>
<h3 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h3><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/ab0b44f557f8b5bc7acb3a53d43ebfcb.png"></p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li><strong>zlbytes</strong>，记录整个压缩列表占用对内存字节数；</li>
<li><strong>zltail</strong>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><strong>zllen</strong>，记录压缩列表包含的节点数量；</li>
<li><strong>zlend</strong>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>另外，压缩列表节点（entry）的构成如下：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/a3b1f6235cf0587115b21312fe60289c.png"></p>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li>_<strong>prevlen</strong>_，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li>
<li>_<strong>encoding</strong>_，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。</li>
<li>_<strong>data</strong>_，记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p>
<p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p>
<ul>
<li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关，如下图（下图中的 content 表示的是实际数据，即本文的 data 字段）：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BC%96%E7%A0%81.png"></p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码，也就是 encoding 长度为 1 字节。通过 encoding 确认了整数类型，就可以确认整数数据的实际大小了，比如如果 encoding 编码确认了数据是 int16 整数，那么 data 的长度就是 int16 的大小。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节&#x2F;2字节&#x2F;5字节的空间</strong>进行编码，encoding 编码的前两个 bit 表示数据的类型，后续的其他 bit 标识字符串数据的实际长度，即 data 的长度。</li>
</ul>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>压缩列表除了查找复杂度高的问题，还有一个问题。</p>
<p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<p>前面提到，压缩列表节点的 prevlen 属性会根据前一个节点的长度进行不同的空间大小分配：</p>
<ul>
<li>如果前一个<strong>节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果前一个<strong>节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>现在假设一个压缩列表中有多个连续的、长度在 250～253 之间的节点，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/462c6a65531667f2bcf420953b0aded9.png"></p>
<p>因为这些节点长度值小于 254 字节，所以 prevlen 属性需要用 1 字节的空间来保存这个长度值。</p>
<p>这时，如果将一个长度大于等于 254 字节的新节点加入到压缩列表的表头节点，即新节点将成为 e1 的前置节点，如下图：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/d1a6deff4672580609c99a5b06bf3429.png"></p>
<p>因为 e1 节点的 prevlen 属性只有 1 个字节大小，无法保存新节点的长度，此时就需要对压缩列表的空间重分配操作，并将 e1 节点的 prevlen 属性从原来的 1 字节大小扩展为 5 字节大小。</p>
<p>多米诺牌的效应就此开始。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/1f0e5ae7ab749078cadda5ba0ed98eac.png"></p>
<p>e1 原本的长度在 250～253 之间，因为刚才的扩展空间，此时 e1 的长度就大于等于 254 了，因此原本 e2 保存 e1 的 prevlen 属性也必须从 1 字节扩展至 5 字节大小。</p>
<p>正如扩展 e1 引发了对 e2 扩展一样，扩展 e2 也会引发对 e3 的扩展，而扩展 e3 又会引发对 e4 的扩展…. 一直持续到结尾。</p>
<p><strong>这种在特殊情况下产生的连续多次空间扩展操作就叫做「连锁更新」</strong>，就像多米诺牌的效应一样，第一张牌倒下了，推动了第二张牌倒下；第二张牌倒下，又推动了第三张牌倒下….，</p>
<h3 id="压缩列表的缺陷"><a href="#压缩列表的缺陷" class="headerlink" title="压缩列表的缺陷"></a>压缩列表的缺陷</h3><p>空间扩展操作也就是重新分配内存，因此<strong>连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能</strong>。</p>
<p>所以说，<strong>虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题</strong>。</p>
<p>因此，<strong>压缩列表只会用于保存的节点数量不多的场景</strong>，只要节点数量足够小，即使发生连锁更新，也是能接受的。</p>
<p>虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。</p>
<hr>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>Redis 的 Hash 对象的底层实现之一是压缩列表（最新 Redis 代码已将压缩列表替换成 listpack）。Hash 对象的另外一个底层实现就是哈希表。</p>
<p>哈希表优点在于，它<strong>能以 O(1) 的复杂度快速查询数据</strong>。</p>
<p>但是存在的风险也是有，在哈希表大小固定的情况下，随着数据不断增多，那么<strong>哈希冲突</strong>的可能性也会越高。</p>
<p>解决哈希冲突的方式，有很多种。</p>
<p><strong>Redis 采用了「链式哈希」来解决哈希冲突</strong>，在不扩容哈希表的前提下，将具有相同哈希值的数据串起来，形成链接起，以便这些数据在表中仍然可以被查询到。</p>
<h3 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h3><p>Redis 的哈希表结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值，总是等于 size - 1，这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>图 4-1 展示了一个大小为 <code>4</code> 的空哈希表 （没有包含任何键值对）。</p>
<p><img src="/./assets/graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png" alt="graphviz-bd3eecd927a4d8fc33b4a1c7f5957c52d67c5021.png (395×333)"></p>
<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数。</p>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<p>举个例子， 图 4-2 就展示了如何通过 <code>next</code> 指针， 将两个索引值相同的键 <code>k1</code> 和 <code>k0</code> 连接在一起。</p>
<p><img src="/./assets/graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png" alt="graphviz-d2641d962325fd58bf15d9fffb4208f70251a999.png (740×346)"></p>
<h4 id="字典-哈希表"><a href="#字典-哈希表" class="headerlink" title="字典&#x2F;哈希表"></a>字典&#x2F;哈希表</h4><p>Redis 中的字典由 <code>dict</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：</p>
<p><img src="/./assets/graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png" alt="graphviz-e73003b166b90094c8c4b7abbc8d59f691f91e27.png (721×532)"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[<span class="number">0</span>] 或者 ht[<span class="number">1</span>]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p><img src="/./assets/graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png" alt="graphviz-ca9c88ba1713cb595c4e0e4a17ef2042b0008621.png (581×359)"></p>
<p>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 <code>k0</code> 和 <code>v0</code> 添加到字典里面， 那么程序会先使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>

<p>计算键 <code>k0</code> 的哈希值。</p>
<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>

<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上， 如图 4-5 所示。</p>
<p><img src="/./assets/graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png" alt="graphviz-2369cb08288f5e59548355042c4c40cc4339e339.png (721×381)"></p>
<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</p>
<p>MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</p>
<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a target="_blank" rel="noopener" href="http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a> 。</p>
<h4 id="哈希冲突解决"><a href="#哈希冲突解决" class="headerlink" title="哈希冲突解决"></a>哈希冲突解决</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>举个例子， 假设程序要将键值对 <code>k2</code> 和 <code>v2</code> 添加到图 4-6 所示的哈希表里面， 并且计算得出 <code>k2</code> 的索引值为 <code>2</code> ， 那么键 <code>k1</code> 和 <code>k2</code> 将产生冲突， 而解决冲突的办法就是使用 <code>next</code> 指针将键 <code>k2</code> 和 <code>k1</code> 所在的节点连接起来， 如图 4-7 所示。</p>
<p><img src="/./assets/graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png" alt="graphviz-db40aa6d0f1265d74f1c1d12b8fa074c0bcda12a.png (569×367)"></p>
<p><img src="/./assets/graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png" alt="graphviz-4b52dcf6eb0768750e1c15480be3326ca37e05b3.png (740×367)"></p>
<p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 用头插法总是将新节点添加到链表的表头位置（因此插入操作的时间复杂度为 O(1)）。</p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的 <code>ht[1]</code>哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 <code>ht[0]</code> 当前包含的键值对数量 （也即是 <code>ht[0].used</code> 的值）<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。（TODO：没理解）</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<h5 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h5><p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>计算得出。</p>
<p>比如说， 对于一个大小为 <code>4</code> ， 包含 <code>4</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 4 / 4 = 1</span><br></pre></td></tr></table></figure>

<p>又比如说， 对于一个大小为 <code>512</code> ， 包含 <code>256</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 256 / 512 = 0.5</span><br></pre></td></tr></table></figure>

<h5 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h5><p>触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作</li>
<li>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</li>
</ul>
<p>触发 rehash 收缩条件：（TODO：待验证）</p>
<ul>
<li>当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</li>
</ul>
<h5 id="扩展哈希表"><a href="#扩展哈希表" class="headerlink" title="扩展哈希表"></a>扩展哈希表</h5><p>举个例子， 假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。 图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子。</li>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 <code>4</code> 改为了现在的 <code>8</code> 。</p>
<p><img src="/./assets/graphviz-93608325578e8e45848938ef420115bf2227639e.png" alt="graphviz-93608325578e8e45848938ef420115bf2227639e.png (721×533)"></p>
<p><img src="/./assets/graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png" alt="graphviz-b68acb4d868ec7d79a44935ce08a159746ca58da.png (721×678)"></p>
<p><img src="/./assets/graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png" alt="graphviz-92dc47e4329eabae941cddfd727b736ef738e8cf.png (721×676)"></p>
<p><img src="/./assets/graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png" alt="graphviz-fa28d986a72f1f48b83c7f959ea217b1f9527d3c.png (721×517)"></p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>上一节说过， 扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 <code>ht[0]</code> 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 <code>ht[1]</code> ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>图 4-12 至图 4-17 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 <code>rehashidx</code> 属性是如何变化的。</p>
<p><img src="/./assets/graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png" alt="graphviz-4c43eaf38cbca10d8d368a5144db6f3c69ab3d84.png (721×678)"></p>
<p><img src="/./assets/graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png" alt="graphviz-b91705b0d7a6c7fd5e37332a930534e0e136ae73.png (721×524)"></p>
<p><img src="/./assets/graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png" alt="graphviz-9e2996e6ca9665776062470cdac346e8fc255374.png (721×528)"></p>
<p><img src="/./assets/graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png" alt="graphviz-c871b5de1a7910aea237ca9dc86508b48da94769.png (721×609)"></p>
<p><img src="/./assets/graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png" alt="graphviz-3b31e4e08cc3e212f986039eb08ae77224cdeec9.png (721×676)"></p>
<p><img src="/./assets/graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png" alt="graphviz-86f810ac65c4e6ee58b17105dfeaa06973d8dd16.png (721×517)"></p>
<h5 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h5><p>在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<p>在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删（delete）、改（update），查（find）在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找。</p>
<h3 id="字典-哈希表API"><a href="#字典-哈希表API" class="headerlink" title="字典&#x2F;哈希表API"></a>字典&#x2F;哈希表API</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>dictCreate</code></td>
<td align="left">创建一个新的字典。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictAdd</code></td>
<td align="left">将给定的键值对添加到字典里面。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictReplace</code></td>
<td align="left">将给定的键值对添加到字典里面， 如果键已经存在于字典，那么用新值取代原有的值。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictFetchValue</code></td>
<td align="left">返回给定键的值。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictGetRandomKey</code></td>
<td align="left">从字典中随机返回一个键值对。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictDelete</code></td>
<td align="left">从字典中删除给定键所对应的键值对。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>dictRelease</code></td>
<td align="left">释放给定字典，以及字典中包含的所有键值对。</td>
<td align="left">O(N) ， <code>N</code> 为字典包含的键值对数量。</td>
</tr>
</tbody></table>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>整数集合（intset）是集合键(Set)的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD numbers 1 3 5 7 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<h3 id="整数集合实现"><a href="#整数集合实现" class="headerlink" title="整数集合实现"></a>整数集合实现</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合元素<strong>唯一</strong>且<strong>升序排列</strong>。</p>
<p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code> 数组是整数集合的底层实现： 整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p><code>length</code> 是 <code>contents</code> 数组中元素的总个数。</p>
<p>虽然 <code>intset</code> 结构将 <code>contents</code> 属性声明为 <code>int8_t</code> 类型的数组， 但实际上 <code>contents</code> 数组并不保存任何 <code>int8_t</code> 类型的值 —— <code>contents</code> 数组的真正类型取决于 <code>encoding</code> 属性的值：</p>
<ul>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 那么 <code>contents</code> 就是一个 <code>int16_t</code> 类型的数组， 数组里的每个项都是一个 <code>int16_t</code> 类型的整数值 （最小值为 <code>-32,768</code> ，最大值为 <code>32,767</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT32</code> ， 那么 <code>contents</code> 就是一个 <code>int32_t</code> 类型的数组， 数组里的每个项都是一个 <code>int32_t</code> 类型的整数值 （最小值为 <code>-2,147,483,648</code> ，最大值为 <code>2,147,483,647</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 那么 <code>contents</code> 就是一个 <code>int64_t</code> 类型的数组， 数组里的每个项都是一个 <code>int64_t</code> 类型的整数值 （最小值为 <code>-9,223,372,036,854,775,808</code> ，最大值为 <code>9,223,372,036,854,775,807</code> ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li><code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 表示整数集合的底层实现为 <code>int16_t</code> 类型的数组， 而集合保存的都是 <code>int16_t</code> 类型的整数值。</li>
<li><code>length</code> 属性的值为 <code>5</code> ， 表示整数集合包含五个元素。</li>
<li><code>contents</code> 数组按从小到大的顺序保存着集合中的五个元素。</li>
<li>因为每个集合元素都是 <code>int16_t</code> 类型的整数值， 所以 <code>contents</code> 数组的大小等于 <code>sizeof(int16_t) * 5 = 16 * 5 = 80</code> 位。</li>
</ul>
<p><img src="/./assets/graphviz-acf7fe010d7b09c5d2500c72eb555863e67ad74f-1698850011048-11.png" alt="graphviz-acf7fe010d7b09c5d2500c72eb555863e67ad74f.png (514×234)"></p>
<p>图 6-2 展示了另一个整数集合示例：</p>
<ul>
<li><code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 表示整数集合的底层实现为 <code>int64_t</code> 类型的数组， 而数组中保存的都是 <code>int64_t</code> 类型的整数值。</li>
<li><code>length</code> 属性的值为 <code>4</code> ， 表示整数集合包含四个元素。</li>
<li><code>contents</code> 数组按从小到大的顺序保存着集合中的四个元素。</li>
<li>因为每个集合元素都是 <code>int64_t</code> 类型的整数值， 所以 <code>contents</code> 数组的大小为 <code>sizeof(int64_t) * 4 = 64 * 4 = 256</code> 位。</li>
</ul>
<p><img src="/./assets/graphviz-878c08b90e7bbd02863d3e5cad116b36785ea30e.png" alt="graphviz-878c08b90e7bbd02863d3e5cad116b36785ea30e.png (552×234)"></p>
<p>虽然 <code>contents</code> 数组保存的四个整数值中， 只有 <code>-2675256175807981027</code> 是真正需要用 <code>int64_t</code> 类型来保存的， 而其他的 <code>1</code> 、 <code>3</code> 、 <code>5</code> 三个值都可以用 <code>int16_t</code> 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 <code>int16_t</code> 数组的整数集合添加一个 <code>int64_t</code> 类型的整数值时， 整数集合已有的所有元素都会被转换成 <code>int64_t</code> 类型， 所以 <code>contents</code> 数组保存的四个整数值都是 <code>int64_t</code> 类型的， 不仅仅是 <code>-2675256175807981027</code> 。</p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>举个例子， 假设现在有一个 <code>INTSET_ENC_INT16</code> 编码的整数集合， 集合中包含三个 <code>int16_t</code> 类型的元素， 如图 6-3 所示。</p>
<p><img src="/./assets/graphviz-21955e71222114585926ca37959be5d948b9ad2b.png" alt="graphviz-21955e71222114585926ca37959be5d948b9ad2b.png (464×234)"></p>
<p>因为每个元素都占用 <code>16</code> 位空间， 所以整数集合底层数组的大小为 <code>3 * 16 = 48</code> 位， 图 6-4 展示了整数集合的三个元素在这 <code>48</code> 位里的位置。</p>
<p><img src="/./assets/graphviz-eac3e19de3f8dd9c40f2302c7b2d10e73983cd5c.png" alt="graphviz-eac3e19de3f8dd9c40f2302c7b2d10e73983cd5c.png (469×144)"></p>
<p>现在， 假设我们要将类型为 <code>int32_t</code> 的整数值 <code>65535</code> 添加到整数集合里面， 因为 <code>65535</code> 的类型 <code>int32_t</code> 比整数集合当前所有元素的类型都要长， 所以在将 <code>65535</code> 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 <code>65535</code> ， 整数集合需要分配四个元素的空间， 因为每个 <code>int32_t</code> 整数值需要占用 <code>32</code> 位空间， 所以在空间重分配之后， 底层数组的大小将是 <code>32 * 4 = 128</code> 位， 如图 6-5 所示。</p>
<p><img src="/./assets/graphviz-63f486a40c957eb449a5836555915601a1be61d6.png" alt="graphviz-63f486a40c957eb449a5836555915601a1be61d6.png (542×144)"></p>
<p>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 <code>1</code> 、 <code>2</code> 、 <code>3</code> 仍然是 <code>int16_t</code> 类型， 这些元素还保存在数组的前 <code>48</code> 位里面， 所以程序接下来要做的就是将这三个元素转换成 <code>int32_t</code> 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 <code>3</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第三， 所以它将被移动到 <code>contents</code> 数组的索引 <code>2</code> 位置上， 也即是数组 <code>64</code> 位至 <code>95</code> 位的空间内， 如图 6-6 所示。</p>
<p><img src="/./assets/graphviz-b8d54b0b6f077fd7a618a9fc198350cb3301fe8a.png" alt="graphviz-b8d54b0b6f077fd7a618a9fc198350cb3301fe8a.png (823×207)"></p>
<p>接着， 因为元素 <code>2</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第二， 所以它将被移动到 <code>contents</code> 数组的索引 <code>1</code> 位置上， 也即是数组的 <code>32</code> 位至 <code>63</code> 位的空间内， 如图 6-7 所示。</p>
<p><img src="/./assets/graphviz-851e799be7671b59d22c1360c757f70871b1460a.png" alt="graphviz-851e799be7671b59d22c1360c757f70871b1460a.png (671×207)"></p>
<p>之后， 因为元素 <code>1</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第一， 所以它将被移动到 <code>contents</code> 数组的索引 <code>0</code> 位置上， 也即是数组的 <code>0</code> 位至 <code>31</code> 位的空间内， 如图 6-8 所示。</p>
<p><img src="/./assets/graphviz-a6e1fc86a05aa7dab4284dbdb027cedb96a5259a.png" alt="graphviz-a6e1fc86a05aa7dab4284dbdb027cedb96a5259a.png (561×207)"></p>
<p>然后， 因为元素 <code>65535</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第四， 所以它将被添加到 <code>contents</code> 数组的索引 <code>3</code> 位置上， 也即是数组的 <code>96</code> 位至 <code>127</code> 位的空间内， 如图 6-9 所示。</p>
<p><img src="/./assets/graphviz-c0a4fd52c53de90a8b70888f89c7b39df564fc6b.png" alt="graphviz-c0a4fd52c53de90a8b70888f89c7b39df564fc6b.png (547×240)"></p>
<p>最后， 程序将整数集合 <code>encoding</code> 属性的值从 <code>INTSET_ENC_INT16</code> 改为 <code>INTSET_ENC_INT32</code> ， 并将 <code>length</code> 属性的值从 <code>3</code> 改为 <code>4</code> ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p><img src="/./assets/graphviz-a1be785cf70da6f653415d42642a25931656fe76.png" alt="graphviz-a1be785cf70da6f653415d42642a25931656fe76.png (415×234)"></p>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 <code>INTSET_ENC_INT16</code> 编码升级为 <code>INTSET_ENC_INT64</code> 编码， 或者从 <code>INTSET_ENC_INT32</code> 编码升级为 <code>INTSET_ENC_INT64</code> 编码， 升级的过程都和上面展示的升级过程类似。</p>
<blockquote>
<p>升级之后新元素的摆放位置</p>
</blockquote>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 <code>0</code> ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 <code>length-1</code> ）。</li>
</ul>
<h4 id="升级好处"><a href="#升级好处" class="headerlink" title="升级好处"></a>升级好处</h4><h5 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h5><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 <code>int16_t</code> 类型的数组来保存 <code>int16_t</code> 类型的值， 只使用 <code>int32_t</code> 类型的数组来保存 <code>int32_t</code> 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h5 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h5><p>当然， 要让一个数组可以同时保存 <code>int16_t</code> 、 <code>int32_t</code> 、 <code>int64_t</code> 三种类型的值， 最简单的做法就是直接使用 <code>int64_t</code> 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 <code>int16_t</code> 类型或者 <code>int32_t</code> 类型的值， 数组都需要使用 <code>int64_t</code> 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 <code>int16_t</code> 类型的值， 那么整数集合的底层实现就会一直是 <code>int16_t</code> 类型的数组， 只有在我们要将 <code>int32_t</code> 类型或者 <code>int64_t</code> 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h4 id="降级？"><a href="#降级？" class="headerlink" title="降级？"></a>降级？</h4><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 <code>int64_t</code> 类型来保存的元素 <code>4294967295</code> 删除了， 整数集合的编码仍然会维持 <code>INTSET_ENC_INT64</code> ， 底层数组也仍然会是 <code>int64_t</code> 类型的， 如图 6-12 所示。</p>
<p><img src="/./assets/graphviz-66791e1245ddf710a39196b431ac5c90c287c64e.png" alt="graphviz-66791e1245ddf710a39196b431ac5c90c287c64e.png (548×234)"></p>
<p><img src="/./assets/graphviz-d3355e08bf0d2f1639075046eb80c940da7e5fc5.png" alt="graphviz-d3355e08bf0d2f1639075046eb80c940da7e5fc5.png (433×234)"></p>
<hr>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><ul>
<li><p>跳跃表是有序集合（zset）的底层实现之一， 除此之外它在 Redis 中没有其他应用。</p>
</li>
<li><p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能用跳表进行高效的范围查询，也能用哈希表进行高效单点查询。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Zset 对象在使用跳表作为数据结构的时候，是使用由「哈希表+跳表」组成的 struct zset，但是我们讨论的时候，都会说跳表是 Zset 对象的底层数据结构，而不会提及哈希表，是因为 struct zset 中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。</li>
</ul>
<h3 id="跳表实现"><a href="#跳表实现" class="headerlink" title="跳表实现"></a>跳表实现</h3><p>Redis 的跳跃表由 <code>zskiplistNode</code> 和 <code>zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于表示整个跳表，其中保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p>
<ul>
<li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code> 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<h4 id="跳表节点"><a href="#跳表节点" class="headerlink" title="跳表节点"></a>跳表节点</h4><p>跳跃表节点的实现由 <code>zskiplistNode</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="层"><a href="#层" class="headerlink" title="层"></a>层</h4><p>跳跃表节点的 <code>level</code> 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 <code>1</code> 层、 <code>3</code> 层和 <code>5</code> 层的节点， 因为 C 语言的数组索引总是从 <code>0</code> 开始的， 所以节点的第一层是 <code>level[0]</code> ， 而第二层是 <code>level[1]</code> ， 以此类推。</p>
<p><img src="/./assets/graphviz-1983e65fd518acd94a59d64f018bfa4d83655cb6.png" alt="img"></p>
<h4 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h4><p>每个层都有一个指向表尾方向的前进指针（<code>level[i].forward</code> 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：</p>
<ol>
<li>迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。</li>
<li>在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。</li>
<li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 <code>NULL</code> ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</li>
</ol>
<p><img src="/./assets/graphviz-e252c0a9575f171b9721162311df23889699cac9.png" alt="img"></p>
<h4 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h4><p>层的跨度（<code>level[i].span</code> 属性）用于记录同一层相邻两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 <code>NULL</code> 的所有前进指针的跨度都为 <code>0</code> ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 <code>3.0</code> 、 成员对象为 <code>o3</code> 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 <code>3</code> ， 所以目标节点在跳跃表中的排位为 <code>3</code> 。</p>
<p><img src="/./assets/graphviz-b5f725abb2be0255dce02cc1b9b404595edff320.png" alt="graphviz-b5f725abb2be0255dce02cc1b9b404595edff320.png (699×543)"></p>
<p>再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 <code>2.0</code> 、 成员对象为 <code>o2</code> 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 <code>1</code> 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。</p>
<p><img src="/./assets/graphviz-35aacc5673063633ae0decd516137022c304ac1b.png" alt="img"></p>
<h4 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h4><p>节点的后退指针（<code>backward</code> 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 <code>tail</code> 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 <code>NULL</code> 的后退指针， 于是访问结束。</p>
<p><img src="/./assets/graphviz-35029fe9a9dbed7001f6fee063c0b376bca6e54d.png" alt="img"></p>
<h4 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h4><p>节点的分值（<code>score</code> 属性）是一个 <code>double</code> 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（<code>obj</code> 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<p>举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 <code>10086.0</code> ， 但保存成员对象 <code>o1</code> 的节点却排在保存成员对象 <code>o2</code> 和 <code>o3</code> 的节点之前， 而保存成员对象 <code>o2</code> 的节点又排在保存成员对象 <code>o3</code> 的节点之前， 由此可见， <code>o1</code> 、 <code>o2</code> 、 <code>o3</code> 三个成员对象在字典中的排序为 <code>o1 &lt;= o2 &lt;= o3</code> 。</p>
<p><img src="/./assets/graphviz-2eca5f315d20b6ceb145dbce294dc00f979605f2.png" alt="graphviz-2eca5f315d20b6ceb145dbce294dc00f979605f2.png (772×543)"></p>
<h3 id="跳表API"><a href="#跳表API" class="headerlink" title="跳表API"></a>跳表API</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zslCreate</code></td>
<td align="left">创建一个新的跳跃表。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>zslFree</code></td>
<td align="left">释放给定跳跃表，以及表中包含的所有节点。</td>
<td align="left">O(N) ， <code>N</code> 为跳跃表的长度。</td>
</tr>
<tr>
<td align="left"><code>zslInsert</code></td>
<td align="left">将包含给定成员和分值的新节点添加到跳跃表中。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslDelete</code></td>
<td align="left">删除跳跃表中包含给定成员和分值的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslGetRank</code></td>
<td align="left">返回包含给定成员和分值的节点在跳跃表中的排位。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslGetElementByRank</code></td>
<td align="left">返回跳跃表在给定排位上的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslIsInRange</code></td>
<td align="left">给定一个分值范围（range）， 比如 <code>0</code> 到 <code>15</code> ， <code>20</code> 到 <code>28</code> ，诸如此类， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 <code>1</code> ，否则返回 <code>0</code> 。</td>
<td align="left">通过跳跃表的表头节点和表尾节点， 这个检测可以用 O(1) 复杂度完成。</td>
</tr>
<tr>
<td align="left"><code>zslFirstInRange</code></td>
<td align="left">给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) 。 <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslLastInRange</code></td>
<td align="left">给定一个分值范围， 返回跳跃表中最后一个符合这个范围的节点。</td>
<td align="left">平均 O(\log N) ，最坏 O(N) 。 <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByScore</code></td>
<td align="left">给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td align="left">O(N) ， <code>N</code> 为被删除节点数量。</td>
</tr>
<tr>
<td align="left"><code>zslDeleteRangeByRank</code></td>
<td align="left">给定一个排位范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td align="left">O(N) ， <code>N</code> 为被删除节点数量。</td>
</tr>
</tbody></table>
<h3 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h3><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<p>举个例子，下图有个 3 层级的跳表。</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.drawio.png"></p>
<p>如果要查找「元素：abcd，权重：4」的节点，查找的过程是这样的：</p>
<ul>
<li>先从头节点的最高层开始，L2 指向了「元素：abc，权重：3」节点，这个节点的权重比要查找节点的小，所以要访问该层上的下一个节点；</li>
<li>但是该层的下一个节点是空节点（ leve[2]指向的是空节点），于是就会跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[1];</li>
<li>「元素：abc，权重：3」节点的 leve[1] 的下一个指针指向了「元素：abcde，权重：4」的节点，然后将其和要查找的节点比较。虽然「元素：abcde，权重：4」的节点的权重和要查找的权重相同，但是当前节点的 SDS 类型数据「大于」要查找的数据，所以会继续跳到「元素：abc，权重：3」节点的下一层去找，也就是 leve[0]；</li>
<li>「元素：abc，权重：3」节点的 leve[0] 的下一个指针指向了「元素：abcd，权重：4」的节点，该节点正是要查找的节点，查询结束。</li>
</ul>
<h3 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h3><p>跳表的相邻两层的节点数量的比例会影响跳表的查询性能。</p>
<p>举个例子，下图的跳表，第二层的节点数量只有 1 个，而第一层的节点数量有 6 个。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/2802786ab4f52c1e248904e5cef33a74.png"></p>
<p>这时，如果想要查询节点 6，那基本就跟链表的查询复杂度一样，就需要在第一层的节点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。</p>
<p>**跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)**。</p>
<p>下图的跳表就是，相邻两层的节点数量的比例是 2 : 1。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/cdc14698f629c74bf5a239cc8a611aeb.png"></p>
<blockquote>
<p>那怎样才能维持相邻两层的节点数量的比例为 2 : 1 呢？</p>
</blockquote>
<p>如果采用新增节点或者删除节点时，来调整跳表节点以维持比例的方法的话，会带来额外的开销。</p>
<p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<p>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<p>虽然我前面讲解跳表的时候，图中的跳表的「头节点」都是 3 层高，但是其实<strong>如果层高最大限制是 64，那么在创建跳表「头节点」的时候，就会直接创建 64 层高的头节点</strong>。</p>
<p>如下代码，创建跳表时，头节点的 level 数组有 ZSKIPLIST_MAXLEVEL个元素（层），节点不存储任何 member 和 score 值，level 数组元素的 forward 都指向NULL， span值都为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，ZSKIPLIST_MAXLEVEL 定义的是最高的层数，Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32。</p>
<h3 id="为什么用跳表而不用平衡树？"><a href="#为什么用跳表而不用平衡树？" class="headerlink" title="为什么用跳表而不用平衡树？"></a>为什么用跳表而不用平衡树？</h3><p>这里插一个常见的面试题：为什么 Zset 的实现用跳表而不用平衡树（如 AVL树、红黑树等）？</p>
<p>简单翻译一下，主要是从内存占用、对范围查找的支持、实现难易程度这三方面总结的原因：</p>
<ul>
<li>它们不是非常内存密集型的。基本上由你决定。改变关于节点具有给定级别数的概率的参数将使其比 btree 占用更少的内存。</li>
<li>Zset 经常需要执行 ZRANGE 或 ZREVRANGE 的命令，即作为链表遍历跳表。通过此操作，跳表的缓存局部性至少与其他类型的平衡树一样好。</li>
<li>它们更易于实现、调试等。例如，由于跳表的简单性，我收到了一个补丁（已经在Redis master中），其中扩展了跳表，在 O(log(N) 中实现了 ZRANK。它只需要对代码进行少量修改。</li>
</ul>
<p>我再详细补充点：</p>
<ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一些</strong>。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1&#x2F;(1-p)，具体取决于参数 p 的大小。如果像 Redis里的实现一样，取 p&#x3D;1&#x2F;4，那么平均每个节点包含 1.33 个指针，比平衡树更有优势。</li>
<li><strong>在做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。</li>
<li><strong>从算法实现难度上来比较，跳表比平衡树要简单得多</strong>。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
</ul>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p>
<p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p>
<p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p>
<h3 id="quicklist-结构设计"><a href="#quicklist-结构设计" class="headerlink" title="quicklist 结构设计"></a>quicklist 结构设计</h3><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">//quicklist的链表头</span></span><br><span class="line">    <span class="comment">//quicklist的链表尾</span></span><br><span class="line">    quicklistNode *tail; </span><br><span class="line">    <span class="comment">//所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNodes的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;       </span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p>接下来看看，quicklistNode 的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="comment">//下一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="comment">//quicklistNode指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;              </span><br><span class="line">    <span class="comment">//压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;                </span><br><span class="line">    <span class="comment">//压缩列表的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;        <span class="comment">//ziplist中的元素个数 </span></span><br><span class="line">    ....</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p>
<p>我画了一张图，方便你理解 quicklist 数据结构。</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/f46cbe347f65ded522f1cc3fd8dba549.png"></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<p><strong>我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p>
<h3 id="listpack-结构设计"><a href="#listpack-结构设计" class="headerlink" title="listpack 结构设计"></a>listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p>
<p>我们先看看 listpack 结构：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/4d2dc376b5fd68dae70d9284ae82b73a.png"></p>
<p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p>
<p>每个 listpack 节点结构如下：</p>
<p><img src="https://cdn.xiaolincoding.com//mysql/other/c5fb0a602d4caaca37ff0357f05b0abf.png"></p>
<p>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<hr>
<blockquote>
<p>压缩列表的entry为什么要保存prevlen呢？listpack改成len之后不会影响功能吗？</p>
</blockquote>
<p>压缩列表的 entry 保存 prevlen 是为了实现节点从后往前遍历，知道前一个节点的长度，就可以计算前一个节点的偏移量。</p>
<p>listpack 一样可以支持从后往前遍历的。详细的算法可以看：<a target="_blank" rel="noopener" href="https://github.com/antirez/listpack/blob/master/listpack.c">https://github.com/antirez/listpack/blob/master/listpack.c</a> 里的lpDecodeBacklen函数，lpDecodeBacklen 函数就可以从当前列表项起始位置的指针开始，向左逐个字节解析，得到前一项的 entry-len 值。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/redis/redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">Redis数据类型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>32 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>用来存这些类型的值：</p>
<ul>
<li>字节字符串</li>
<li>整数</li>
<li>浮点数</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="数值增减"><a href="#数值增减" class="headerlink" title="数值增减"></a>数值增减</h3><table>
<thead>
<tr>
<th>Command</th>
<th align="left">Example use and description</th>
</tr>
</thead>
<tbody><tr>
<td>INCR</td>
<td align="left">INCR key-name—Increments the value stored at the key by 1</td>
</tr>
<tr>
<td>DECR</td>
<td align="left">DECR key-name—Decrements the value stored at the key by 1</td>
</tr>
<tr>
<td>INCRBY</td>
<td align="left">INCRBY key-name amount—Increments the value stored at the key by the provided integer value</td>
</tr>
<tr>
<td>DECRBY</td>
<td align="left">DECRBY key-name amount—Decrements the value stored at the key by the provided integer value</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td align="left">INCRBYFLOAT key-name amount—Increments the value stored at the key by the provided float value (available in &gt;&#x3D; Redis 2.6)</td>
</tr>
</tbody></table>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Example use and description</th>
</tr>
</thead>
<tbody><tr>
<td>APPEND</td>
<td>APPEND key-name value—Concatenates the provided value to the string already stored at the given key</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>GETRANGE key-name start end—Fetches the substring, including all characters from the start offset to the end offset, inclusive</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>SETRANGE key-name offset value—Sets the substring starting at the provided offset to the given value</td>
</tr>
<tr>
<td>GETBIT</td>
<td>GETBIT key-name offset—Treats the byte string as a bit string, and returns the value of the bit in the string at the provided bit offset</td>
</tr>
<tr>
<td>SETBIT</td>
<td>SETBIT key-name offset value—Treats the byte string as a bit string, and sets the value of the bit in the string at the provided bit offset</td>
</tr>
<tr>
<td>BITCOUNT</td>
<td>BITCOUNT key-name [start end]—Counts the number of 1 bits in the string, optionally starting and finishing at the provided byte offsets</td>
</tr>
<tr>
<td>BITOP</td>
<td>BITOP operation dest-key key-name [key-name …]—Performs one of the bitwise operations, AND , OR, XOR, or NOT , on the strings provided, storing the result in the destination key</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>GETRANGE</strong> AND <strong>SUBSTR</strong> In the past, GETRANGE was named SUBSTR, and the<br>Python client continues to use the substr() method name to fetch ranges from<br>the string. When using a version of Redis later than 2.6, you should use the get-<br>range() method, and use substr() for Redis versions before 2.6.</p>
</blockquote>
<blockquote>
<p>When writing to strings using SETRANGE and SETBIT , if the STRING wasn’t previously<br>long enough, Redis will automatically extend the STRING with nulls before updating<br>and writing the new data. When reading STRINGs with GETRANGE, any request for data<br>beyond the end of the STRING won’t be returned, but when reading bits with GETBIT ,<br>any bit beyond the end of the STRING is considered zero.</p>
</blockquote>
<p><img src="/./assets/image-20231108132049463.png" alt="image-20231108132049463"></p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p>
<ul>
<li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>**SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li>
<li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ul>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="普通字符串的基本操作："><a href="#普通字符串的基本操作：" class="headerlink" title="普通字符串的基本操作："></a>普通字符串的基本操作：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key-value 类型的值</span><br><span class="line">&gt; SET name lin</span><br><span class="line">OK</span><br><span class="line"># 根据 key 获得对应的 value</span><br><span class="line">&gt; GET name</span><br><span class="line">&quot;lin&quot;</span><br><span class="line"># 判断某个 key 是否存在</span><br><span class="line">&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line"># 返回 key 所储存的字符串值的长度</span><br><span class="line">&gt; STRLEN name</span><br><span class="line">(integer) 3</span><br><span class="line"># 删除某个 key 对应的值</span><br><span class="line">&gt; DEL name</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h3 id="批量设置"><a href="#批量设置" class="headerlink" title="批量设置 :"></a>批量设置 :</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 批量设置 key-value 类型的值</span><br><span class="line">&gt; MSET key1 value1 key2 value2 </span><br><span class="line">OK</span><br><span class="line"># 批量获取多个 key 对应的 value</span><br><span class="line">&gt; MGET key1 key2 </span><br><span class="line">1) &quot;value1&quot;</span><br><span class="line">2) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<h3 id="计数器（字符串的内容为整数的时候可以使用）："><a href="#计数器（字符串的内容为整数的时候可以使用）：" class="headerlink" title="计数器（字符串的内容为整数的时候可以使用）："></a>计数器（字符串的内容为整数的时候可以使用）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key-value 类型的值</span><br><span class="line">&gt; SET number 0</span><br><span class="line">OK</span><br><span class="line"># 将 key 中储存的数字值增一</span><br><span class="line">&gt; INCR number</span><br><span class="line">(integer) 1</span><br><span class="line"># 将key中存储的数字值加 10</span><br><span class="line">&gt; INCRBY number 10</span><br><span class="line">(integer) 11</span><br><span class="line"># 将 key 中储存的数字值减一</span><br><span class="line">&gt; DECR number</span><br><span class="line">(integer) 10</span><br><span class="line"># 将key中存储的数字值键 10</span><br><span class="line">&gt; DECRBY number 10</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<h3 id="过期（默认为永不过期）："><a href="#过期（默认为永不过期）：" class="headerlink" title="过期（默认为永不过期）："></a>过期（默认为永不过期）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置 key 在 60 秒后过期（该方法是针对已经存在的key设置过期时间）</span><br><span class="line">&gt; EXPIRE name  60 </span><br><span class="line">(integer) 1</span><br><span class="line"># 查看数据还有多久过期</span><br><span class="line">&gt; TTL name </span><br><span class="line">(integer) 51</span><br><span class="line"></span><br><span class="line">#设置 key-value 类型的值，并设置该key的过期时间为 60 秒</span><br><span class="line">&gt; SET key  value EX 60</span><br><span class="line">OK</span><br><span class="line">&gt; SETEX key  60 value</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="不存在就插入："><a href="#不存在就插入：" class="headerlink" title="不存在就插入："></a>不存在就插入：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不存在就插入（not exists）</span><br><span class="line">&gt;SETNX key value</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象"><a href="#缓存对象" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>使用 String 来缓存对象有两种方式：</p>
<ul>
<li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li>
<li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li>
</ul>
<h3 id="常规计数"><a href="#常规计数" class="headerlink" title="常规计数"></a>常规计数</h3><p>因为 Redis 处理命令是单线程，所以执行命令的过程是原子的。因此 String 数据类型适合计数场景，比如计算访问次数、点赞、转发、库存数量等等。</p>
<p>比如计算文章的阅读量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 初始化文章的阅读量</span><br><span class="line">&gt; SET aritcle:readcount:1001 0</span><br><span class="line">OK</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 1</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 2</span><br><span class="line">#阅读量+1</span><br><span class="line">&gt; INCR aritcle:readcount:1001</span><br><span class="line">(integer) 3</span><br><span class="line"># 获取对应文章的阅读量</span><br><span class="line">&gt; GET aritcle:readcount:1001</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：</p>
<ul>
<li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li>
</ul>
<p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>lock_key 就是 key 键；</li>
<li>unique_value 是客户端生成的唯一的标识；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。</p>
<p>可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。</p>
<h3 id="共享-Session-信息"><a href="#共享-Session-信息" class="headerlink" title="共享 Session 信息"></a>共享 Session 信息</h3><p>通常我们在开发后台管理系统时，会使用 Session 来保存用户的会话(登录)状态，这些 Session 信息会被保存在服务器端，但这只适用于单系统应用，如果是分布式系统此模式将不再适用。</p>
<p>例如用户一的 Session 信息被存储在服务器一，但第二次访问时用户一被分配到服务器二，这个时候服务器并没有用户一的 Session 信息，就会出现需要重复登录的问题，问题在于分布式系统每次会把请求随机分配到不同的服务器。</p>
<p>分布式系统单独存储 Session 流程图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session1.png"></p>
<p>因此，我们需要借助 Redis 对这些 Session 信息进行统一的存储和管理，这样无论请求发送到那台服务器，服务器都会去同一个 Redis 获取相关的 Session 信息，这样就解决了分布式系统下 Session 存储的问题。</p>
<p>分布式系统使用同一个 Redis 存储 Session 流程图：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Session2.png"></p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>列表存储有序字符串，两头增删</p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul>
<li>工作队列</li>
<li>最近浏览过的文章</li>
<li>收藏</li>
</ul>
<h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p>List 类型的底层数据结构是由<strong>双向链表或压缩列表</strong>实现的：</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>但是<strong>在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表</strong>。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="left">Command</th>
<th>Example use and description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RPUSH</td>
<td>RPUSH key-name value [value …]—Pushes the value(s) onto the right end of the list</td>
</tr>
<tr>
<td align="left">LPUSH</td>
<td>LPUSH key-name value [value …]—Pushes the value(s) onto the left end of the list</td>
</tr>
<tr>
<td align="left">RPOP</td>
<td>RPOP key-name—Removes and returns the rightmost item from the list</td>
</tr>
<tr>
<td align="left">LPOP</td>
<td>LPOP key-name—Removes and returns the leftmost item from the list</td>
</tr>
<tr>
<td align="left">LINDEX</td>
<td>LINDEX key-name offset—Returns the item at the given offset</td>
</tr>
<tr>
<td align="left">LRANGE</td>
<td>LRANGE key-name start end—Returns the items in the list at the offsets from start to end, inclusive</td>
</tr>
<tr>
<td align="left">LTRIM</td>
<td>LTRIM key-name start end—Trims the list to only include items at indices between start and end, inclusive</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span><br><span class="line">LPUSH key value [value ...] </span><br><span class="line"># 将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">RPUSH key value [value ...]</span><br><span class="line"># 移除并返回key列表的头元素</span><br><span class="line">LPOP key     </span><br><span class="line"># 移除并返回key列表的尾元素</span><br><span class="line">RPOP key </span><br><span class="line"></span><br><span class="line"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span><br><span class="line">LRANGE key start stop</span><br><span class="line"></span><br><span class="line"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BLPOP key [key ...] timeout</span><br><span class="line"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span><br><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。</p>
<p>我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。</p>
<h5 id="1、如何满足消息保序需求？"><a href="#1、如何满足消息保序需求？" class="headerlink" title="1、如何满足消息保序需求？"></a>1、如何满足消息保序需求？</h5><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/list%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" title="" alt="" width="792">

<ul>
<li><p>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</p>
</li>
<li><p>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</p>
</li>
</ul>
<p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p>
<p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个while(1)循环）。如果有新消息写入，RPOP命令就会返回结果，否则，RPOP命令返回空值，再继续循环。</p>
<p>所以，即使没有新消息写入List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p>
<p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p>
<img title="" src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.png" alt="" width="774">

<h5 id="2、如何处理重复的消息？"><a href="#2、如何处理重复的消息？" class="headerlink" title="2、如何处理重复的消息？"></a>2、如何处理重复的消息？</h5><p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p>
<ul>
<li>每个消息都有一个全局的 ID。</li>
<li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li>
</ul>
<p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p>
<p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; LPUSH mq &quot;111000102:stock:99&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h5 id="3、如何保证消息可靠性？"><a href="#3、如何保证消息可靠性？" class="headerlink" title="3、如何保证消息可靠性？"></a>3、如何保证消息可靠性？</h5><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p>
<p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<h5 id="List-作为消息队列有什么缺陷？"><a href="#List-作为消息队列有什么缺陷？" class="headerlink" title="List 作为消息队列有什么缺陷？"></a>List 作为消息队列有什么缺陷？</h5><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p>
<p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p>
<p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong>。</p>
<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 存储一个哈希表key的键值</span><br><span class="line">HSET key field value   </span><br><span class="line"># 获取哈希表key对应的field键值</span><br><span class="line">HGET key field</span><br><span class="line"></span><br><span class="line"># 在一个哈希表key中存储多个键值对</span><br><span class="line">HMSET key field value [field value...] </span><br><span class="line"># 批量获取哈希表key中多个field键值</span><br><span class="line">HMGET key field [field ...]       </span><br><span class="line"># 删除哈希表key中的field键值</span><br><span class="line">HDEL key field [field ...]    </span><br><span class="line"></span><br><span class="line"># 返回哈希表key中field的数量</span><br><span class="line">HLEN key       </span><br><span class="line"># 返回哈希表key中所有的键值</span><br><span class="line">HGETALL key </span><br><span class="line"></span><br><span class="line"># 为哈希表key中field键的值加上增量n</span><br><span class="line">HINCRBY key field n             </span><br></pre></td></tr></table></figure>

<h2 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="缓存对象-1"><a href="#缓存对象-1" class="headerlink" title="缓存对象"></a>缓存对象</h3><p>以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素，如下图所示。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%B4%AD%E7%89%A9%E8%BD%A6.png" title="" alt="" width="345">

<p>涉及的命令如下：</p>
<ul>
<li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li>
<li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li>
</ul>
<p>当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>The max size of a Redis set is 2^32 - 1 (4,294,967,295) members.</p>
<p>支持多个集合取交集、并集、差集。</p>
<h2 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h2><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><p>Set常用操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span><br><span class="line">SADD key member [member ...]</span><br><span class="line"># 从集合key中删除元素</span><br><span class="line">SREM key member [member ...] </span><br><span class="line"># 获取集合key中所有元素</span><br><span class="line">SMEMBERS key</span><br><span class="line"># 获取集合key中的元素个数</span><br><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line"># 判断member元素是否存在于集合key中</span><br><span class="line">SISMEMBER key member</span><br><span class="line"></span><br><span class="line"># 从集合key中随机选出count个元素，元素不从key中删除</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"># 从集合key中随机选出count个元素，元素从key中删除</span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure>

<p>Set运算操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 交集运算</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"># 将交集结果存入新集合destination中</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 并集运算</span><br><span class="line">SUNION key [key ...]</span><br><span class="line"># 将并集结果存入新集合destination中</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"># 差集运算</span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"># 将差集结果存入新集合destination中</span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li><p>去重</p>
</li>
<li><p>集合间运算</p>
</li>
</ul>
<p>这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<h3 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h3><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。</p>
<p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># uid:1 用户对文章 article:1 点赞</span><br><span class="line">&gt; SADD article:1 uid:1</span><br><span class="line">(integer) 1</span><br><span class="line"># uid:2 用户对文章 article:1 点赞</span><br><span class="line">&gt; SADD article:1 uid:2</span><br><span class="line">(integer) 1</span><br><span class="line"># uid:3 用户对文章 article:1 点赞</span><br><span class="line">&gt; SADD article:1 uid:3</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><code>uid:1</code> 取消了对 article:1 文章点赞。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>获取 article:1 文章所有点赞用户 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SMEMBERS article:1</span><br><span class="line">1) &quot;uid:3&quot;</span><br><span class="line">2) &quot;uid:2&quot;</span><br></pre></td></tr></table></figure>

<p>获取 article:1 文章的点赞用户数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SCARD article:1</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SISMEMBER article:1 uid:1</span><br><span class="line">(integer) 0  # 返回0说明没点赞，返回1则说明点赞了</span><br></pre></td></tr></table></figure>

<h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h3><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p>
<p>key 可以是用户id，value 则是已关注的公众号的id。</p>
<p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span><br><span class="line">&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(integer) 5</span><br><span class="line"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span><br><span class="line">&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取共同关注</span><br><span class="line">&gt; SINTER uid:1 uid:2</span><br><span class="line">1) &quot;7&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;9&quot;</span><br></pre></td></tr></table></figure>

<p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SDIFF uid:1 uid:2</span><br><span class="line">1) &quot;5&quot;</span><br><span class="line">2) &quot;6&quot;</span><br></pre></td></tr></table></figure>

<p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SISMEMBER uid:1 5</span><br><span class="line">(integer) 1 # 返回0，说明关注了</span><br><span class="line">&gt; SISMEMBER uid:2 5</span><br><span class="line">(integer) 0 # 返回0，说明没关注</span><br></pre></td></tr></table></figure>

<h3 id="抽奖"><a href="#抽奖" class="headerlink" title="抽奖"></a>抽奖</h3><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 抽取 1 个一等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky 1</span><br><span class="line">1) &quot;Tom&quot;</span><br><span class="line"># 抽取 2 个二等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky 2</span><br><span class="line">1) &quot;Mark&quot;</span><br><span class="line">2) &quot;Jerry&quot;</span><br><span class="line"># 抽取 3 个三等奖：</span><br><span class="line">&gt; SRANDMEMBER lucky 3</span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line">2) &quot;Tom&quot;</span><br><span class="line">3) &quot;Jerry&quot;</span><br></pre></td></tr></table></figure>

<p>如果不允许重复中奖，可以使用 SPOP 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 抽取一等奖1个</span><br><span class="line">&gt; SPOP lucky 1</span><br><span class="line">1) &quot;Sary&quot;</span><br><span class="line"># 抽取二等奖2个</span><br><span class="line">&gt; SPOP lucky 2</span><br><span class="line">1) &quot;Jerry&quot;</span><br><span class="line">2) &quot;Mark&quot;</span><br><span class="line"># 抽取三等奖3个</span><br><span class="line">&gt; SPOP lucky 3</span><br><span class="line">1) &quot;John&quot;</span><br><span class="line">2) &quot;Sean&quot;</span><br><span class="line">3) &quot;Lindy&quot;</span><br></pre></td></tr></table></figure>

<h1 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h1><p>有序集合。</p>
<blockquote>
<p>A Redis sorted set is a collection of unique strings (members) ordered by an associated score. When more than one string has the same score, the strings are ordered lexicographically.</p>
</blockquote>
<h2 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h2><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li><p>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用 <strong>压缩列表(ziplist)</strong> 作为 Zset 类型的底层数据结构；</p>
<ul>
<li><pre><code class="python"># redis.conf

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；</span><br><span class="line"></span><br><span class="line">**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**</span><br><span class="line"></span><br><span class="line">哈希表维护redis对象-&gt;分值映射，实现O(1)复杂度查找redis对象的分值；</span><br><span class="line"></span><br><span class="line">跳表维护分值-&gt;redis对象的映射，分值有序存储，实现有序集合。</span><br><span class="line"></span><br><span class="line">&gt;  * The elements are added to a hash table mapping Redis objects to scores.</span><br><span class="line">&gt; </span><br><span class="line">&gt;  * At the same time the elements are added to a skip list mapping scores</span><br><span class="line">&gt; </span><br><span class="line">&gt;  * to Redis objects (so objects are sorted by scores in this &quot;view&quot;).</span><br><span class="line"></span><br><span class="line">## 常用命令</span><br><span class="line"></span><br><span class="line">Zset 常用操作：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="往有序集合key中加入带分值元素"><a href="#往有序集合key中加入带分值元素" class="headerlink" title="往有序集合key中加入带分值元素"></a>往有序集合key中加入带分值元素</h1><p>ZADD key score member [[score member]…]   </p>
<h1 id="往有序集合key中删除元素"><a href="#往有序集合key中删除元素" class="headerlink" title="往有序集合key中删除元素"></a>往有序集合key中删除元素</h1><p>ZREM key member [member…]                 </p>
<h1 id="返回有序集合key中元素member的分值"><a href="#返回有序集合key中元素member的分值" class="headerlink" title="返回有序集合key中元素member的分值"></a>返回有序集合key中元素member的分值</h1><p>ZSCORE key member</p>
<h1 id="获取member的排名（从0开始）"><a href="#获取member的排名（从0开始）" class="headerlink" title="获取member的排名（从0开始）"></a>获取member的排名（从0开始）</h1><p>ZRANK key member</p>
<h1 id="返回有序集合key中元素个数"><a href="#返回有序集合key中元素个数" class="headerlink" title="返回有序集合key中元素个数"></a>返回有序集合key中元素个数</h1><p>ZCARD key </p>
<h1 id="为有序集合key中元素member的分值加上increment"><a href="#为有序集合key中元素member的分值加上increment" class="headerlink" title="为有序集合key中元素member的分值加上increment"></a>为有序集合key中元素member的分值加上increment</h1><p>ZINCRBY key increment member </p>
<h1 id="正序获取有序集合key从start下标到stop下标的元素"><a href="#正序获取有序集合key从start下标到stop下标的元素" class="headerlink" title="正序获取有序集合key从start下标到stop下标的元素"></a>正序获取有序集合key从start下标到stop下标的元素</h1><p>ZRANGE key start stop [WITHSCORES]</p>
<h1 id="倒序获取有序集合key从start下标到stop下标的元素"><a href="#倒序获取有序集合key从start下标到stop下标的元素" class="headerlink" title="倒序获取有序集合key从start下标到stop下标的元素"></a>倒序获取有序集合key从start下标到stop下标的元素</h1><p>ZREVRANGE key start stop [WITHSCORES]</p>
<h1 id="返回有序集合中指定分数区间内的成员，分数由低到高排序。"><a href="#返回有序集合中指定分数区间内的成员，分数由低到高排序。" class="headerlink" title="返回有序集合中指定分数区间内的成员，分数由低到高排序。"></a>返回有序集合中指定分数区间内的成员，分数由低到高排序。</h1><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</p>
<h1 id="返回指定成员区间内的成员，按字典正序排列-分数必须相同。"><a href="#返回指定成员区间内的成员，按字典正序排列-分数必须相同。" class="headerlink" title="返回指定成员区间内的成员，按字典正序排列, 分数必须相同。"></a>返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</h1><p>ZRANGEBYLEX key min max [LIMIT offset count]</p>
<h1 id="返回指定成员区间内的成员，按字典倒序排列-分数必须相同"><a href="#返回指定成员区间内的成员，按字典倒序排列-分数必须相同" class="headerlink" title="返回指定成员区间内的成员，按字典倒序排列, 分数必须相同"></a>返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</h1><p>ZREVRANGEBYLEX key max min [LIMIT offset count]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="并集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"><a href="#并集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积" class="headerlink" title="并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"></a>并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</h1><p>ZUNIONSTORE destkey numberkeys key [key…] </p>
<h1 id="交集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"><a href="#交集计算-相同元素分值相加-，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积" class="headerlink" title="交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积"></a>交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</h1><p>ZINTERSTORE destkey numberkeys key [key…]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line"># Connect to local Redis instance</span><br><span class="line">r = redis.Redis()</span><br><span class="line"></span><br><span class="line"># Define the name of your sorted set</span><br><span class="line">zset_name = &#x27;myzset&#x27;</span><br><span class="line"></span><br><span class="line"># ZADD: Add members to a sorted set, or update its score if it already exists</span><br><span class="line">r.zadd(zset_name, &#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;)</span><br><span class="line"></span><br><span class="line"># ZRANGE: Get a range of members in a sorted set, by index. -1 means the end of range.</span><br><span class="line"># Output: [b&#x27;one&#x27;, b&#x27;two&#x27;, b&#x27;three&#x27;]</span><br><span class="line">print(r.zrange(zset_name, 0, -1))  </span><br><span class="line"></span><br><span class="line"># ZRANK: Determine the index of a member in a sorted set</span><br><span class="line">print(r.zrank(zset_name, &#x27;one&#x27;))  # Output: 0</span><br><span class="line"></span><br><span class="line"># ZREM: Remove one or more members from a sorted set</span><br><span class="line">r.zrem(zset_name, &#x27;one&#x27;)</span><br><span class="line"></span><br><span class="line"># ZSCORE: Get the score associated with the given member in a sorted set</span><br><span class="line">print(r.zscore(zset_name, &#x27;two&#x27;))  # Output: 2.0</span><br><span class="line"></span><br><span class="line"># ZINCRBY: Increment the score of a member in a sorted set</span><br><span class="line">r.zincrby(zset_name, 1, &#x27;two&#x27;)</span><br><span class="line"></span><br><span class="line"># ZREVRANGE: Return a range of members in a sorted set, by index, with scores ordered from high to low.</span><br><span class="line"># Descending lexicographical order is used for elements with equal score, so &#x27;tw&#x27; is left to &#x27;th&#x27;</span><br><span class="line">print(r.zrevrange(zset_name, 0, -1))  # Output: [b&#x27;two&#x27;, b&#x27;three&#x27;]</span><br><span class="line"></span><br><span class="line"># ZCOUNT: Count the members in a sorted set with scores within the given values</span><br><span class="line">print(r.zcount(zset_name, 1, 3))  # Output: 2</span><br><span class="line"></span><br><span class="line"># ZCARD: Get the number of members in a sorted set</span><br><span class="line">print(r.zcard(zset_name))  # Output: 2</span><br><span class="line"></span><br><span class="line"># ZREMRANGEBYRANK: Remove all members in a sorted set within the given indexes</span><br><span class="line">r.zremrangebyrank(zset_name, 0, 1)</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p>
<p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># arcticle:1 文章获得了200个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 200 arcticle:1</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:2 文章获得了40个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 40 arcticle:2</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:3 文章获得了100个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 100 arcticle:3</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:4 文章获得了50个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 50 arcticle:4</span><br><span class="line">(integer) 1</span><br><span class="line"># arcticle:5 文章获得了150个赞</span><br><span class="line">&gt; ZADD user:xiaolin:ranking 150 arcticle:5</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZINCRBY user:xiaolin:ranking 1 arcticle:4</span><br><span class="line">&quot;51&quot;</span><br></pre></td></tr></table></figure>

<p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合key中元素个数）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZSCORE user:xiaolin:ranking arcticle:4</span><br><span class="line">&quot;50&quot;</span><br></pre></td></tr></table></figure>

<p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从start下标到stop下标的元素）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># WITHSCORES 表示把 score 也显示出来</span><br><span class="line">&gt; ZREVRANGE user:xiaolin:ranking 0 2 WITHSCORES</span><br><span class="line">1) &quot;arcticle:1&quot;</span><br><span class="line">2) &quot;200&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:3&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure>

<p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYSCORE user:xiaolin:ranking 100 200 WITHSCORES</span><br><span class="line">1) &quot;arcticle:3&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;arcticle:5&quot;</span><br><span class="line">4) &quot;150&quot;</span><br><span class="line">5) &quot;arcticle:1&quot;</span><br><span class="line">6) &quot;200&quot;</span><br></pre></td></tr></table></figure>

<h3 id="电话或姓名排序"><a href="#电话或姓名排序" class="headerlink" title="电话或姓名排序"></a>电话或姓名排序</h3><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p>
<h4 id="电话排序"><a href="#电话排序" class="headerlink" title="电话排序"></a>电话排序</h4><p>我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZADD phone 0 13100111100 0 13110114300 0 13132110901 </span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZADD phone 0 13200111100 0 13210414300 0 13252110901 </span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZADD phone 0 13300111100 0 13310414300 0 13352110901 </span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>获取所有号码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line">1) &quot;13100111100&quot;</span><br><span class="line">2) &quot;13110114300&quot;</span><br><span class="line">3) &quot;13132110901&quot;</span><br><span class="line">4) &quot;13200111100&quot;</span><br><span class="line">5) &quot;13210414300&quot;</span><br><span class="line">6) &quot;13252110901&quot;</span><br><span class="line">7) &quot;13300111100&quot;</span><br><span class="line">8) &quot;13310414300&quot;</span><br><span class="line">9) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>

<p>获取 132 号段的号码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [132 (133</span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br></pre></td></tr></table></figure>

<p>获取132、133号段的号码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX phone [132 (134</span><br><span class="line">1) &quot;13200111100&quot;</span><br><span class="line">2) &quot;13210414300&quot;</span><br><span class="line">3) &quot;13252110901&quot;</span><br><span class="line">4) &quot;13300111100&quot;</span><br><span class="line">5) &quot;13310414300&quot;</span><br><span class="line">6) &quot;13352110901&quot;</span><br></pre></td></tr></table></figure>

<h4 id="姓名排序"><a href="#姓名排序" class="headerlink" title="姓名排序"></a>姓名排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; zadd names 0 Toumas 0 Jake 0 Bluetuo 0 Gaodeng 0 Aimini 0 Aidehua </span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure>

<p>获取所有人的名字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names - +</span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br><span class="line">3) &quot;Bluetuo&quot;</span><br><span class="line">4) &quot;Gaodeng&quot;</span><br><span class="line">5) &quot;Jake&quot;</span><br><span class="line">6) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure>

<p>获取名字中大写字母A开头的所有人：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [A (B</span><br><span class="line">1) &quot;Aidehua&quot;</span><br><span class="line">2) &quot;Aimini&quot;</span><br></pre></td></tr></table></figure>

<p>获取名字中大写字母 C 到 Z 的所有人：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZRANGEBYLEX names [C [Z</span><br><span class="line">1) &quot;Gaodeng&quot;</span><br><span class="line">2) &quot;Jake&quot;</span><br><span class="line">3) &quot;Toumas&quot;</span><br></pre></td></tr></table></figure>

<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/bitmap.png" title="" alt="" width="695">

<h2 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h2><p>用 String 类型。</p>
<h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><p>bitmap 基本操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 设置值，其中value只能是 0 和 1</span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line"># 获取值</span><br><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line"># 获取指定范围内值为 1 的个数</span><br><span class="line"># start 和 end 以字节为单位</span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure>

<p>bitmap 运算操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">  AND 与运算 &amp;</span><br><span class="line">  OR 或运算 |</span><br><span class="line">  XOR 异或 ^</span><br><span class="line">  NOT 取反 ~</span><br><span class="line"># result 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定value(0/1)的位置</span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure>

<h2 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h2><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p>
<h3 id="签到统计"><a href="#签到统计" class="headerlink" title="签到统计"></a>签到统计</h3><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p>
<p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p>
<p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p>
<p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT uid:sign:100:202206 2 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户 6 月 3 日是否签到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT uid:sign:100:202206 2 </span><br></pre></td></tr></table></figure>

<p>第三步，统计该用户在 6 月份的签到次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT uid:sign:100:202206</span><br></pre></td></tr></table></figure>

<p>这样，我们就知道该用户在 6 月份的签到情况了。</p>
<blockquote>
<p>如何统计这个月首次打卡时间呢？</p>
</blockquote>
<p>Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。</p>
<p>在默认情况下， 命令将检测整个位图， 用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID &#x3D; 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITPOS uid:sign:100:202206 1</span><br></pre></td></tr></table></figure>

<p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1 。</p>
<h3 id="判断用户登陆状态"><a href="#判断用户登陆状态" class="headerlink" title="判断用户登陆状态"></a>判断用户登陆状态</h3><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p>
<p>只需要一个 key &#x3D; login_status 表示存储用户登陆状态集合数据， 将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。 5000 万用户只需要 6 MB 的空间。</p>
<p>假如我们要判断 ID &#x3D; 10086 的用户的登陆情况：</p>
<p>第一步，执行以下指令，表示用户已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 1</span><br></pre></td></tr></table></figure>

<p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT login_status 10086</span><br></pre></td></tr></table></figure>

<p>第三步，登出，将 offset 对应的 value 设置成 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT login_status 10086 0</span><br></pre></td></tr></table></figure>

<h3 id="连续签到用户总数"><a href="#连续签到用户总数" class="headerlink" title="连续签到用户总数"></a>连续签到用户总数</h3><p>如何统计出这连续 7 天连续打卡用户总数呢？</p>
<p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p>
<p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p>
<p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p>
<p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p>
<p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p>
<ul>
<li><code>operation</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li>
</ul>
<p>假设要统计 3 天连续打卡的用户数，则是将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计，如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 与操作</span><br><span class="line">BITOP AND destmap bitmap:01 bitmap:02 bitmap:03</span><br><span class="line"># 统计 bit 位 =  1 的个数</span><br><span class="line">BITCOUNT destmap</span><br></pre></td></tr></table></figure>

<p>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8&#x2F;8&#x2F;1024&#x2F;1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>消息队列。 </p>
<p>TODO</p>
<p>针对 Redis 是否适合做消息队列，关键看你的业务场景：</p>
<ul>
<li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li>
<li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/linux/zombie_process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/linux/zombie_process/" class="post-title-link" itemprop="url">Linux zombie process</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>654</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>You cannot kill a <code>&lt;defunct&gt;</code> process (also known as zombie process) as it is already dead. The system keeps zombie processes for the parent to collect the exit status. If the parent does not collect the exit status then the zombie processes will stay around forever. The only way to get rid of those zombie processes are by killing the parent. If the parent is init then you can only reboot.</p>
<p>Zombie processes take up almost no resouces so there is no performance cost in letting them linger. Although having zombie processes around usually means there is a bug in some of your programs. Init should usually collect all children. If init has zombie children then there is a bug in init (or somehwere else but a bug it is).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尝试复现：</span><br><span class="line"></span><br><span class="line">创建一个父进程是1的进程，然后kill掉它，他如果没有被init回收掉pid，就变成defunct</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/linux/soft_link_and_hard_link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/linux/soft_link_and_hard_link/" class="post-title-link" itemprop="url">Linux软链接和硬链接用法及区别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux软链接和硬链接"><a href="#Linux软链接和硬链接" class="headerlink" title="Linux软链接和硬链接"></a>Linux软链接和硬链接</h1><h2 id="创建软硬链接"><a href="#创建软硬链接" class="headerlink" title="创建软硬链接"></a>创建软硬链接</h2><p>Creating a symlink</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s myfile mylink</span><br></pre></td></tr></table></figure>

<p>Creating a hardlink</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln somefile somelink</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接与源文件共享inode（<code>ll -i</code> 第三列显示当前文件inode引用计数），删除源文件后（inode引用减一），硬链接还引用着，inode引用数为1，文件不删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># echo &quot;hh&quot; &gt; file</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ln file file_hard_link</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">115686215428339169 -rw-r--r-- 2 root root 3 Feb  6 16:45 file</span><br><span class="line">115686215428339169 -rw-r--r-- 2 root root 3 Feb  6 16:45 file_hard_link</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm file</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">115686215428339169 -rw-r--r-- 1 root root 3 Feb  6 16:45 file_hard_link</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># cat file_hard_link </span></span><br><span class="line">hh</span><br></pre></td></tr></table></figure>

<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接指向源文件的路径，删除源文件后，软连接指向失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ln -s file file_soft_link</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">115686215428339169 -rw-r--r-- 1 root root 3 Feb  6 16:45 file</span><br><span class="line">225179981368582177 lrwxrwxrwx 1 root root 4 Feb  6 16:48 file_soft_link -&gt; file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># rm -f file</span></span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">225179981368582177 lrwxrwxrwx 1 root root 4 Feb  6 16:48 file_soft_link -&gt; file</span><br><span class="line">[root@ZLPC-WangQingJia inode]<span class="comment"># cat file_soft_link </span></span><br><span class="line"><span class="built_in">cat</span>: file_soft_link: No such file or directory</span><br></pre></td></tr></table></figure>

<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><p><img src="/../assets/image-66.png" alt="Alt text"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> file</span><br><span class="line">$ <span class="built_in">ln</span> -s file file_soft_link</span><br><span class="line">$ <span class="built_in">ln</span> file file_hard_link</span><br><span class="line">$ ll -i</span><br><span class="line">total 0</span><br><span class="line">21955048184376494 -rw-r--r-- 2 root root 0 Feb  6 16:30 file</span><br><span class="line">21955048184376494 -rw-r--r-- 2 root root 0 Feb  6 16:30 file_hard_link        </span><br><span class="line">11258999069499309 lrwxrwxrwx 1 root root 4 Feb  6 16:30 file_soft_link -&gt; file</span><br></pre></td></tr></table></figure>

<ul>
<li>软链接inode私有，硬链接inode共享；</li>
<li>由于硬链接共享inode，而inode各个文件系统独立，因此硬链接不能跨文件系统；软链接支持跨文件系统，因为软连接指向的是文件的路径。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/linux/strace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/linux/strace/" class="post-title-link" itemprop="url">Linux strace</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>302</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="strace抓取ld链接器具体参数"><a href="#strace抓取ld链接器具体参数" class="headerlink" title="strace抓取ld链接器具体参数"></a>strace抓取ld链接器具体参数</h2><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/62562907/11850070">详见</a></p>
<p>strace参数解释：</p>
<ul>
<li><code>-o</code> forked.log save the output to forked.log  </li>
<li><code>-s</code> 1024 variables shorter than 1024 chars are not truncated (default 32 was not enough)  </li>
<li><code>-f</code> enables strace on forked processes  </li>
<li><code>-e trace=/exec</code> - filter system calls so only ones starting with exec are shown</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -o forked.log -s 1024 -f -e trace=/exec gcc hello.c.s -o hello_gcc</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/linux/wsl_proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/linux/wsl_proxy/" class="post-title-link" itemprop="url">wsl代理配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="wsl1-proxy"><a href="#wsl1-proxy" class="headerlink" title="wsl1 proxy"></a>wsl1 proxy</h1><p>勾选 “Allow LAN” 后，设置如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=&quot;http://127.0.0.1:7890&quot;</span><br></pre></td></tr></table></figure>

<h1 id="wsl2-proxy"><a href="#wsl2-proxy" class="headerlink" title="wsl2 proxy"></a>wsl2 proxy</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/592620059">https://zhuanlan.zhihu.com/p/592620059</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">hostip=$(cat /etc/resolv.conf | grep nameserver | awk &#x27;&#123; print $2 &#125;&#x27;)</span><br><span class="line">wslip=$(hostname -I | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line"># 这里填写主机代理的端口</span><br><span class="line">port=7890</span><br><span class="line"></span><br><span class="line">PROXY_HTTP=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;</span><br><span class="line"></span><br><span class="line">set_proxy()&#123;</span><br><span class="line">    export http_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">    export HTTP_PROXY=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"></span><br><span class="line">    export https_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">    export HTTPS_proxy=&quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line"></span><br><span class="line">    git config --global http.proxy &quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">    git config --global https.proxy &quot;$&#123;PROXY_HTTP&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unset_proxy()&#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset HTTP_PROXY</span><br><span class="line">    unset https_proxy</span><br><span class="line">    unset HTTPS_PROXY</span><br><span class="line">    git config --global --unset http.proxy</span><br><span class="line">    git config --global --unset https.proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test_setting()&#123;</span><br><span class="line">    echo &quot;Host ip:&quot; $&#123;hostip&#125;</span><br><span class="line">    echo &quot;WSL ip:&quot; $&#123;wslip&#125;</span><br><span class="line">    echo &quot;Current proxy:&quot; $https_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &quot;set&quot; ]</span><br><span class="line">then</span><br><span class="line">    set_proxy</span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;unset&quot; ]</span><br><span class="line">then</span><br><span class="line">    unset_proxy</span><br><span class="line"></span><br><span class="line">elif [ &quot;$1&quot; = &quot;test&quot; ]</span><br><span class="line">then</span><br><span class="line">    test_setting</span><br><span class="line">else</span><br><span class="line">    echo &quot;Unsupported arguments.&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/linux/linux%20tee%20cmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/linux/linux%20tee%20cmd/" class="post-title-link" itemprop="url">Linux tee cmd</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>159</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="linux-tee-cmd"><a href="#linux-tee-cmd" class="headerlink" title="linux tee cmd"></a>linux tee cmd</h1><p>tee 是 字母T的发音，将 | 左边的stdin 同时分流到 stdout 和 file 一份。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wqj@ubuntu-server:~/demo$ echo <span class="string">&quot;hello&quot;</span> | tee demo.txt</span><br><span class="line">hello</span><br><span class="line">wqj@ubuntu-server:~/demo$ cat demo.txt </span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/note/linux/nm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="折纸飞向麦田">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 折纸飞向麦田的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/19/note/linux/nm/" class="post-title-link" itemprop="url">linux nm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-19 20:08:28" itemprop="dateCreated datePublished" datetime="2024-02-19T20:08:28+08:00">2024-02-19</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="nm的使用"><a href="#nm的使用" class="headerlink" title="nm的使用"></a>nm的使用</h1><h2 id="按地址升序打印并demangle"><a href="#按地址升序打印并demangle" class="headerlink" title="按地址升序打印并demangle"></a>按地址升序打印并demangle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-C demangle symbols</span><br><span class="line">-n 按地址升序</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ nm -n -C demo</span><br><span class="line">                 U __cxa_atexit@@GLIBC_2.2.5</span><br><span class="line">                 w __gmon_start__</span><br><span class="line">                 U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">                 U std::ios_base::Init::Init()@@GLIBCXX_3.4</span><br><span class="line">0000000000400708 T _init</span><br><span class="line">00000000004007c0 T _start</span><br><span class="line">...</span><br><span class="line">0000000000601171 b std::__ioinit</span><br><span class="line">0000000000601178 B _end</span><br></pre></td></tr></table></figure>

<h2 id="分析C-vtable内容"><a href="#分析C-vtable内容" class="headerlink" title="分析C++ vtable内容"></a>分析C++ vtable内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;C::foo&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先用objdump取出vtable内若干符号的地址，然后用nm找出地址对应的符号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -C demangle</span></span><br><span class="line"><span class="comment"># -d disassemble</span></span><br><span class="line">[root@ZLPC-wangqingjia demo]<span class="comment"># objdump -C -d --section=.rodata demo</span></span><br><span class="line"></span><br><span class="line">demo:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">00000000004009b0 &lt;_IO_stdin_used&gt;:</span><br><span class="line">  4009b0:       01 00 02 00 00 00 00 00                             ........        </span><br><span class="line"></span><br><span class="line">00000000004009b8 &lt;__dso_handle&gt;:</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">00000000004009c0 &lt;std::piecewise_construct&gt;:</span><br><span class="line">  4009c0:       00 43 3a 3a 66 6f 6f 00                             .C::foo.        </span><br><span class="line"></span><br><span class="line">00000000004009c8 &lt;vtable <span class="keyword">for</span> C&gt;:</span><br><span class="line">        ...</span><br><span class="line">  4009d0:       e0 09 40 00 00 00 00 00 fa 08 40 00 00 00 00 00     ..@.......@.....</span><br><span class="line"></span><br><span class="line">00000000004009e0 &lt;typeinfo <span class="keyword">for</span> C&gt;:</span><br><span class="line">  4009e0:       b0 0d 60 00 00 00 00 00 f8 09 40 00 00 00 00 00     ..`.......@.....</span><br><span class="line">  4009f0:       00 0a 40 00 00 00 00 00                             ..@.....        </span><br><span class="line"></span><br><span class="line">00000000004009f8 &lt;typeinfo name <span class="keyword">for</span> C&gt;:</span><br><span class="line">  4009f8:       31 43 00 00 00 00 00 00                             1C......        </span><br><span class="line"></span><br><span class="line">0000000000400a00 &lt;typeinfo <span class="keyword">for</span> B&gt;:</span><br><span class="line">  400a00:       b0 0d 60 00 00 00 00 00 18 0a 40 00 00 00 00 00     ..`.......@.....</span><br><span class="line">  400a10:       20 0a 40 00 00 00 00 00                              .@.....        </span><br><span class="line"></span><br><span class="line">0000000000400a18 &lt;typeinfo name <span class="keyword">for</span> B&gt;:</span><br><span class="line">  400a18:       31 42 00 00 00 00 00 00                             1B......        </span><br><span class="line"></span><br><span class="line">0000000000400a20 &lt;typeinfo <span class="keyword">for</span> A&gt;:</span><br><span class="line">  400a20:       50 0d 60 00 00 00 00 00 30 0a 40 00 00 00 00 00     P.`.....0.@.....</span><br><span class="line"></span><br><span class="line">0000000000400a30 &lt;typeinfo name <span class="keyword">for</span> A&gt;:</span><br><span class="line">  400a30:       31 41 00                                            1A.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小端存储，数值低位在低地址</span></span><br><span class="line">[root@ZLPC-wangqingjia demo]<span class="comment"># nm -n -C demo | grep 4009e0</span></span><br><span class="line">00000000004009e0 V typeinfo <span class="keyword">for</span> C</span><br><span class="line">[root@ZLPC-wangqingjia demo]<span class="comment"># nm -n -C demo | grep 4008fa</span></span><br><span class="line">00000000004008fa W C::foo()</span><br></pre></td></tr></table></figure>

<p>而用 g++ -S 生成的反汇编为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vtable for C:</span><br><span class="line">	.quad	0</span><br><span class="line">	.quad	typeinfo for C</span><br><span class="line">	.quad	C::foo()</span><br><span class="line">	.weak	typeinfo for C</span><br><span class="line">	.section	.rodata._ZTI1C,&quot;aG&quot;,@progbits,typeinfo for C,comdat</span><br><span class="line">	.align 8</span><br><span class="line">	.type	typeinfo for C, @object</span><br><span class="line">	.size	typeinfo for C, 24</span><br></pre></td></tr></table></figure>

<p>每一列代表什么意思？</p>
<ul>
<li>符号值，即地址</li>
<li>符号类型, 一般小写是local，大写是global(external), 例外是：”u”,”v”,”w” 这三个小写的是global的。<ul>
<li>A - The symbol’s value is absolute, and will not be changed by further linking.</li>
<li>B&#x2F;b - The symbol is in the uninitialized data section (known as BSS).</li>
<li>C - The symbol is common.  Common symbols are uninitialized data.  When linking, multiple common symbols may appear with the same name.  If the symbol is defined anywhere, the common symbols are treated as undefined references. (没理解)</li>
<li>D&#x2F;d - The symbol is in the initialized data section.</li>
<li>G&#x2F;g - The symbol is in an initialized data section for small objects.  Some object file formats permit more efficient access to small data objects, such as a global int variable as opposed to a large global array.</li>
<li>I - The symbol is an indirect reference to another symbol.</li>
<li>i - For ELF format files this indicates that the symbol is an indirect function.  This is a GNU extension to the standard set of ELF symbol types.  It indicates a symbol which if referenced by a relocation does not evaluate to its address, but instead must be invoked at runtime. The runtime execution will then return the value to be used in the relocation.</li>
<li>N - The symbol is a debugging symbol.</li>
<li>p - The symbols is in a stack unwind section. (没理解)</li>
<li>R&#x2F;r - The symbol is in a read only data section.</li>
<li>S&#x2F;s - The symbol is in an uninitialized data section for small objects.</li>
<li>T&#x2F;t - The symbol is in the text (code) section.</li>
<li>U - The symbol is undefined.</li>
<li>u - The symbol is a unique global symbol.  This is a GNU extension to the standard set of ELF symbol bindings.  For such a symbol the dynamic linker will make sure that in the entire process there is just one symbol with this name and type in use.</li>
<li>V&#x2F;v - The symbol is a weak object.  When a weak defined symbol is linked with a normal defined symbol, the normal defined symbol is used with no error.  When a weak undefined symbol is linked and the symbol is not defined, the value of the weak symbol becomes zero with no error.  On some systems, uppercase indicates that a default value has been specified.</li>
<li>W&#x2F;w - The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</li>
<li>‘-‘ - The symbol is a stabs symbol in an a.out object file.  In this case, the next values printed are the stabs other field, the stabs desc field, and the stab type.  Stabs symbols are used to hold debugging information.</li>
<li>‘?’ - The symbol type is unknown, or object file format specific.</li>
</ul>
</li>
<li>符号名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@ZLPC-wangqingjia demo]# nm a.out -C | grep &quot;std::_Sp_counted_base&quot;</span><br><span class="line">0000000000400e40 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_destroy()</span><br><span class="line">0000000000400d48 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_release()</span><br><span class="line">0000000000400dc4 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_M_add_ref_copy()</span><br><span class="line">0000000000401370 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_Sp_counted_base()</span><br><span class="line">0000000000401370 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::_Sp_counted_base()</span><br><span class="line">0000000000400eee W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_base()</span><br><span class="line">0000000000400ed6 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_base()</span><br><span class="line">0000000000400ed6 W std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;::~_Sp_counted_base()</span><br><span class="line">00000000004018a8 V typeinfo for std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">00000000004018c0 V typeinfo name for std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br><span class="line">00000000004017f8 V vtable for std::_Sp_counted_base&lt;(__gnu_cxx::_Lock_policy)2&gt;</span><br></pre></td></tr></table></figure>


<h1 id="nm原理"><a href="#nm原理" class="headerlink" title="nm原理"></a>nm原理</h1><p>我很好奇 <code>nm</code> 怎么从elf目标文件中获取的符号信息。</p>
<p>用GDB跟一下，其实是调用 BFD 接口获取符号表。</p>
<blockquote>
<p>The first use is to read an object file. The object file readers are programs like ‘gdb’, ‘nm’, ‘objdump’, and ‘objcopy’. These programs use BFD to view an object file in a generic form. The official BFD interface is normally fully adequate for these programs. - bfd&#x2F;doc&#x2F;bfdint.texi</p>
</blockquote>
<p>gas、ld、nm、objdump、objcopy 这些工具，均借助BFD读写二进制目标文件。</p>
<p>所以要看BFD怎么从elf目标文件中获取符号表。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">折纸飞向麦田</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">197k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:29</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
